{"version":3,"sources":["../node_modules/@babel/traverse/lib/path/lib/hoister.js","../node_modules/@babel/traverse/lib/path/family.js","../node_modules/@babel/traverse/lib/path/comments.js","../node_modules/@babel/traverse/lib/visitors.js","../node_modules/@babel/traverse/lib/hub.js","../node_modules/@babel/traverse/lib/cache.js","../node_modules/@babel/traverse/lib/path/lib/virtual-types.js","../node_modules/@babel/traverse/lib/scope/index.js","../node_modules/@babel/traverse/lib/scope/binding.js","../node_modules/@babel/traverse/lib/index.js","../node_modules/@babel/traverse/lib/path/index.js","../node_modules/@babel/traverse/lib/context.js","../node_modules/@babel/traverse/lib/scope/lib/renamer.js","../node_modules/@babel/traverse/lib/path/ancestry.js","../node_modules/@babel/traverse/lib/path/inference/index.js","../node_modules/@babel/traverse/lib/path/inference/inferers.js","../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js","../node_modules/@babel/traverse/lib/path/replacement.js","../node_modules/@babel/traverse/lib/path/evaluation.js","../node_modules/@babel/traverse/lib/path/conversion.js","../node_modules/@babel/traverse/lib/path/introspection.js","../node_modules/@babel/traverse/lib/path/context.js","../node_modules/@babel/traverse/lib/path/removal.js","../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js","../node_modules/@babel/traverse/lib/path/modification.js"],"names":["Object","defineProperty","exports","value","default","t","obj","__esModule","cache","_getRequireWildcardCache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_interopRequireWildcard","require","WeakMap","referenceVisitor","ReferencedIdentifier","path","state","isJSXIdentifier","react","isCompatTag","node","name","parentPath","isJSXMemberExpression","scope","isFunction","isArrowFunctionExpression","parent","breakOnScopePaths","push","binding","getBinding","constantViolations","mutableBinding","stop","bindings","PathHoister","this","scopes","attachAfter","keys","bindingIdentifierEquals","identifier","isCompatibleScope","indexOf","_getAttachmentPath","targetScope","isProgram","hasOwnBinding","kind","parentKey","getAttachmentParentForPath","violationPath","pop","hasOwnParamBindings","getNextScopeAttachmentParent","bodies","i","length","_blockHoist","Array","isArray","container","isStatement","constant","traverse","getCompatibleScopes","attachTo","getAttachmentPath","getFunctionParent","uid","generateUidIdentifier","declarator","variableDeclarator","isVariableDeclarator","variableDeclaration","attached","isJSXElement","children","JSXExpressionContainer","replaceWith","cloneNode","getOpposite","getSibling","getCompletionRecords","paths","isIfStatement","addCompletionRecords","isDoExpression","isFor","isWhile","isBlockStatement","isTryStatement","isCatchClause","isSwitchStatement","cases","isLastCaseWithConsequent","consequent","breakStatement","findBreak","prevSibling","getPrevSibling","isExpressionStatement","remove","buildUndefinedNode","statementFinder","statement","some","completionRecordForSwitch","_index","listKey","setContext","context","getNextSibling","getAllNextSiblings","_key","sibling","siblings","getAllPrevSiblings","parts","split","_getKey","_getPattern","map","_","part","getBindingIdentifiers","duplicates","getOuterBindingIdentifiers","getBindingIdentifierPaths","outerOnly","search","concat","ids","create","id","shift","type","isIdentifier","_ids","isExportDeclaration","declaration","isDeclaration","isFunctionDeclaration","isFunctionExpression","child","getOuterBindingIdentifierPaths","statements","isLabeledStatement","_findBreak","_findBreak2","isBreakStatement","shareCommentsWithSiblings","trailing","trailingComments","leading","leadingComments","prev","next","hasPrev","Boolean","hasNext","addComments","addComment","content","line","comments","explode","verify","merge","visitors","states","wrapper","rootVisitor","visitor","visitorType","wrapWithStateOrWrapper","nodeVisitor","mergePair","virtualTypes","_exploded","nodeType","shouldIgnoreKey","fns","enter","ensureEntranceObjects","ensureCallbackArrays","wrapCheck","types","aliases","FLIPPED_ALIAS_KEYS","deprecratedKey","DEPRECATED_KEYS","console","trace","alias","existing","assign","_verified","Error","validateVisitorMethods","TYPES","visitorKey","val","fn","TypeError","oldVisitor","newVisitor","newFn","toString","exit","checkPath","apply","arguments","dest","src","Hub","msg","clear","clearPath","clearScope","ForAwaitStatement","NumericLiteralTypeAnnotation","ExistentialTypeParam","SpreadProperty","RestProperty","Flow","Pure","Generated","User","Var","BlockScoped","Referenced","Scope","Expression","Statement","BindingIdentifier","ReferencedMemberExpression","opts","isReferenced","isMemberExpression","grandparent","isBinding","isVariableDeclaration","isForXStatement","left","isForStatement","init","isReferencedIdentifier","isExpression","isScope","isBlockScoped","isVar","loc","isUser","isPure","isFlow","isImportDeclaration","importKind","exportKind","isImportSpecifier","isObjectPattern","isObjectExpression","await","_renamer","_interopRequireDefault","_binding","_globals","_cache","gatherNodeParts","isModuleDeclaration","source","specifiers","isModuleSpecifier","local","isLiteral","object","property","callee","properties","argument","expression","meta","openingElement","openingFragment","namespace","collectorVisitor","For","FOR_INIT_KEYS","declar","getProgramParent","registerBinding","Declaration","registerDeclaration","references","ForXStatement","isPattern","ExportDeclaration","isClassDeclaration","reference","declarations","decl","LabeledStatement","addGlobal","getBlockParent","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","Block","bodyPath","CatchClause","Function","NOT_LOCAL_BINDING","params","param","ClassExpression","cached","block","labels","Map","inited","generateUid","toIdentifier","replace","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","uids","defaultName","join","slice","generateUidBasedOnNode","isThisExpression","isSuper","dontPush","isStatic","generateUidIdentifierBasedOnNode","hub","buildError","oldName","newName","rename","sep","repeat","log","violations","allowArrayLike","isGenericType","isArrayExpression","callExpression","memberExpression","helperName","args","numericLiteral","unshift","addHelper","getLabel","label","registerLabel","specifier","unaryExpression","reassign","bindingPath","ReferenceError","declarators","getOwnBinding","checkBlockScopedCollisions","registerConstantViolation","globals","constantsOnly","isClass","superClass","body","isClassBody","method","isBinary","right","elements","elem","prop","isMethod","computed","isProperty","isUnaryExpression","isTaggedTemplateExpression","matchesPattern","tag","quasi","isTemplateLiteral","expressions","isPureish","data","crawl","programParent","crawling","ref","isLoop","ensureBlock","unique","blockHoist","dataKey","declarPath","getData","unshiftContainer","setData","isFunctionParent","isBlockParent","getBindingIdentifier","previousPath","_previousPath","_this$getBinding","noGlobals","parentHasBinding","hasUid","includes","contextVariables","_this$parent","info","removeOwnBinding","_this$getBinding2","findParent","p","builtin","Binding","referencePaths","referenced","clearValue","hasDeoptedValue","hasValue","enumerable","_path","_scope","_hub","_context","noScope","VISITOR_KEYS","hasDenylistedType","cheap","traverseFast","skipKeys","visit","clearNode","removeProperties","delete","tree","hasType","denylistTypes","denylist","SHOULD_SKIP","SHOULD_STOP","REMOVED","_debug","_generator","NodePath_ancestry","NodePath_inference","NodePath_replacement","NodePath_evaluation","NodePath_conversion","NodePath_introspection","NodePath_context","NodePath_removal","NodePath_modification","NodePath_family","NodePath_comments","debug","NodePath","contexts","_traverseFlags","def","undefined","SyntaxError","validate","inList","message","enabled","getPathLocation","code","v","targetNode","setup","typeKey","virtualType","TraversalContext","queue","notPriority","trap","priorityQueue","shouldVisit","visitQueue","visited","WeakSet","resync","pushContext","process","add","popContext","nodes","visitMultiple","visitSingle","_helperSplitExportDeclaration","renameVisitor","skip","Renamer","parentDeclar","maybeExportDeclar","isExportDefaultDeclaration","find","isClassExpression","maybeConvertFromExportDeclaration","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","callback","getStatementParent","isFile","getEarliestCommonAncestorFrom","getDeepestCommonAncestorFrom","deepest","ancestries","earliest","filter","lastCommonIndex","lastCommon","minDepth","Infinity","ancestry","first","depthLoop","shouldMatch","getAncestry","isAncestor","maybeDescendant","isDescendant","maybeAncestor","inType","getTypeAnnotation","typeAnnotation","_getTypeAnnotation","anyTypeAnnotation","isTypeAnnotation","declarParent","isForInStatement","stringTypeAnnotation","isForOfStatement","voidTypeAnnotation","typeAnnotationInferringNodes","_inferer","inferer","inferers","validParent","isBaseType","baseName","soft","_isBaseType","couldBeBaseType","isAnyTypeAnnotation","isUnionTypeAnnotation","type2","baseTypeStrictlyMatches","isFlowBaseAnnotation","genericName","isGenericTypeAnnotation","isStringTypeAnnotation","isNumberTypeAnnotation","isBooleanTypeAnnotation","isMixedTypeAnnotation","isEmptyTypeAnnotation","isVoidTypeAnnotation","VariableDeclarator","_type","isCallExpression","ArrayExpression","TypeCastExpression","NewExpression","genericTypeAnnotation","TemplateLiteral","NUMBER_UNARY_OPERATORS","numberTypeAnnotation","STRING_UNARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","booleanTypeAnnotation","BinaryExpression","NUMBER_BINARY_OPERATORS","BOOLEAN_BINARY_OPERATORS","unionTypeAnnotation","LogicalExpression","argumentTypes","isTSTypeAnnotation","createTSUnionType","createFlowUnionType","createUnionTypeAnnotation","ConditionalExpression","SequenceExpression","ParenthesizedExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","nullLiteralTypeAnnotation","RegExpLiteral","ObjectExpression","RestElement","ClassDeclaration","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","CallExpression","isObjectKeys","arrayTypeAnnotation","isArrayFrom","isObjectValues","isObjectEntries","tupleTypeAnnotation","resolveCall","TaggedTemplateExpression","_infererReference","buildMatchMemberExpression","resolve","is","returnType","functionConstantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","violation","getTypeAnnotationBindingConstantViolations","functions","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","target","typeofPath","typePath","BOOLEAN_NUMBER_BINARY_OPERATORS","typeValue","createTypeAnnotationBasedOnTypeof","isConditionalExpression","getParentConditionalPath","isLogicalExpression","isBinaryExpression","replaceWithMultiple","_pathCache$get","_verifyNodeList","inheritLeadingComments","inheritTrailingComments","insertAfter","requeue","replaceWithSourceString","replacement","_parser","parse","err","_codeFrame","codeFrameColumns","start","column","removed","_index2","nodePath","isNodeType","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","expressionStatement","replaceExpressionWithStatements","oldNode","inheritsComments","removeComments","_replaceWith","setScope","_pathCache$get2","toSequenceExpression","functionParent","isParentAsync","arrowFunctionExpression","blockStatement","hoistVariablesVisitor","completionRecords","loop","generateDeclaredUidIdentifier","pushContainer","returnStatement","assignmentExpression","arrowFunctionToExpression","FUNCTION_TYPES","awaitExpression","replaceInline","_containerInsertAfter","VariableDeclaration","exprs","evaluateTruthy","res","evaluate","confident","deoptPath","seen","evaluateCached","deopt","VALID_CALLEES","INVALID_METHODS","resolved","item","isSequenceExpression","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","evaluateQuasis","quasis","testResult","isExpressionWrapper","end","NaN","prefix","arg","arr","elems","elemValue","props","isObjectMethod","isSpreadElement","wasConfident","leftConfident","rightConfident","Math","pow","func","global","_evaluate","raw","str","cooked","expr","String","toComputedKey","stringLiteral","bodyNode","stringPath","arrowFunctionToShadowed","unwrapFunctionEnvironment","buildCodeFrameError","hoistFunctionEnvironment","allowInsertArrow","specCompliant","thisBinding","checkBinding","objectExpression","thisExpression","_helperFunctionName","fnPath","thisEnvFn","isClassProperty","static","inConstructor","getScopeInformation","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","allSuperCalls","ClassProperty","superBinding","getSuperBinding","forEach","superCall","argumentsBinding","argumentsChild","argsRef","newTargetBinding","metaProperty","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","standardizeSuperProperty","isAssignment","isAssignmentExpression","isCall","getSuperPropBinding","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","jsxIdentifier","assignmentPath","op","tmp","binaryExpression","isUpdateExpression","updateExpr","computedKey","sequenceExpression","isClassMethod","supers","argsBinding","restElement","super","spreadElement","propName","fnBody","argsList","valueIdent","cacheKey","ThisExpression","JSXIdentifier","isJSXOpeningElement","MemberExpression","MetaProperty","pattern","allowPartial","isnt","equals","isType","isCompletionRecord","allowInsideFunction","isStatementOrBlock","STATEMENT_OR_BLOCK_KEYS","referencesImport","moduleSource","importName","isImportDefaultSpecifier","isImportNamespaceSpecifier","imported","getSource","getCode","willIMaybeExecuteBefore","funcParent","getOuterFunction","_guessExecutionStatusRelativeToDifferentFunctions","commonPath","commonIndex","isExecutionUncertainInList","divergence","keyPosition","allStatus","executionOrderCheckedNodes","dangerous","_resolve","ret","isTypeCastExpression","targetKey","targetName","match","isNaN","isConstantExpression","isRegExpLiteral","every","isInStrictMode","sourceType","directives","isExecutionUncertain","maxIndex","_call","then","isBlacklisted","isDenylisted","_this$opts$denylist","blacklist","shouldSkip","shouldStop","skipKey","getScope","_resyncParent","_resyncList","_resyncKey","setKey","newContainer","_resyncRemoved","_markRemoved","_this$node","pathToQueue","maybeQueue","_getQueueContexts","_this$opts","_assertUnremoved","_removeFromScope","_callRemovalHooks","_remove","removeBinding","_removalHooks","hooks","splice","updateSiblingKeys","self","isSwitchCase","insertBefore","isExportNamedDeclaration","_containerInsertBefore","shouldInsertCurrentNode","_containerInsert","from","to","temp","fromIndex","incrementBy","constructor","hoist","hoister","_hoister","run"],"mappings":"+JAEAA,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQE,aAAU,EAElB,IAAIC,EAIJ,SAAiCC,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEF,QAASE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAMG,IAAIL,GAAQ,IAAIM,EAAS,GAAQC,EAAwBb,OAAOC,gBAAkBD,OAAOc,yBAA0B,IAAK,IAAIC,KAAOT,EAAO,GAAIN,OAAOgB,UAAUC,eAAeC,KAAKZ,EAAKS,GAAM,CAAE,IAAII,EAAON,EAAwBb,OAAOc,yBAAyBR,EAAKS,GAAO,KAAUI,IAASA,EAAKR,KAAOQ,EAAKC,KAAQpB,OAAOC,eAAeW,EAAQG,EAAKI,GAAgBP,EAAOG,GAAOT,EAAIS,GAAYH,EAAOR,QAAUE,EAASE,GAASA,EAAMY,IAAId,EAAKM,GAAW,OAAOA,EAJttBS,CAAwBC,EAAQ,KAExC,SAASb,IAA6B,GAAuB,oBAAZc,QAAwB,OAAO,KAAM,IAAIf,EAAQ,IAAIe,QAAqE,OAA1Dd,EAA2B,WAAc,OAAOD,GAAiBA,EAIlL,IAAMgB,EAAmB,CACvBC,qBADuB,SACFC,EAAMC,GACzB,IAAID,EAAKE,oBAAqBvB,EAAEwB,MAAMC,YAAYJ,EAAKK,KAAKC,OAAUN,EAAKO,WAAWC,wBAAtF,CAIA,GAAuB,SAAnBR,EAAKK,KAAKC,KAAiB,CAC7B,IAAIG,EAAQT,EAAKS,MAEjB,GACE,GAAIA,EAAMT,KAAKU,eAAiBD,EAAMT,KAAKW,4BACzC,YAEKF,EAAQA,EAAMG,QAEnBH,GAAOR,EAAMY,kBAAkBC,KAAKL,EAAMT,MAGhD,IAAMe,EAAUf,EAAKS,MAAMO,WAAWhB,EAAKK,KAAKC,MAChD,GAAKS,EAAL,CAlBgC,UAoBRA,EAAQE,oBApBA,IAoBhC,2BAAoD,CAClD,GADkD,QACpCR,QAAUM,EAAQf,KAAKS,MAGnC,OAFAR,EAAMiB,gBAAiB,OACvBlB,EAAKmB,QAvBuB,8BA4B5BJ,IAAYd,EAAMQ,MAAMO,WAAWhB,EAAKK,KAAKC,QACjDL,EAAMmB,SAASpB,EAAKK,KAAKC,MAAQS,OAK/BM,E,WACJ,WAAYrB,EAAMS,GAAO,UACvBa,KAAKT,kBAAoB,GACzBS,KAAKF,SAAW,GAChBE,KAAKJ,gBAAiB,EACtBI,KAAKC,OAAS,GACdD,KAAKb,MAAQA,EACba,KAAKtB,KAAOA,EACZsB,KAAKE,aAAc,E,oDAGHf,GAChB,cAAkBnC,OAAOmD,KAAKH,KAAKF,UAAnC,eAA8C,CAAzC,IAAM/B,EAAG,KACN0B,EAAUO,KAAKF,SAAS/B,GAE9B,IAAKoB,EAAMiB,wBAAwBrC,EAAK0B,EAAQY,YAC9C,OAAO,EAIX,OAAO,I,4CAIP,IAAIlB,EAAQa,KAAKtB,KAAKS,MAEtB,EAAG,CACD,IAAIa,KAAKM,kBAAkBnB,GAGzB,MAGF,GALEa,KAAKC,OAAOT,KAAKL,GAKfa,KAAKT,kBAAkBgB,QAAQpB,EAAMT,OAAS,EAChD,YAEKS,EAAQA,EAAMG,U,0CAIvB,IAAIZ,EAAOsB,KAAKQ,qBAEhB,GAAK9B,EAAL,CACA,IAAI+B,EAAc/B,EAAKS,MAMvB,GAJIsB,EAAY/B,OAASA,IACvB+B,EAAc/B,EAAKS,MAAMG,QAGvBmB,EAAY/B,KAAKgC,aAAeD,EAAY/B,KAAKU,aACnD,cAAmBpC,OAAOmD,KAAKH,KAAKF,UAApC,eAA+C,CAA1C,IAAMd,EAAI,KACb,GAAKyB,EAAYE,cAAc3B,GAA/B,CACA,IAAMS,EAAUO,KAAKF,SAASd,GAE9B,GAAqB,UAAjBS,EAAQmB,MAA+C,WAA3BnB,EAAQf,KAAKmC,UAM7C,GAF0Bb,KAAKc,2BAA2BrB,EAAQf,MAE5CX,KAAOW,EAAKX,IAAK,CACrCiC,KAAKE,aAAc,EACnBxB,EAAOe,EAAQf,KAFsB,UAITe,EAAQE,oBAJC,IAIrC,2BAAwD,KAA7CoB,EAA6C,QAClDf,KAAKc,2BAA2BC,GAAehD,IAAMW,EAAKX,MAC5DW,EAAOqC,IAN0B,iCAa3C,OAAOrC,K,2CAIP,IACMS,EADSa,KAAKC,OACCe,MACrB,GAAK7B,EAEL,GAAIA,EAAMT,KAAKU,aAAc,CAC3B,IAAIY,KAAKiB,oBAAoB9B,GAS3B,OAAOa,KAAKkB,+BARZ,GAAIlB,KAAKb,QAAUA,EAAO,OAG1B,IAFA,IAAMgC,EAAShC,EAAMT,KAAKf,IAAI,QAAQA,IAAI,QAEjCyD,EAAI,EAAGA,EAAID,EAAOE,OAAQD,IACjC,IAAID,EAAOC,GAAGrC,KAAKuC,YACnB,OAAOH,EAAOC,QAKb,GAAIjC,EAAMT,KAAKgC,YACpB,OAAOV,KAAKkB,iC,qDAKd,IAAM/B,EAAQa,KAAKC,OAAOe,MAC1B,GAAI7B,EAAO,OAAOa,KAAKc,2BAA2B3B,EAAMT,Q,iDAG/BA,GACzB,GACE,IAAKA,EAAKO,YAAcsC,MAAMC,QAAQ9C,EAAK+C,YAAc/C,EAAKgD,cAC5D,OAAOhD,QAEFA,EAAOA,EAAKO,c,0CAGHE,GAClB,cAAmBnC,OAAOmD,KAAKH,KAAKF,UAApC,eAA+C,CAA1C,IAAMd,EAAI,KACb,GAAKG,EAAMwB,cAAc3B,GAAzB,CACA,IAAMS,EAAUO,KAAKF,SAASd,GAC9B,GAAqB,UAAjBS,EAAQmB,MAAoBnB,EAAQkC,SAAU,OAAO,GAG3D,OAAO,I,4BAKP,GADA3B,KAAKtB,KAAKkD,SAASpD,EAAkBwB,OACjCA,KAAKJ,eAAT,CACAI,KAAK6B,sBACL,IAAMC,EAAW9B,KAAK+B,oBACtB,GAAKD,GACDA,EAASE,sBAAwBhC,KAAKtB,KAAKsD,oBAA/C,CACA,IAAIC,EAAMH,EAAS3C,MAAM+C,sBAAsB,OACzCC,EAAa9E,EAAE+E,mBAAmBH,EAAKjC,KAAKtB,KAAKK,MARnD,EAUe+C,EADF9B,KAAKE,YAAc,cAAgB,gBACd,CAAC4B,EAASO,uBAAyBF,EAAa9E,EAAEiF,oBAAoB,MAAO,CAACH,MAA7GI,EAVH,UAWEjD,EAASU,KAAKtB,KAAKO,WAOzB,OALIK,EAAOkD,gBAAkBxC,KAAKtB,KAAK+C,YAAcnC,EAAOP,KAAK0D,WAC/DR,EAAM5E,EAAEqF,uBAAuBT,IAGjCjC,KAAKtB,KAAKiE,YAAYtF,EAAEuF,UAAUX,IAC3BH,EAASO,uBAAyBE,EAAS5E,IAAI,QAAU4E,EAAS5E,IAAI,6B,KAKjFT,EAAQE,QAAU2C,G,8CC9LlB/C,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQ2F,YAyBR,WACE,GAAiB,SAAb7C,KAAKjC,IACP,OAAOiC,KAAK8C,WAAW,SAClB,GAAiB,UAAb9C,KAAKjC,IACd,OAAOiC,KAAK8C,WAAW,SA5B3B5F,EAAQ6F,qBAwGR,WACE,IAAIC,EAAQ,GAEZ,GAAIhD,KAAKiD,gBACPD,EAAQE,EAAqBlD,KAAKrC,IAAI,cAAeqF,GACrDA,EAAQE,EAAqBlD,KAAKrC,IAAI,aAAcqF,QAC/C,GAAIhD,KAAKmD,kBAAoBnD,KAAKoD,SAAWpD,KAAKqD,UACvDL,EAAQE,EAAqBlD,KAAKrC,IAAI,QAASqF,QAC1C,GAAIhD,KAAKU,aAAeV,KAAKsD,mBAClCN,EAAQE,EAAqBlD,KAAKrC,IAAI,QAAQqD,MAAOgC,OAChD,IAAIhD,KAAKZ,aACd,OAAOY,KAAKrC,IAAI,QAAQoF,uBACf/C,KAAKuD,kBACdP,EAAQE,EAAqBlD,KAAKrC,IAAI,SAAUqF,GAChDA,EAAQE,EAAqBlD,KAAKrC,IAAI,WAAYqF,IACzChD,KAAKwD,gBACdR,EAAQE,EAAqBlD,KAAKrC,IAAI,QAASqF,GACtChD,KAAKyD,oBACdT,EAvDJ,SAAmCU,EAAOV,GAGxC,IAFA,IAAIW,GAA2B,EAEtBvC,EAAIsC,EAAMrC,OAAS,EAAGD,GAAK,EAAGA,IAAK,CAC1C,IACMwC,EADaF,EAAMtC,GACKzD,IAAI,cAC9BkG,EAAiBC,EAAUF,GAE/B,GAAIC,EAAgB,CAClB,KAA8B,IAAvBA,EAAe9F,KAAa8F,EAAe5E,WAAWqE,oBAC3DO,EAAiBA,EAAe5E,WAGlC,IAAM8E,EAAcF,EAAeG,iBAE/BH,EAAe9F,IAAM,IAAMgG,EAAYE,yBAA2BF,EAAYT,qBAChFN,EAAQE,EAAqBa,EAAaf,GAC1Ca,EAAeK,WAEfL,EAAelB,YAAYkB,EAAe1E,MAAMgF,sBAChDnB,EAAQE,EAAqBW,EAAgBb,SAEtCW,GAA0B,WACnC,IAAMS,EAAkB,SAAlBA,EAAkBC,GAAS,OAAKA,EAAUf,oBAAsBe,EAAU1G,IAAI,QAAQ2G,KAAKF,IAE3ER,EAAWU,KAAKF,KAGpCpB,EAAQE,EAAqBU,EAAWA,EAAWvC,OAAS,GAAI2B,GAChEW,GAA2B,GAPM,GAYvC,OAAOX,EAqBGuB,CAA0BvE,KAAKrC,IAAI,SAAUqF,GAErDA,EAAMxD,KAAKQ,MAGb,OAAOgD,GA9HT9F,EAAQ4F,WAiIR,SAAoB/E,GAClB,OAAOyG,EAAOpH,QAAQO,IAAI,CACxBsB,WAAYe,KAAKf,WACjBK,OAAQU,KAAKV,OACbmC,UAAWzB,KAAKyB,UAChBgD,QAASzE,KAAKyE,QACd1G,IAAKA,IACJ2G,WAAW1E,KAAK2E,UAvIrBzH,EAAQ8G,eA0IR,WACE,OAAOhE,KAAK8C,WAAW9C,KAAKjC,IAAM,IA1IpCb,EAAQ0H,eA6IR,WACE,OAAO5E,KAAK8C,WAAW9C,KAAKjC,IAAM,IA7IpCb,EAAQ2H,mBAgJR,WACE,IAAIC,EAAO9E,KAAKjC,IACZgH,EAAU/E,KAAK8C,aAAagC,GAC1BE,EAAW,GAEjB,KAAOD,EAAQhG,MACbiG,EAASxF,KAAKuF,GACdA,EAAU/E,KAAK8C,aAAagC,GAG9B,OAAOE,GAzJT9H,EAAQ+H,mBA4JR,WACE,IAAIH,EAAO9E,KAAKjC,IACZgH,EAAU/E,KAAK8C,aAAagC,GAC1BE,EAAW,GAEjB,KAAOD,EAAQhG,MACbiG,EAASxF,KAAKuF,GACdA,EAAU/E,KAAK8C,aAAagC,GAG9B,OAAOE,GArKT9H,EAAQS,IAwKR,SAAaI,GAAqB,IAAhB4G,IAAgB,0DAChB,IAAZA,IAAkBA,EAAU3E,KAAK2E,SACrC,IAAMO,EAAQnH,EAAIoH,MAAM,KAExB,OAAqB,IAAjBD,EAAM7D,OACDrB,KAAKoF,QAAQrH,EAAK4G,GAElB3E,KAAKqF,YAAYH,EAAOP,IA9KnCzH,EAAQkI,QAkLR,SAAiBrH,EAAK4G,GAAS,WACvB5F,EAAOiB,KAAKjB,KACZ0C,EAAY1C,EAAKhB,GAEvB,OAAIwD,MAAMC,QAAQC,GACTA,EAAU6D,KAAI,SAACC,EAAGnE,GACvB,OAAOoD,EAAOpH,QAAQO,IAAI,CACxB8G,QAAS1G,EACTkB,WAAY,EACZK,OAAQP,EACR0C,UAAWA,EACX1D,IAAKqD,IACJsD,WAAWC,MAGTH,EAAOpH,QAAQO,IAAI,CACxBsB,WAAYe,KACZV,OAAQP,EACR0C,UAAW1C,EACXhB,IAAKA,IACJ2G,WAAWC,IArMlBzH,EAAQmI,YAyMR,SAAqBH,EAAOP,GAC1B,IADmC,EAC/BjG,EAAOsB,KADwB,IAGhBkF,GAHgB,IAGnC,2BAA0B,KAAfM,EAAe,QAEtB9G,EADW,MAAT8G,EACK9G,EAAKO,WAERsC,MAAMC,QAAQ9C,GACTA,EAAK8G,GAEL9G,EAAKf,IAAI6H,EAAMb,IAVO,8BAenC,OAAOjG,GAvNTxB,EAAQuI,sBA0NR,SAA+BC,GAC7B,OAAOrI,EAAEoI,sBAAsBzF,KAAKjB,KAAM2G,IA1N5CxI,EAAQyI,2BA6NR,SAAoCD,GAClC,OAAOrI,EAAEsI,2BAA2B3F,KAAKjB,KAAM2G,IA7NjDxI,EAAQ0I,0BAgOR,WAA0E,IAAvCF,EAAuC,wDAAnBG,EAAmB,wDAClEnH,EAAOsB,KACT8F,EAAS,GAAGC,OAAOrH,GACjBsH,EAAMhJ,OAAOiJ,OAAO,MAE1B,KAAOH,EAAOzE,QAAQ,CACpB,IAAM6E,EAAKJ,EAAOK,QAClB,GAAKD,GACAA,EAAGnH,KAAR,CACA,IAAMoB,EAAO9C,EAAEoI,sBAAsBtF,KAAK+F,EAAGnH,KAAKqH,MAElD,GAAIF,EAAGG,eACL,GAAIX,EAAY,CACd,IAAMY,EAAON,EAAIE,EAAGnH,KAAKC,MAAQgH,EAAIE,EAAGnH,KAAKC,OAAS,GAEtDsH,EAAK9G,KAAK0G,QAEVF,EAAIE,EAAGnH,KAAKC,MAAQkH,OAMxB,GAAIA,EAAGK,sBAAP,CACE,IAAMC,EAAcN,EAAGvI,IAAI,eAEvB6I,EAAYC,iBACdX,EAAOtG,KAAKgH,OAJhB,CAUA,GAAIX,EAAW,CACb,GAAIK,EAAGQ,wBAAyB,CAC9BZ,EAAOtG,KAAK0G,EAAGvI,IAAI,OACnB,SAGF,GAAIuI,EAAGS,uBACL,SAIJ,GAAIxG,EACF,IAAK,IAAIiB,EAAI,EAAGA,EAAIjB,EAAKkB,OAAQD,IAAK,CACpC,IAAMrD,EAAMoC,EAAKiB,GACXwF,EAAQV,EAAGvI,IAAII,IAEjBwD,MAAMC,QAAQoF,IAAUA,EAAM7H,QAChC+G,EAASA,EAAOC,OAAOa,OAM/B,OAAOZ,GAvRT9I,EAAQ2J,+BA0RR,SAAwCnB,GACtC,OAAO1F,KAAK4F,0BAA0BF,GAAY,IAzRpD,IAQgCpI,EAR5BkH,GAQ4BlH,EARIgB,EAAQ,MAQShB,EAAIC,WAAaD,EAAM,CAAEF,QAASE,GANnFD,EAIJ,SAAiCC,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEF,QAASE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAMG,IAAIL,GAAQ,IAAIM,EAAS,GAAQC,EAAwBb,OAAOC,gBAAkBD,OAAOc,yBAA0B,IAAK,IAAIC,KAAOT,EAAO,GAAIN,OAAOgB,UAAUC,eAAeC,KAAKZ,EAAKS,GAAM,CAAE,IAAII,EAAON,EAAwBb,OAAOc,yBAAyBR,EAAKS,GAAO,KAAUI,IAASA,EAAKR,KAAOQ,EAAKC,KAAQpB,OAAOC,eAAeW,EAAQG,EAAKI,GAAgBP,EAAOG,GAAOT,EAAIS,GAAYH,EAAOR,QAAUE,EAASE,GAASA,EAAMY,IAAId,EAAKM,GAAW,OAAOA,EAJttBS,CAAwBC,EAAQ,KAExC,SAASb,IAA6B,GAAuB,oBAAZc,QAAwB,OAAO,KAAM,IAAIf,EAAQ,IAAIe,QAAqE,OAA1Dd,EAA2B,WAAc,OAAOD,GAAiBA,EAclL,SAAS0F,EAAqBxE,EAAMsE,GAClC,OAAItE,EAAasE,EAAM+C,OAAOrH,EAAKqE,wBAC5BC,EAGT,SAASc,EAAUgD,GACjB,IAAIjD,EAECtC,MAAMC,QAAQsF,KACjBA,EAAa,CAACA,IAJa,UAOLA,GAPK,IAO7B,2BAAoC,KAAzBzC,EAAyB,QAClC,GAAIA,EAAUlB,kBAAoBkB,EAAU3D,aAAe2D,EAAUf,oBAAsBe,EAAUb,iBAAmBa,EAAU0C,qBAChIlD,EAAiBC,EAAUO,EAAU1G,IAAI,cACpC,GAAI0G,EAAUpB,gBAAiB,CACpC,IAAI+D,EAEJnD,EAA0E,OAAxDmD,EAAalD,EAAUO,EAAU1G,IAAI,gBAA0BqJ,EAAalD,EAAUO,EAAU1G,IAAI,mBACjH,GAAI0G,EAAUd,iBAAkB,CACrC,IAAI0D,EAEJpD,EAAsE,OAApDoD,EAAcnD,EAAUO,EAAU1G,IAAI,WAAqBsJ,EAAcnD,EAAUO,EAAU1G,IAAI,iBAC1G0G,EAAU6C,qBACnBrD,EAAiBQ,GAGnB,GAAIR,EACF,OAAOA,GAvBkB,8BA2B7B,OAAO,O,kCCpET7G,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQiK,0BAUR,WACE,GAAwB,kBAAbnH,KAAKjC,IAAkB,OAClC,IAAMgB,EAAOiB,KAAKjB,KAClB,IAAKA,EAAM,OACX,IAAMqI,EAAWrI,EAAKsI,iBAChBC,EAAUvI,EAAKwI,gBACrB,IAAKH,IAAaE,EAAS,OAC3B,IAAME,EAAOxH,KAAK8C,WAAW9C,KAAKjC,IAAM,GAClC0J,EAAOzH,KAAK8C,WAAW9C,KAAKjC,IAAM,GAClC2J,EAAUC,QAAQH,EAAKzI,MACvB6I,EAAUD,QAAQF,EAAK1I,MAEzB2I,IAAYE,EACdJ,EAAKK,YAAY,WAAYT,GACpBQ,IAAYF,GACrBD,EAAKI,YAAY,UAAWP,IAxBhCpK,EAAQ4K,WA4BR,SAAoB1B,EAAM2B,EAASC,GACjC3K,EAAEyK,WAAW9H,KAAKjB,KAAMqH,EAAM2B,EAASC,IA5BzC9K,EAAQ2K,YA+BR,SAAqBzB,EAAM6B,GACzB5K,EAAEwK,YAAY7H,KAAKjB,KAAMqH,EAAM6B,IA9BjC,IAAI5K,EAIJ,SAAiCC,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEF,QAASE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAMG,IAAIL,GAAQ,IAAIM,EAAS,GAAQC,EAAwBb,OAAOC,gBAAkBD,OAAOc,yBAA0B,IAAK,IAAIC,KAAOT,EAAO,GAAIN,OAAOgB,UAAUC,eAAeC,KAAKZ,EAAKS,GAAM,CAAE,IAAII,EAAON,EAAwBb,OAAOc,yBAAyBR,EAAKS,GAAO,KAAUI,IAASA,EAAKR,KAAOQ,EAAKC,KAAQpB,OAAOC,eAAeW,EAAQG,EAAKI,GAAgBP,EAAOG,GAAOT,EAAIS,GAAYH,EAAOR,QAAUE,EAASE,GAASA,EAAMY,IAAId,EAAKM,GAAW,OAAOA,EAJttBS,CAAwBC,EAAQ,KAExC,SAASb,IAA6B,GAAuB,oBAAZc,QAAwB,OAAO,KAAM,IAAIf,EAAQ,IAAIe,QAAqE,OAA1Dd,EAA2B,WAAc,OAAOD,GAAiBA,I,8CCTlLR,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQgL,QAAUA,EAClBhL,EAAQiL,OAASA,EACjBjL,EAAQkL,MAqIR,SAAeC,GAGb,IAH6C,IAAtBC,EAAsB,uDAAb,GAAIC,EAAS,uCACvCC,EAAc,GAEXpH,EAAI,EAAGA,EAAIiH,EAAShH,OAAQD,IAAK,CACxC,IAAMqH,EAAUJ,EAASjH,GACnBzC,EAAQ2J,EAAOlH,GACrB8G,EAAQO,GAER,cAAmBzL,OAAOmD,KAAKsI,GAA/B,eAAyC,CAApC,IAAMrC,EAAI,KACTsC,EAAcD,EAAQrC,IAEtBzH,GAAS4J,KACXG,EAAcC,EAAuBD,EAAa/J,EAAO4J,IAG3D,IAAMK,EAAcJ,EAAYpC,GAAQoC,EAAYpC,IAAS,GAC7DyC,EAAUD,EAAaF,IAI3B,OAAOF,GAvJT,IAAIM,EAAezK,EAAwBC,EAAQ,MAE/CjB,EAAIgB,EAAwBC,EAAQ,KAExC,SAASb,IAA6B,GAAuB,oBAAZc,QAAwB,OAAO,KAAM,IAAIf,EAAQ,IAAIe,QAAqE,OAA1Dd,EAA2B,WAAc,OAAOD,GAAiBA,EAElL,SAASa,EAAwBf,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEF,QAASE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAMG,IAAIL,GAAQ,IAAIM,EAAS,GAAQC,EAAwBb,OAAOC,gBAAkBD,OAAOc,yBAA0B,IAAK,IAAIC,KAAOT,EAAO,GAAIN,OAAOgB,UAAUC,eAAeC,KAAKZ,EAAKS,GAAM,CAAE,IAAII,EAAON,EAAwBb,OAAOc,yBAAyBR,EAAKS,GAAO,KAAUI,IAASA,EAAKR,KAAOQ,EAAKC,KAAQpB,OAAOC,eAAeW,EAAQG,EAAKI,GAAgBP,EAAOG,GAAOT,EAAIS,GAAyE,OAA7DH,EAAOR,QAAUE,EAASE,GAASA,EAAMY,IAAId,EAAKM,GAAkBA,EAE9tB,SAASsK,EAAQO,GACf,GAAIA,EAAQM,UAAW,OAAON,EAC9BA,EAAQM,WAAY,EAEpB,cAAuB/L,OAAOmD,KAAKsI,GAAnC,eAA6C,CAAxC,IAAMO,EAAQ,KACjB,IAAIC,EAAgBD,GAApB,CACA,IAAM9D,EAAQ8D,EAAS7D,MAAM,KAC7B,GAAqB,IAAjBD,EAAM7D,OAAV,CACA,IAAM6H,EAAMT,EAAQO,UACbP,EAAQO,GAL4B,UAOxB9D,GAPwB,IAO3C,2BAA0B,CACxBuD,EADwB,SACRS,GARyB,iCAY7Cf,EAAOM,UACAA,EAAQlL,WAgKjB,SAA+BD,GAC7B,cAAkBN,OAAOmD,KAAK7C,GAA9B,eAAoC,CAA/B,IAAMS,EAAG,KACZ,IAAIkL,EAAgBlL,GAApB,CACA,IAAMmL,EAAM5L,EAAIS,GAEG,oBAARmL,IACT5L,EAAIS,GAAO,CACToL,MAAOD,MAtKbE,CAAsBX,GACtBY,EAAqBZ,GAErB,cAAuBzL,OAAOmD,KAAKsI,GAAnC,eAA6C,CAAxC,IAAMO,EAAQ,KACjB,IAAIC,EAAgBD,GAApB,CACA,IAAMT,EAAUO,EAAaE,GAC7B,GAAKT,EAAL,CAGA,IAFA,IAAMW,EAAMT,EAAQO,GAEpB,MAAmBhM,OAAOmD,KAAK+I,GAA/B,eAAqC,CAAhC,IAAM9C,EAAI,KACb8C,EAAI9C,GAAQkD,EAAUf,EAASW,EAAI9C,IAKrC,UAFOqC,EAAQO,GAEXT,EAAQgB,MAAO,WACEhB,EAAQgB,OADV,IACjB,2BAAkC,KAAvBnD,EAAuB,QAC5BqC,EAAQrC,GACVyC,EAAUJ,EAAQrC,GAAO8C,GAEzBT,EAAQrC,GAAQ8C,GALH,oCASjBL,EAAUJ,EAASS,KAIvB,cAAuBlM,OAAOmD,KAAKsI,GAAnC,eAA6C,CAAxC,IAAMO,EAAQ,KACjB,IAAIC,EAAgBD,GAApB,CACA,IAAME,EAAMT,EAAQO,GAChBQ,EAAUnM,EAAEoM,mBAAmBT,GAC7BU,EAAiBrM,EAAEsM,gBAAgBX,GAOzC,GALIU,IACFE,QAAQC,MAAR,8BAAqCb,EAArC,uCAA4EU,IAC5EF,EAAU,CAACE,IAGRF,EAAL,QACOf,EAAQO,GAZ4B,UAcvBQ,GAduB,IAc3C,2BAA6B,KAAlBM,EAAkB,QACrBC,EAAWtB,EAAQqB,GAErBC,EACFlB,EAAUkB,EAAUb,GAEpBT,EAAQqB,GAAS9M,OAAOgN,OAAO,GAAId,IApBI,iCAyB7C,cAAuBlM,OAAOmD,KAAKsI,GAAnC,eAA6C,CAAxC,IAAMO,EAAQ,KACbC,EAAgBD,IACpBK,EAAqBZ,EAAQO,IAG/B,OAAOP,EAGT,SAASN,EAAOM,GACd,IAAIA,EAAQwB,UAAZ,CAEA,GAAuB,oBAAZxB,EACT,MAAM,IAAIyB,MAAM,6HAGlB,cAAuBlN,OAAOmD,KAAKsI,GAAnC,eAA6C,CAAxC,IAAMO,EAAQ,KAKjB,GAJiB,UAAbA,GAAqC,SAAbA,GAC1BmB,EAAuBnB,EAAUP,EAAQO,KAGvCC,EAAgBD,GAApB,CAEA,GAAI3L,EAAE+M,MAAM7J,QAAQyI,GAAY,EAC9B,MAAM,IAAIkB,MAAJ,kDAAqDlB,EAArD,+BAGR,IAAMX,EAAWI,EAAQO,GAEzB,GAAwB,kBAAbX,EACT,cAAyBrL,OAAOmD,KAAKkI,GAArC,eAAgD,CAA3C,IAAMgC,EAAU,KACnB,GAAmB,UAAfA,GAAyC,SAAfA,EAG5B,MAAM,IAAIH,MAAM,8DAAgE,GAAhE,OAAmElB,EAAnE,0CAA6GqB,IAF7HF,EAAuB,GAAD,OAAInB,EAAJ,YAAgBqB,GAAchC,EAASgC,MAQrE5B,EAAQwB,WAAY,GAGtB,SAASE,EAAuBzL,EAAM4L,GACpC,IADyC,EACnCpB,EAAM,GAAGnD,OAAOuE,GADmB,IAGxBpB,GAHwB,IAGzC,2BAAsB,KAAXqB,EAAW,QACpB,GAAkB,oBAAPA,EACT,MAAM,IAAIC,UAAJ,wCAA+C9L,EAA/C,6BAAwE6L,KALzC,+BAiC3C,SAAS5B,EAAuB8B,EAAY9L,EAAO4J,GAGjD,IAFA,IAAMmC,EAAa,GADuC,aAGrD,IAAM3M,EAAG,KACRmL,EAAMuB,EAAW1M,GACrB,IAAKwD,MAAMC,QAAQ0H,GAAM,iBACzBA,EAAMA,EAAI5D,KAAI,SAAUiF,GACtB,IAAII,EAAQJ,EAgBZ,OAdI5L,IACFgM,EAAQ,SAAUjM,GAChB,OAAO6L,EAAGrM,KAAKS,EAAOD,EAAMC,KAI5B4J,IACFoC,EAAQpC,EAAQ5J,EAAMZ,IAAKA,EAAK4M,IAG9BA,IAAUJ,IACZI,EAAMC,SAAW,kBAAML,EAAGK,aAGrBD,KAETD,EAAW3M,GAAOmL,GAtBpB,MAAkBlM,OAAOmD,KAAKsK,GAA9B,eAA2C,IAyB3C,OAAOC,EAgBT,SAASrB,EAAqB/L,GACxBA,EAAI6L,QAAU5H,MAAMC,QAAQlE,EAAI6L,SAAQ7L,EAAI6L,MAAQ,CAAC7L,EAAI6L,QACzD7L,EAAIuN,OAAStJ,MAAMC,QAAQlE,EAAIuN,QAAOvN,EAAIuN,KAAO,CAACvN,EAAIuN,OAG5D,SAASvB,EAAUf,EAASgC,GAC1B,IAAMI,EAAQ,SAAUjM,GACtB,GAAI6J,EAAQuC,UAAUpM,GACpB,OAAO6L,EAAGQ,MAAM/K,KAAMgL,YAM1B,OAFAL,EAAMC,SAAW,kBAAML,EAAGK,YAEnBD,EAGT,SAAS1B,EAAgBlL,GACvB,MAAe,MAAXA,EAAI,KACI,UAARA,GAA2B,SAARA,GAA0B,eAARA,IAE7B,aAARA,GAA8B,YAARA,GAA6B,aAARA,GAA8B,cAARA,IAOvE,SAAS8K,EAAUoC,EAAMC,GACvB,cAAkBlO,OAAOmD,KAAK+K,GAA9B,eAAoC,CAA/B,IAAMnN,EAAG,KACZkN,EAAKlN,GAAO,GAAGgI,OAAOkF,EAAKlN,IAAQ,GAAImN,EAAInN,O,sDC3O/Cf,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQE,aAAU,E,IAEZ+N,E,uJAMF,MAAM,IAAIjB,MAAM,mD,iCAGPnL,EAAMqM,GAAwB,IAAnBlB,EAAmB,uDAAXM,UAC5B,OAAO,IAAIN,EAAMkB,O,KAKrBlO,EAAQE,QAAU+N,G,iCCpBlBnO,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQmO,MASR,WACEC,IACAC,KAVFrO,EAAQoO,UAAYA,EACpBpO,EAAQqO,WAAaA,EACrBrO,EAAQiC,MAAQjC,EAAQwB,UAAO,EAC/B,IAAIA,EAAO,IAAIH,QACfrB,EAAQwB,KAAOA,EACf,IAAIS,EAAQ,IAAIZ,QAQhB,SAAS+M,IACPpO,EAAQwB,KAAOA,EAAO,IAAIH,QAG5B,SAASgN,IACPrO,EAAQiC,MAAQA,EAAQ,IAAIZ,QAZ9BrB,EAAQiC,MAAQA,G,iCCVhBnC,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQsO,kBAAoBtO,EAAQuO,6BAA+BvO,EAAQwO,qBAAuBxO,EAAQyO,eAAiBzO,EAAQ0O,aAAe1O,EAAQ2O,KAAO3O,EAAQ4O,KAAO5O,EAAQ6O,UAAY7O,EAAQ8O,KAAO9O,EAAQ+O,IAAM/O,EAAQgP,YAAchP,EAAQiP,WAAajP,EAAQkP,MAAQlP,EAAQmP,WAAanP,EAAQoP,UAAYpP,EAAQqP,kBAAoBrP,EAAQsP,2BAA6BtP,EAAQuB,0BAAuB,EAEra,IAAIpB,EAIJ,SAAiCC,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEF,QAASE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAMG,IAAIL,GAAQ,IAAIM,EAAS,GAAQC,EAAwBb,OAAOC,gBAAkBD,OAAOc,yBAA0B,IAAK,IAAIC,KAAOT,EAAO,GAAIN,OAAOgB,UAAUC,eAAeC,KAAKZ,EAAKS,GAAM,CAAE,IAAII,EAAON,EAAwBb,OAAOc,yBAAyBR,EAAKS,GAAO,KAAUI,IAASA,EAAKR,KAAOQ,EAAKC,KAAQpB,OAAOC,eAAeW,EAAQG,EAAKI,GAAgBP,EAAOG,GAAOT,EAAIS,GAAYH,EAAOR,QAAUE,EAASE,GAASA,EAAMY,IAAId,EAAKM,GAAW,OAAOA,EAJttBS,CAAwBC,EAAQ,KAExC,SAASb,IAA6B,GAAuB,oBAAZc,QAAwB,OAAO,KAAM,IAAIf,EAAQ,IAAIe,QAAqE,OAA1Dd,EAA2B,WAAc,OAAOD,GAAiBA,EAIlL,IAAMiB,EAAuB,CAC3B8K,MAAO,CAAC,aAAc,iBAEtBuB,UAH2B,SAGjBpM,EAAM+N,GAAM,IAElB1N,EAEEL,EAFFK,KACAO,EACEZ,EADFY,OAGF,IAAKjC,EAAEgJ,aAAatH,EAAM0N,KAAUpP,EAAE6B,sBAAsBI,EAAQmN,GAAO,CACzE,IAAIpP,EAAEuB,gBAAgBG,EAAM0N,GAG1B,OAAO,EAFP,GAAIpP,EAAEwB,MAAMC,YAAYC,EAAKC,MAAO,OAAO,EAM/C,OAAO3B,EAAEqP,aAAa3N,EAAMO,EAAQZ,EAAKO,WAAWK,UAIxDpC,EAAQuB,qBAAuBA,EAC/B,IAAM+N,EAA6B,CACjCjD,MAAO,CAAC,oBAERuB,UAHiC,YAM9B,IAFD/L,EAEC,EAFDA,KACAO,EACC,EADDA,OAEA,OAAOjC,EAAEsP,mBAAmB5N,IAAS1B,EAAEqP,aAAa3N,EAAMO,KAI9DpC,EAAQsP,2BAA6BA,EACrC,IAAMD,EAAoB,CACxBhD,MAAO,CAAC,cAERuB,UAHwB,SAGdpM,GAAM,IAEZK,EAEEL,EAFFK,KACAO,EACEZ,EADFY,OAEIsN,EAAclO,EAAKO,WAAWK,OACpC,OAAOjC,EAAEgJ,aAAatH,IAAS1B,EAAEwP,UAAU9N,EAAMO,EAAQsN,KAI7D1P,EAAQqP,kBAAoBA,EAC5B,IAAMD,EAAY,CAChB/C,MAAO,CAAC,aAERuB,UAHgB,YAMb,IAFD/L,EAEC,EAFDA,KACAO,EACC,EADDA,OAEA,GAAIjC,EAAEqE,YAAY3C,GAAO,CACvB,GAAI1B,EAAEyP,sBAAsB/N,GAAO,CACjC,GAAI1B,EAAE0P,gBAAgBzN,EAAQ,CAC5B0N,KAAMjO,IACJ,OAAO,EACX,GAAI1B,EAAE4P,eAAe3N,EAAQ,CAC3B4N,KAAMnO,IACJ,OAAO,EAGb,OAAO,EAEP,OAAO,IAKb7B,EAAQoP,UAAYA,EACpB,IAAMD,EAAa,CACjB9C,MAAO,CAAC,cAERuB,UAHiB,SAGPpM,GACR,OAAIA,EAAK2H,eACA3H,EAAKyO,yBAEL9P,EAAE+P,aAAa1O,EAAKK,QAKjC7B,EAAQmP,WAAaA,EACrB,IAAMD,EAAQ,CACZ7C,MAAO,CAAC,WAAY,WAEpBuB,UAHY,SAGFpM,GACR,OAAOrB,EAAEgQ,QAAQ3O,EAAKK,KAAML,EAAKY,UAIrCpC,EAAQkP,MAAQA,EAChB,IAAMD,EAAa,CACjBrB,UADiB,SACPpM,GACR,OAAOrB,EAAEqP,aAAahO,EAAKK,KAAML,EAAKY,UAI1CpC,EAAQiP,WAAaA,EACrB,IAAMD,EAAc,CAClBpB,UADkB,SACRpM,GACR,OAAOrB,EAAEiQ,cAAc5O,EAAKK,QAIhC7B,EAAQgP,YAAcA,EACtB,IAAMD,EAAM,CACV1C,MAAO,CAAC,uBAERuB,UAHU,SAGApM,GACR,OAAOrB,EAAEkQ,MAAM7O,EAAKK,QAIxB7B,EAAQ+O,IAAMA,EAOd/O,EAAQ8O,KANK,CACXlB,UADW,SACDpM,GACR,OAAOA,EAAKK,QAAUL,EAAKK,KAAKyO,MAWpCtQ,EAAQ6O,UANU,CAChBjB,UADgB,SACNpM,GACR,OAAQA,EAAK+O,WAWjBvQ,EAAQ4O,KANK,CACXhB,UADW,SACDpM,EAAM+N,GACd,OAAO/N,EAAKS,MAAMuO,OAAOhP,EAAKK,KAAM0N,KAKxC,IAAMZ,EAAO,CACXtC,MAAO,CAAC,OAAQ,oBAAqB,oBAAqB,mBAE1DuB,UAHW,YAKR,IADD/L,EACC,EADDA,KAEA,QAAI1B,EAAEsQ,OAAO5O,KAEF1B,EAAEuQ,oBAAoB7O,GACJ,SAApBA,EAAK8O,YAA6C,WAApB9O,EAAK8O,WACjCxQ,EAAEkJ,oBAAoBxH,GACJ,SAApBA,EAAK+O,aACHzQ,EAAE0Q,kBAAkBhP,KACF,SAApBA,EAAK8O,YAA6C,WAApB9O,EAAK8O,eAOhD3Q,EAAQ2O,KAAOA,EASf3O,EAAQ0O,aARa,CACnBrC,MAAO,CAAC,eAERuB,UAHmB,SAGTpM,GACR,OAAOA,EAAKO,YAAcP,EAAKO,WAAW+O,oBAa9C9Q,EAAQyO,eARe,CACrBpC,MAAO,CAAC,eAERuB,UAHqB,SAGXpM,GACR,OAAOA,EAAKO,YAAcP,EAAKO,WAAWgP,uBAQ9C/Q,EAAQwO,qBAHqB,CAC3BnC,MAAO,CAAC,yBAMVrM,EAAQuO,6BAH6B,CACnClC,MAAO,CAAC,gCAaVrM,EAAQsO,kBAVkB,CACxBjC,MAAO,CAAC,kBAERuB,UAHwB,YAMtB,OAAsB,IADrB,EADD/L,KAEYmP,S,qEC3MhBlR,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQE,aAAU,EAElB,IAAI+Q,EAAWC,EAAuB9P,EAAQ,MAE1CkG,EAAS4J,EAAuB9P,EAAQ,KAExC+P,EAAWD,EAAuB9P,EAAQ,MAE1CgQ,EAAWF,EAAuB9P,EAAQ,MAE1CjB,EAMJ,SAAiCC,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEF,QAASE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAMG,IAAIL,GAAQ,IAAIM,EAAS,GAAQC,EAAwBb,OAAOC,gBAAkBD,OAAOc,yBAA0B,IAAK,IAAIC,KAAOT,EAAO,GAAIN,OAAOgB,UAAUC,eAAeC,KAAKZ,EAAKS,GAAM,CAAE,IAAII,EAAON,EAAwBb,OAAOc,yBAAyBR,EAAKS,GAAO,KAAUI,IAASA,EAAKR,KAAOQ,EAAKC,KAAQpB,OAAOC,eAAeW,EAAQG,EAAKI,GAAgBP,EAAOG,GAAOT,EAAIS,GAAYH,EAAOR,QAAUE,EAASE,GAASA,EAAMY,IAAId,EAAKM,GAAW,OAAOA,EANttBS,CAAwBC,EAAQ,KAEpCiQ,EAASjQ,EAAQ,KAErB,SAASb,IAA6B,GAAuB,oBAAZc,QAAwB,OAAO,KAAM,IAAIf,EAAQ,IAAIe,QAAqE,OAA1Dd,EAA2B,WAAc,OAAOD,GAAiBA,EAIlL,SAAS4Q,EAAuB9Q,GAAO,OAAOA,GAAOA,EAAIC,WAAaD,EAAM,CAAEF,QAASE,GAEvF,SAASkR,EAAgBzP,EAAMmG,GAC7B,OAAgB,MAARnG,OAAe,EAASA,EAAKqH,MACnC,QACE,GAAI/I,EAAEoR,oBAAoB1P,GACxB,GAAIA,EAAK2P,OACPF,EAAgBzP,EAAK2P,OAAQxJ,QACxB,GAAInG,EAAK4P,YAAc5P,EAAK4P,WAAWtN,OAAQ,WACpCtC,EAAK4P,YAD+B,IACpD,4BAAiCH,EAAjC,QAAoDtJ,IADA,oCAE3CnG,EAAKyH,aACdgI,EAAgBzP,EAAKyH,YAAatB,QAE3B7H,EAAEuR,kBAAkB7P,GAC7ByP,EAAgBzP,EAAK8P,MAAO3J,GACnB7H,EAAEyR,UAAU/P,IACrBmG,EAAM1F,KAAKT,EAAK5B,OAGlB,MAEF,IAAK,mBACL,IAAK,2BACL,IAAK,sBACHqR,EAAgBzP,EAAKgQ,OAAQ7J,GAC7BsJ,EAAgBzP,EAAKiQ,SAAU9J,GAC/B,MAEF,IAAK,aACL,IAAK,gBACHA,EAAM1F,KAAKT,EAAKC,MAChB,MAEF,IAAK,iBACL,IAAK,yBACL,IAAK,gBACHwP,EAAgBzP,EAAKkQ,OAAQ/J,GAC7B,MAEF,IAAK,mBACL,IAAK,gBAAL,UACkBnG,EAAKmQ,YADvB,IACE,2BAAiC,CAC/BV,EAD+B,QACZtJ,IAFvB,8BAKE,MAEF,IAAK,gBACL,IAAK,cACHsJ,EAAgBzP,EAAKoQ,SAAUjK,GAC/B,MAEF,IAAK,iBACL,IAAK,eACL,IAAK,gBACL,IAAK,cACL,IAAK,uBACL,IAAK,qBACHsJ,EAAgBzP,EAAKhB,IAAKmH,GAC1B,MAEF,IAAK,iBACHA,EAAM1F,KAAK,QACX,MAEF,IAAK,QACH0F,EAAM1F,KAAK,SACX,MAEF,IAAK,SACH0F,EAAM1F,KAAK,UACX,MAEF,IAAK,eACH0F,EAAM1F,KAAK,MACX,MAEF,IAAK,kBACH0F,EAAM1F,KAAK,SACXgP,EAAgBzP,EAAKoQ,SAAUjK,GAC/B,MAEF,IAAK,kBACHA,EAAM1F,KAAK,SACXgP,EAAgBzP,EAAKoQ,SAAUjK,GAC/B,MAEF,IAAK,uBACHsJ,EAAgBzP,EAAKiO,KAAM9H,GAC3B,MAEF,IAAK,qBACHsJ,EAAgBzP,EAAKmH,GAAIhB,GACzB,MAEF,IAAK,qBACL,IAAK,sBACL,IAAK,kBACL,IAAK,mBAIL,IAAK,cACHsJ,EAAgBzP,EAAKmH,GAAIhB,GACzB,MAEF,IAAK,0BACHsJ,EAAgBzP,EAAKqQ,WAAYlK,GACjC,MAEF,IAAK,kBACL,IAAK,mBACHsJ,EAAgBzP,EAAKoQ,SAAUjK,GAC/B,MAEF,IAAK,eACHsJ,EAAgBzP,EAAKsQ,KAAMnK,GAC3BsJ,EAAgBzP,EAAKiQ,SAAU9J,GAC/B,MAEF,IAAK,aACHsJ,EAAgBzP,EAAKuQ,eAAgBpK,GACrC,MAEF,IAAK,oBACHA,EAAM1F,KAAKT,EAAKC,MAChB,MAEF,IAAK,cACHwP,EAAgBzP,EAAKwQ,gBAAiBrK,GACtC,MAEF,IAAK,qBACHA,EAAM1F,KAAK,YACX,MAEF,IAAK,oBACHgP,EAAgBzP,EAAKyQ,UAAWtK,GAChCsJ,EAAgBzP,EAAKC,KAAMkG,IAKjC,IAAMuK,EAAmB,CACvBC,IADuB,SACnBhR,GAAM,UACUrB,EAAEsS,eADZ,IACR,2BAAmC,KAAxB5R,EAAwB,QAC3B6R,EAASlR,EAAKf,IAAII,GAExB,GAAI6R,EAAOrC,SACW7O,EAAKS,MAAM6C,qBAAuBtD,EAAKS,MAAM0Q,oBACrDC,gBAAgB,MAAOF,IAN/B,gCAWVG,YAZuB,SAYXrR,GACNA,EAAK4O,kBAEL5O,EAAK6H,uBAAyB7H,EAAKf,IAAI,eAAe8I,kBAI3C/H,EAAKS,MAAM6C,qBAAuBtD,EAAKS,MAAM0Q,oBACrDG,oBAAoBtR,KAG7BD,qBAvBuB,SAuBFC,EAAMC,GACzBA,EAAMsR,WAAWzQ,KAAKd,IAGxBwR,cA3BuB,SA2BTxR,EAAMC,GAClB,IAAMqO,EAAOtO,EAAKf,IAAI,SAElBqP,EAAKmD,aAAenD,EAAK3G,iBAC3B1H,EAAMgB,mBAAmBH,KAAKd,IAIlC0R,kBAAmB,CACjBvF,KADiB,SACZnM,GAAM,IAEPK,EAEEL,EAFFK,KACAI,EACET,EADFS,MAEIyQ,EAAS7Q,EAAKyH,YAEpB,GAAInJ,EAAEgT,mBAAmBT,IAAWvS,EAAEqJ,sBAAsBkJ,GAAS,CACnE,IAAM1J,EAAK0J,EAAO1J,GAClB,IAAKA,EAAI,OACT,IAAMzG,EAAUN,EAAMO,WAAWwG,EAAGlH,MAChCS,GAASA,EAAQ6Q,UAAU5R,QAC1B,GAAIrB,EAAEyP,sBAAsB8C,GAAS,WACvBA,EAAOW,cADgB,IAC1C,2BACE,IADsC,IAA7BC,EAA6B,QACtC,MAAmBxT,OAAOmD,KAAK9C,EAAEoI,sBAAsB+K,IAAvD,eAA+D,CAA1D,IAAMxR,EAAI,KACPS,EAAUN,EAAMO,WAAWV,GAC7BS,GAASA,EAAQ6Q,UAAU5R,IAJO,kCAYhD+R,iBA5DuB,SA4DN/R,GACfA,EAAKS,MAAM0Q,mBAAmBa,UAAUhS,EAAKK,MAC7CL,EAAKS,MAAMwR,iBAAiBX,oBAAoBtR,IAGlDkS,qBAjEuB,SAiEFlS,EAAMC,GACzBA,EAAMkS,YAAYrR,KAAKd,IAGzBoS,iBArEuB,SAqENpS,EAAMC,GACrBA,EAAMgB,mBAAmBH,KAAKd,IAGhCqS,gBAzEuB,SAyEPrS,EAAMC,GACO,WAAvBD,EAAKK,KAAKiS,UACZrS,EAAMgB,mBAAmBH,KAAKd,IAIlCwN,YA/EuB,SA+EXxN,GACV,IAAIS,EAAQT,EAAKS,MAKjB,GAJIA,EAAMT,OAASA,IAAMS,EAAQA,EAAMG,QACxBH,EAAMwR,iBACdX,oBAAoBtR,GAEvBA,EAAK2R,sBAAwB3R,EAAKK,KAAKmH,GAAI,CAC7C,IACMlH,EADKN,EAAKK,KAAKmH,GACLlH,KAChBN,EAAKS,MAAMW,SAASd,GAAQN,EAAKS,MAAMG,OAAOI,WAAWV,KAI7DiS,MA5FuB,SA4FjBvS,GACJ,IADU,EACJsE,EAAQtE,EAAKf,IAAI,QADb,IAGaqF,GAHb,IAGV,2BAA8B,KAAnBkO,EAAmB,QACxBA,EAASxK,yBACXhI,EAAKS,MAAMwR,iBAAiBX,oBAAoBkB,IAL1C,gCAUZC,YAtGuB,SAsGXzS,GACVA,EAAKS,MAAM2Q,gBAAgB,MAAOpR,IAGpC0S,SA1GuB,SA0Gd1S,GACHA,EAAKiI,wBAA0BjI,EAAKhB,IAAI,QAAUgB,EAAKf,IAAI,MAAMoB,KAAK1B,EAAEgU,oBAC1E3S,EAAKS,MAAM2Q,gBAAgB,QAASpR,EAAKf,IAAI,MAAOe,GAGtD,IALa,EAKP4S,EAAS5S,EAAKf,IAAI,UALX,IAOO2T,GAPP,IAOb,2BAA4B,KAAjBC,EAAiB,QAC1B7S,EAAKS,MAAM2Q,gBAAgB,QAASyB,IARzB,gCAYfC,gBAtHuB,SAsHP9S,GACVA,EAAKhB,IAAI,QAAUgB,EAAKf,IAAI,MAAMoB,KAAK1B,EAAEgU,oBAC3C3S,EAAKS,MAAM2Q,gBAAgB,QAASpR,KAKtCuD,EAAM,EAEJmK,E,WACJ,WAAY1N,GAAM,cAEdK,EACEL,EADFK,KAGI0S,EAASlD,EAAOpP,MAAMxB,IAAIoB,GAEhC,IAAe,MAAV0S,OAAiB,EAASA,EAAO/S,QAAUA,EAC9C,OAAO+S,EAGTlD,EAAOpP,MAAMf,IAAIW,EAAMiB,MAEvBA,KAAKiC,IAAMA,IACXjC,KAAK0R,MAAQ3S,EACbiB,KAAKtB,KAAOA,EACZsB,KAAK2R,OAAS,IAAIC,IAClB5R,KAAK6R,QAAS,E,2CAgBP9S,EAAM0N,EAAM9N,IACnB,EAAI6F,EAAOpH,SAAS2B,EAAM0N,EAAMzM,KAAMrB,EAAOqB,KAAKtB,Q,oDAGtBM,GAC5B,IAAMkH,EAAKlG,KAAKkC,sBAAsBlD,GAItC,OAHAgB,KAAKR,KAAK,CACR0G,OAEK7I,EAAEuF,UAAUsD,K,4CAGClH,GACpB,OAAO3B,EAAEgD,WAAWL,KAAK8R,YAAY9S,M,oCAGZ,IAErBiD,EAFMjD,EAAe,uDAAR,OACjBA,EAAO3B,EAAE0U,aAAa/S,GAAMgT,QAAQ,MAAO,IAAIA,QAAQ,WAAY,IAEnE,IAAI5Q,EAAI,EAER,GACEa,EAAMjC,KAAKiS,aAAajT,EAAMoC,GAC9BA,UACOpB,KAAKkS,SAASjQ,IAAQjC,KAAKmS,WAAWlQ,IAAQjC,KAAKoS,UAAUnQ,IAAQjC,KAAKqS,aAAapQ,IAEhG,IAAMqQ,EAAUtS,KAAK6P,mBAGrB,OAFAyC,EAAQrC,WAAWhO,IAAO,EAC1BqQ,EAAQC,KAAKtQ,IAAO,EACbA,I,mCAGIjD,EAAMoC,GACjB,IAAI8E,EAAKlH,EAET,OADIoC,EAAI,IAAG8E,GAAM9E,GACjB,WAAW8E,K,6CAGUnH,EAAMyT,GAC3B,IAAMtN,EAAQ,GACdsJ,EAAgBzP,EAAMmG,GACtB,IAAIgB,EAAKhB,EAAMuN,KAAK,KAEpB,OADAvM,EAAKA,EAAG8L,QAAQ,KAAM,KAAOQ,GAAe,MACrCxS,KAAK8R,YAAY5L,EAAGwM,MAAM,EAAG,O,uDAGL3T,EAAMyT,GACrC,OAAOnV,EAAEgD,WAAWL,KAAK2S,uBAAuB5T,EAAMyT,M,+BAG/CzT,GACP,GAAI1B,EAAEuV,iBAAiB7T,IAAS1B,EAAEwV,QAAQ9T,GACxC,OAAO,EAGT,GAAI1B,EAAEgJ,aAAatH,GAAO,CACxB,IAAMU,EAAUO,KAAKN,WAAWX,EAAKC,MAErC,OAAIS,EACKA,EAAQkC,SAER3B,KAAKmS,WAAWpT,EAAKC,MAIhC,OAAO,I,4CAGaD,EAAM+T,GAC1B,GAAI9S,KAAK+S,SAAShU,GAChB,OAAO,KAEP,IAAMmH,EAAKlG,KAAKgT,iCAAiCjU,GAEjD,OAAK+T,EAOE5M,GANLlG,KAAKR,KAAK,CACR0G,OAEK7I,EAAEuF,UAAUsD,M,iDAOE2I,EAAOjO,EAAM5B,EAAMkH,GAC5C,GAAa,UAATtF,IACe,UAAfiO,EAAMjO,OACiB,QAATA,GAAiC,QAAfiO,EAAMjO,MAAiC,UAAfiO,EAAMjO,MAAmC,WAAfiO,EAAMjO,MAAoC,UAAfiO,EAAMjO,OAA8B,QAATA,GAA2B,UAATA,KAG5J,MAAMZ,KAAKiT,IAAIC,WAAWhN,EAApB,iCAAkDlH,EAAlD,KAA2DwL,a,6BAI9D2I,EAASC,EAAS1B,GACvB,IAAMjS,EAAUO,KAAKN,WAAWyT,GAEhC,GAAI1T,EAEF,OADA2T,EAAUA,GAAWpT,KAAKkC,sBAAsBiR,GAASnU,KAClD,IAAImP,EAAS/Q,QAAQqC,EAAS0T,EAASC,GAASC,OAAO3B,K,qCAInDpM,EAAK6N,EAASC,EAASjW,GAChCmI,EAAI6N,KACN7N,EAAI8N,GAAWjW,EACfmI,EAAI6N,GAAW,Q,6BAKjB,IAAMG,EAAM,IAAIC,OAAO,IACvB3J,QAAQ4J,IAAIF,GACZ,IAAInU,EAAQa,KAEZ,EAAG,CACD4J,QAAQ4J,IAAI,IAAKrU,EAAMuS,MAAMtL,MAE7B,cAAmBpJ,OAAOmD,KAAKhB,EAAMW,UAArC,eAAgD,CAA3C,IAAMd,EAAI,KACPS,EAAUN,EAAMW,SAASd,GAC/B4K,QAAQ4J,IAAI,KAAMxU,EAAM,CACtB2C,SAAUlC,EAAQkC,SAClBsO,WAAYxQ,EAAQwQ,WACpBwD,WAAYhU,EAAQE,mBAAmB0B,OACvCT,KAAMnB,EAAQmB,cAGXzB,EAAQA,EAAMG,QAEvBsK,QAAQ4J,IAAIF,K,8BAGNvU,EAAMqC,EAAGsS,GACf,GAAIrW,EAAEgJ,aAAatH,GAAO,CACxB,IAAMU,EAAUO,KAAKN,WAAWX,EAAKC,MAErC,IAAgB,MAAXS,OAAkB,EAASA,EAAQkC,WAAalC,EAAQf,KAAKiV,cAAc,SAC9E,OAAO5U,EAIX,GAAI1B,EAAEuW,kBAAkB7U,GACtB,OAAOA,EAGT,GAAI1B,EAAEgJ,aAAatH,EAAM,CACvBC,KAAM,cAEN,OAAO3B,EAAEwW,eAAexW,EAAEyW,iBAAiBzW,EAAEyW,iBAAiBzW,EAAEyW,iBAAiBzW,EAAEgD,WAAW,SAAUhD,EAAEgD,WAAW,cAAehD,EAAEgD,WAAW,UAAWhD,EAAEgD,WAAW,SAAU,CAACtB,IAGtL,IAAIgV,EACEC,EAAO,CAACjV,GAgBd,OAdU,IAANqC,EACF2S,EAAa,oBACJ3S,GACT4S,EAAKxU,KAAKnC,EAAE4W,eAAe7S,IAC3B2S,EAAa,iBAEbA,EAAa,UAGXL,IACFM,EAAKE,QAAQlU,KAAKiT,IAAIkB,UAAUJ,IAChCA,EAAa,kBAGR1W,EAAEwW,eAAe7T,KAAKiT,IAAIkB,UAAUJ,GAAaC,K,+BAGjDhV,GACP,QAASgB,KAAKoU,SAASpV,K,+BAGhBA,GACP,OAAOgB,KAAK2R,OAAOhU,IAAIqB,K,oCAGXN,GACZsB,KAAK2R,OAAOvT,IAAIM,EAAKK,KAAKsV,MAAMrV,KAAMN,K,0CAGpBA,GAClB,GAAIA,EAAKqI,qBACP/G,KAAKsU,cAAc5V,QACd,GAAIA,EAAKgI,wBACd1G,KAAK8P,gBAAgB,UAAWpR,EAAKf,IAAI,MAAOe,QAC3C,GAAIA,EAAKoO,wBAAyB,CACvC,IADuC,EACjCyD,EAAe7R,EAAKf,IAAI,gBADS,IAGlB4S,GAHkB,IAGvC,2BAAmC,KAAxBX,EAAwB,QACjC5P,KAAK8P,gBAAgBpR,EAAKK,KAAK6B,KAAMgP,IAJA,oCAMlC,GAAIlR,EAAK2R,qBACdrQ,KAAK8P,gBAAgB,MAAOpR,QACvB,GAAIA,EAAKkP,sBAAuB,CACrC,IADqC,EAC/Be,EAAajQ,EAAKf,IAAI,cADS,IAGbgR,GAHa,IAGrC,2BAAoC,KAAzB4F,EAAyB,QAClCvU,KAAK8P,gBAAgB,SAAUyE,IAJI,oCAMhC,GAAI7V,EAAK6H,sBAAuB,CACrC,IAAMqJ,EAASlR,EAAKf,IAAI,gBAEpBiS,EAAOS,sBAAwBT,EAAOlJ,yBAA2BkJ,EAAO9C,0BAC1E9M,KAAKgQ,oBAAoBJ,QAG3B5P,KAAK8P,gBAAgB,UAAWpR,K,2CAKlC,OAAOrB,EAAEmX,gBAAgB,OAAQnX,EAAE4W,eAAe,IAAI,K,gDAG9BvV,GAGxB,IAFA,IAAMsH,EAAMtH,EAAK+G,wBAEjB,MAAmBzI,OAAOmD,KAAK6F,GAA/B,eAAqC,CAAhC,IAAMhH,EAAI,KACPS,EAAUO,KAAKN,WAAWV,GAC5BS,GAASA,EAAQgV,SAAS/V,M,sCAIlBkC,EAAMlC,GAA0B,IAApBgW,EAAoB,uDAANhW,EACxC,IAAKkC,EAAM,MAAM,IAAI+T,eAAe,aAEpC,GAAIjW,EAAKoO,wBAAT,CACE,IADgC,EAC1B8H,EAAclW,EAAKf,IAAI,gBADG,IAGXiX,GAHW,IAGhC,2BAAkC,KAAvBhF,EAAuB,QAChC5P,KAAK8P,gBAAgBlP,EAAMgP,IAJG,oCAalC,IAHA,IAAMtQ,EAASU,KAAK6P,mBACd7J,EAAMtH,EAAKiH,4BAA2B,GAE5C,MAAmB3I,OAAOmD,KAAK6F,GAA/B,eAAqC,CAAhC,IAAMhH,EAAI,KACbM,EAAO2Q,WAAWjR,IAAQ,EADS,UAGlBgH,EAAIhH,IAHc,IAGnC,2BAA4B,KAAjBkH,EAAiB,QACpB2I,EAAQ7O,KAAK6U,cAAc7V,GAEjC,GAAI6P,EAAO,CACT,GAAIA,EAAMxO,aAAe6F,EAAI,SAC7BlG,KAAK8U,2BAA2BjG,EAAOjO,EAAM5B,EAAMkH,GAGjD2I,EACF7O,KAAK+U,0BAA0BL,GAE/B1U,KAAKF,SAASd,GAAQ,IAAIqP,EAASjR,QAAQ,CACzCiD,WAAY6F,EACZ/G,MAAOa,KACPtB,KAAMgW,EACN9T,KAAMA,KAlBuB,kC,gCAyB7B7B,GACRiB,KAAKgV,QAAQjW,EAAKC,MAAQD,I,6BAGrBC,GACL,IAAIG,EAAQa,KAEZ,GACE,GAAIb,EAAMoT,KAAKvT,GAAO,OAAO,QACtBG,EAAQA,EAAMG,QAEvB,OAAO,I,gCAGCN,GACR,IAAIG,EAAQa,KAEZ,GACE,GAAIb,EAAM6V,QAAQhW,GAAO,OAAO,QACzBG,EAAQA,EAAMG,QAEvB,OAAO,I,mCAGIN,GACX,QAASgB,KAAK6P,mBAAmBI,WAAWjR,K,6BAGvCD,EAAMkW,GACX,GAAI5X,EAAEgJ,aAAatH,GAAO,CACxB,IAAMU,EAAUO,KAAKN,WAAWX,EAAKC,MACrC,QAAKS,KACDwV,GAAsBxV,EAAQkC,UAE7B,GAAItE,EAAE6X,QAAQnW,GACnB,QAAIA,EAAKoW,aAAenV,KAAK0N,OAAO3O,EAAKoW,WAAYF,KAI9CjV,KAAK0N,OAAO3O,EAAKqW,KAAMH,GACzB,GAAI5X,EAAEgY,YAAYtW,GAAO,WACTA,EAAKqW,MADI,IAC9B,2BAAgC,KAArBE,EAAqB,QAC9B,IAAKtV,KAAK0N,OAAO4H,EAAQL,GAAgB,OAAO,GAFpB,8BAK9B,OAAO,EACF,GAAI5X,EAAEkY,SAASxW,GACpB,OAAOiB,KAAK0N,OAAO3O,EAAKiO,KAAMiI,IAAkBjV,KAAK0N,OAAO3O,EAAKyW,MAAOP,GACnE,GAAI5X,EAAEuW,kBAAkB7U,GAAO,WACjBA,EAAK0W,UADY,IACpC,2BAAkC,KAAvBC,EAAuB,QAChC,IAAK1V,KAAK0N,OAAOgI,EAAMT,GAAgB,OAAO,GAFZ,8BAKpC,OAAO,EACF,GAAI5X,EAAE4Q,mBAAmBlP,GAAO,WAClBA,EAAKmQ,YADa,IACrC,2BAAoC,KAAzByG,EAAyB,QAClC,IAAK3V,KAAK0N,OAAOiI,EAAMV,GAAgB,OAAO,GAFX,8BAKrC,OAAO,EACF,GAAI5X,EAAEuY,SAAS7W,GACpB,QAAIA,EAAK8W,WAAa7V,KAAK0N,OAAO3O,EAAKhB,IAAKkX,MAC1B,QAAdlW,EAAK6B,MAAgC,QAAd7B,EAAK6B,MAE3B,GAAIvD,EAAEyY,WAAW/W,GACtB,QAAIA,EAAK8W,WAAa7V,KAAK0N,OAAO3O,EAAKhB,IAAKkX,KACrCjV,KAAK0N,OAAO3O,EAAK5B,MAAO8X,GAC1B,GAAI5X,EAAE0Y,kBAAkBhX,GAC7B,OAAOiB,KAAK0N,OAAO3O,EAAKoQ,SAAU8F,GAC7B,GAAI5X,EAAE2Y,2BAA2BjX,GACtC,OAAO1B,EAAE4Y,eAAelX,EAAKmX,IAAK,gBAAkBlW,KAAKmS,WAAW,UAAU,IAASnS,KAAK0N,OAAO3O,EAAKoX,MAAOlB,GAC1G,GAAI5X,EAAE+Y,kBAAkBrX,GAAO,WACXA,EAAKsX,aADM,IACpC,2BAA2C,KAAhCjH,EAAgC,QACzC,IAAKpP,KAAK0N,OAAO0B,EAAY6F,GAAgB,OAAO,GAFlB,8BAKpC,OAAO,EAEP,OAAO5X,EAAEiZ,UAAUvX,K,8BAIfhB,EAAKuM,GACX,OAAOtK,KAAKuW,KAAKxY,GAAOuM,I,8BAGlBvM,GACN,IAAIoB,EAAQa,KAEZ,EAAG,CACD,IAAMuW,EAAOpX,EAAMoX,KAAKxY,GACxB,GAAY,MAARwY,EAAc,OAAOA,QAClBpX,EAAQA,EAAMG,U,iCAGdvB,GACT,IAAIoB,EAAQa,KAEZ,EAAG,CAEW,MADCb,EAAMoX,KAAKxY,KACNoB,EAAMoX,KAAKxY,GAAO,YAC7BoB,EAAQA,EAAMG,U,6BAIlBU,KAAK6R,SACR7R,KAAK6R,QAAS,EACd7R,KAAKwW,W,8BAKP,IAAM9X,EAAOsB,KAAKtB,KAOlB,GANAsB,KAAKiQ,WAAajT,OAAOiJ,OAAO,MAChCjG,KAAKF,SAAW9C,OAAOiJ,OAAO,MAC9BjG,KAAKgV,QAAUhY,OAAOiJ,OAAO,MAC7BjG,KAAKuS,KAAOvV,OAAOiJ,OAAO,MAC1BjG,KAAKuW,KAAOvZ,OAAOiJ,OAAO,MAEtBvH,EAAKU,aAAc,CACjBV,EAAKiI,wBAA0BjI,EAAKhB,IAAI,QAAUgB,EAAKf,IAAI,MAAMoB,KAAK1B,EAAEgU,oBAC1ErR,KAAK8P,gBAAgB,QAASpR,EAAKf,IAAI,MAAOe,GAGhD,IALqB,EAKf4S,EAAS5S,EAAKf,IAAI,UALH,IAOD2T,GAPC,IAOrB,2BAA4B,KAAjBC,EAAiB,QAC1BvR,KAAK8P,gBAAgB,QAASyB,IARX,+BAYvB,IAAMkF,EAAgBzW,KAAK6P,mBAC3B,IAAI4G,EAAcC,SAAlB,CACA,IAAM/X,EAAQ,CACZsR,WAAY,GACZtQ,mBAAoB,GACpBkR,YAAa,IAEf7Q,KAAK0W,UAAW,EAChBhY,EAAKkD,SAAS6N,EAAkB9Q,GAChCqB,KAAK0W,UAAW,EA7BV,UA+Ba/X,EAAMkS,aA/BnB,IA+BN,2BAAsC,CAGpC,IAHoC,IAA3BnS,EAA2B,QAC9BsH,EAAMtH,EAAK+G,wBAEjB,MAAmBzI,OAAOmD,KAAK6F,GAA/B,eAAqC,CAAhC,IAAMhH,EAAI,KACTN,EAAKS,MAAMO,WAAWV,IAC1ByX,EAAc/F,UAAU1K,EAAIhH,IAG9BN,EAAKS,MAAM4V,0BAA0BrW,IAvCjC,wCA0CYC,EAAMsR,YA1ClB,IA0CN,2BAAoC,KAAzB0G,EAAyB,QAC5BlX,EAAUkX,EAAIxX,MAAMO,WAAWiX,EAAI5X,KAAKC,MAE1CS,EACFA,EAAQ6Q,UAAUqG,GAElBF,EAAc/F,UAAUiG,EAAI5X,OAhD1B,wCAoDaJ,EAAMgB,oBApDnB,IAoDN,2BAA6C,KAAlCjB,EAAkC,QAC3CA,EAAKS,MAAM4V,0BAA0BrW,IArDjC,kC,2BAyDH+N,GACH,IAAI/N,EAAOsB,KAAKtB,KAEXA,EAAK4E,oBAAuB5E,EAAKgC,cACpChC,EAAOsB,KAAK2Q,iBAAiBjS,MAG3BA,EAAK+E,sBACP/E,GAAQsB,KAAKgC,qBAAuBhC,KAAK6P,oBAAoBnR,OAG3DA,EAAKkY,UAAYlY,EAAK8E,iBAAmB9E,EAAKU,gBAChDV,EAAKmY,cACLnY,EAAOA,EAAKf,IAAI,SAGlB,IAAMmZ,EAASrK,EAAKqK,OACdlW,EAAO6L,EAAK7L,MAAQ,MACpBmW,EAAiC,MAApBtK,EAAKnL,YAAsB,EAAImL,EAAKnL,YACjD0V,EAAU,eAAH,OAAkBpW,EAAlB,YAA0BmW,GACnCE,GAAcH,GAAUpY,EAAKwY,QAAQF,GAEzC,IAAKC,EAAY,CACf,IAAMrH,EAASvS,EAAEiF,oBAAoB1B,EAAM,IAC3CgP,EAAOtO,YAAcyV,EAFN,MAGArY,EAAKyY,iBAAiB,OAAQ,CAACvH,IAA7CqH,EAHc,UAIVH,GAAQpY,EAAK0Y,QAAQJ,EAASC,GAGrC,IAAM9U,EAAa9E,EAAE+E,mBAAmBqK,EAAKvG,GAAIuG,EAAKS,MACtD+J,EAAWlY,KAAKwR,aAAa/Q,KAAK2C,GAClCnC,KAAK8P,gBAAgBlP,EAAMqW,EAAWtZ,IAAI,gBAAgBqD,S,yCAI1D,IAAI7B,EAAQa,KAEZ,GACE,GAAIb,EAAMT,KAAKgC,YACb,OAAOvB,QAEFA,EAAQA,EAAMG,QAEvB,MAAM,IAAI4K,MAAM,6B,0CAIhB,IAAI/K,EAAQa,KAEZ,GACE,GAAIb,EAAMT,KAAK2Y,mBACb,OAAOlY,QAEFA,EAAQA,EAAMG,QAEvB,OAAO,O,uCAIP,IAAIH,EAAQa,KAEZ,GACE,GAAIb,EAAMT,KAAK4Y,gBACb,OAAOnY,QAEFA,EAAQA,EAAMG,QAEvB,MAAM,IAAI4K,MAAM,kF,uCAIhB,IAAMlE,EAAMhJ,OAAOiJ,OAAO,MACtB9G,EAAQa,KAEZ,EAAG,CACD,cAAkBhD,OAAOmD,KAAKhB,EAAMW,UAApC,eAA+C,CAA1C,IAAM/B,EAAG,KACRA,KAAOiI,KAAQ,IACjBA,EAAIjI,GAAOoB,EAAMW,SAAS/B,IAI9BoB,EAAQA,EAAMG,aACPH,GAET,OAAO6G,I,6CAIP,IADqB,EACfA,EAAMhJ,OAAOiJ,OAAO,MADL,IAGF+E,WAHE,IAGrB,2BAA8B,KAAnBpK,EAAmB,QACxBzB,EAAQa,KAEZ,EAAG,CACD,cAAmBhD,OAAOmD,KAAKhB,EAAMW,UAArC,eAAgD,CAA3C,IAAMd,EAAI,KACPS,EAAUN,EAAMW,SAASd,GAC3BS,EAAQmB,OAASA,IAAMoF,EAAIhH,GAAQS,GAGzCN,EAAQA,EAAMG,aACPH,IAbU,8BAgBrB,OAAO6G,I,8CAGehH,EAAMD,GAC5B,OAAOiB,KAAKuX,qBAAqBvY,KAAUD,I,iCAGlCC,GACT,IACIwY,EADArY,EAAQa,KAGZ,EAAG,CACD,IAGMyX,EAHAhY,EAAUN,EAAM0V,cAAc7V,GAEpC,GAAIS,EAGF,KAAuC,OAAjCgY,EAAgBD,QAAwB,EAASC,EAActH,cAAiC,UAAjB1Q,EAAQmB,KAC3F,OAAOnB,EAIX+X,EAAerY,EAAMT,WACdS,EAAQA,EAAMG,U,oCAGXN,GACZ,OAAOgB,KAAKF,SAASd,K,2CAGFA,GACnB,IAAI0Y,EAEJ,OAAqD,OAA7CA,EAAmB1X,KAAKN,WAAWV,SAAiB,EAAS0Y,EAAiBrX,a,8CAGhErB,GACtB,IAAMS,EAAUO,KAAKF,SAASd,GAC9B,OAAkB,MAAXS,OAAkB,EAASA,EAAQY,a,oCAG9BrB,GACZ,QAASgB,KAAK6U,cAAc7V,K,iCAGnBA,EAAM2Y,GACf,QAAK3Y,MACDgB,KAAKW,cAAc3B,OACnBgB,KAAK4X,iBAAiB5Y,EAAM2Y,OAC5B3X,KAAK6X,OAAO7Y,OACX2Y,IAAavL,EAAM4I,QAAQ8C,SAAS9Y,OACpC2Y,IAAavL,EAAM2L,iBAAiBD,SAAS9Y,U,uCAInCA,EAAM2Y,GACrB,IAAIK,EAEJ,OAAuC,OAA/BA,EAAehY,KAAKV,aAAkB,EAAS0Y,EAAa7F,WAAWnT,EAAM2Y,K,oCAGzE3Y,EAAMG,GAClB,IAAM8Y,EAAOjY,KAAKN,WAAWV,GAEzBiZ,IACFA,EAAK9Y,MAAM+Y,iBAAiBlZ,GAC5BiZ,EAAK9Y,MAAQA,EACbA,EAAMW,SAASd,GAAQiZ,K,uCAIVjZ,UACRgB,KAAKF,SAASd,K,oCAGTA,GACZ,IAAImZ,EAE2C,OAA9CA,EAAoBnY,KAAKN,WAAWV,KAA0BmZ,EAAkBhZ,MAAM+Y,iBAAiBlZ,GACxG,IAAIG,EAAQa,KAEZ,GACMb,EAAMoT,KAAKvT,KACbG,EAAMoT,KAAKvT,IAAQ,SAEdG,EAAQA,EAAMG,U,6BA5nBvB,IAAMA,EAASU,KAAKtB,KAAK0Z,YAAW,SAAAC,GAAC,OAAIA,EAAEhL,aAC3C,OAAiB,MAAV/N,OAAiB,EAASA,EAAOH,Q,kCAIxC,OAAOa,KAAKtB,KAAKY,S,0BAIjB,OAAOU,KAAKtB,KAAKuU,Q,KAwnBrB/V,EAAQE,QAAUgP,EAClBA,EAAM4I,QAAUhY,OAAOmD,KAAKmO,EAASlR,QAAQkb,SAC7ClM,EAAM2L,iBAAmB,CAAC,YAAa,YAAa,WAAY,Q,qDC57BhE/a,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQE,aAAU,E,IAEZmb,E,WACJ,cAKG,IAJDlY,EAIC,EAJDA,WACAlB,EAGC,EAHDA,MACAT,EAEC,EAFDA,KACAkC,EACC,EADDA,KACC,UACDZ,KAAKL,mBAAqB,GAC1BK,KAAK2B,UAAW,EAChB3B,KAAKwY,eAAiB,GACtBxY,KAAKyY,YAAa,EAClBzY,KAAKiQ,WAAa,EAClBjQ,KAAKK,WAAaA,EAClBL,KAAKb,MAAQA,EACba,KAAKtB,KAAOA,EACZsB,KAAKY,KAAOA,EACZZ,KAAK0Y,a,+CAIL1Y,KAAK0Y,aACL1Y,KAAK2Y,iBAAkB,I,+BAGhBxb,GACH6C,KAAK2Y,kBACT3Y,KAAK4Y,UAAW,EAChB5Y,KAAK7C,MAAQA,K,mCAIb6C,KAAK2Y,iBAAkB,EACvB3Y,KAAK4Y,UAAW,EAChB5Y,KAAK7C,MAAQ,O,+BAGNuB,GACPsB,KAAK2B,UAAW,GAE+B,IAA3C3B,KAAKL,mBAAmBY,QAAQ7B,IAIpCsB,KAAKL,mBAAmBH,KAAKd,K,gCAGrBA,IACmC,IAAvCsB,KAAKwY,eAAejY,QAAQ7B,KAIhCsB,KAAKyY,YAAa,EAClBzY,KAAKiQ,aACLjQ,KAAKwY,eAAehZ,KAAKd,M,oCAIzBsB,KAAKiQ,aACLjQ,KAAKyY,aAAezY,KAAKiQ,e,KAK7B/S,EAAQE,QAAUmb,G,4CCpElBvb,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQE,QAAUwE,EAClB5E,OAAOC,eAAeC,EAAS,WAAY,CACzC2b,YAAY,EACZlb,IAAK,WACH,OAAOmb,EAAM1b,WAGjBJ,OAAOC,eAAeC,EAAS,QAAS,CACtC2b,YAAY,EACZlb,IAAK,WACH,OAAOob,EAAO3b,WAGlBJ,OAAOC,eAAeC,EAAS,MAAO,CACpC2b,YAAY,EACZlb,IAAK,WACH,OAAOqb,EAAK5b,WAGhBF,EAAQmL,cAAW,EAEnB,IAAI4Q,EAAW7K,EAAuB9P,EAAQ,MAE1C+J,EAAWhK,EAAwBC,EAAQ,OAE/CpB,EAAQmL,SAAWA,EAEnB,IAAIhL,EAAIgB,EAAwBC,EAAQ,KAEpCd,EAAQa,EAAwBC,EAAQ,MAExCwa,EAAQ1K,EAAuB9P,EAAQ,KAEvCya,EAAS3K,EAAuB9P,EAAQ,MAExC0a,EAAO5K,EAAuB9P,EAAQ,OAE1C,SAASb,IAA6B,GAAuB,oBAAZc,QAAwB,OAAO,KAAM,IAAIf,EAAQ,IAAIe,QAAqE,OAA1Dd,EAA2B,WAAc,OAAOD,GAAiBA,EAElL,SAASa,EAAwBf,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEF,QAASE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAMG,IAAIL,GAAQ,IAAIM,EAAS,GAAQC,EAAwBb,OAAOC,gBAAkBD,OAAOc,yBAA0B,IAAK,IAAIC,KAAOT,EAAO,GAAIN,OAAOgB,UAAUC,eAAeC,KAAKZ,EAAKS,GAAM,CAAE,IAAII,EAAON,EAAwBb,OAAOc,yBAAyBR,EAAKS,GAAO,KAAUI,IAASA,EAAKR,KAAOQ,EAAKC,KAAQpB,OAAOC,eAAeW,EAAQG,EAAKI,GAAgBP,EAAOG,GAAOT,EAAIS,GAAyE,OAA7DH,EAAOR,QAAUE,EAASE,GAASA,EAAMY,IAAId,EAAKM,GAAkBA,EAE9tB,SAASwQ,EAAuB9Q,GAAO,OAAOA,GAAOA,EAAIC,WAAaD,EAAM,CAAEF,QAASE,GAEvF,SAASsE,EAAStC,EAAQmN,EAAMtN,EAAOR,EAAOM,GAC5C,GAAKK,EAAL,CAGA,GAFKmN,IAAMA,EAAO,KAEbA,EAAKyM,UAAY/Z,GACA,YAAhBG,EAAO8G,MAAsC,SAAhB9G,EAAO8G,KACtC,MAAM,IAAI8D,MAAM,0EAA4E,2CAA5E,OAAuH5K,EAAO8G,KAA9H,kBAAqJ,iCAIpK/I,EAAE8b,aAAa7Z,EAAO8G,QAI3BiC,EAASH,QAAQuE,GACjB7K,EAAS7C,KAAKO,EAAQmN,EAAMtN,EAAOR,EAAOM,KAgC5C,SAASma,EAAkB1a,EAAMC,GAC3BD,EAAKK,KAAKqH,OAASzH,EAAMyH,OAC3BzH,EAAMjB,KAAM,EACZgB,EAAKmB,QAhCT+B,EAASyG,SAAWA,EACpBzG,EAASuG,OAASE,EAASF,OAC3BvG,EAASsG,QAAUG,EAASH,QAE5BtG,EAASyX,MAAQ,SAAUta,EAAMoK,GAC/B,OAAO9L,EAAEic,aAAava,EAAMoK,IAG9BvH,EAAS7C,KAAO,SAAUA,EAAM0N,EAAMtN,EAAOR,EAAOM,EAAYsa,GAC9D,IAAMpZ,EAAO9C,EAAE8b,aAAapa,EAAKqH,MACjC,GAAKjG,EAAL,CACA,IAHwE,EAGlEwE,EAAU,IAAIsU,EAAS7b,QAAQ+B,EAAOsN,EAAM9N,EAAOM,GAHe,IAKtDkB,GALsD,IAKxE,2BAAwB,KAAbpC,EAAa,QACtB,KAAIwb,IAAYA,EAASxb,KACrB4G,EAAQ6U,MAAMza,EAAMhB,GAAM,QAPwC,iCAW1E6D,EAAS6X,UAAY,SAAU1a,EAAM0N,GACnCpP,EAAEqc,iBAAiB3a,EAAM0N,GACzBjP,EAAMkB,KAAKib,OAAO5a,IAGpB6C,EAAS8X,iBAAmB,SAAUE,EAAMnN,GAE1C,OADApP,EAAEic,aAAaM,EAAMhY,EAAS6X,UAAWhN,GAClCmN,GAUThY,EAASiY,QAAU,SAAUD,EAAMxT,EAAM0T,GACvC,GAAqB,MAAjBA,OAAwB,EAASA,EAAchC,SAAS8B,EAAKxT,MAAO,OAAO,EAC/E,GAAIwT,EAAKxT,OAASA,EAAM,OAAO,EAC/B,IAAMzH,EAAQ,CACZjB,KAAK,EACL0I,KAAMA,GAOR,OALAxE,EAASgY,EAAM,CACbV,SAAS,EACTa,SAAUD,EACV3Q,MAAOiQ,GACN,KAAMza,GACFA,EAAMjB,KAGfkE,EAASpE,MAAQA,G,4DCnHjBR,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQE,QAAUF,EAAQ8c,YAAc9c,EAAQ+c,YAAc/c,EAAQgd,aAAU,EAEhF,IAAIpR,EAAezK,EAAwBC,EAAQ,MAE/C6b,EAAS/L,EAAuB9P,EAAQ,MAExCkG,EAAS4J,EAAuB9P,EAAQ,KAExCya,EAAS3K,EAAuB9P,EAAQ,MAExCjB,EAAIgB,EAAwBC,EAAQ,KAEpCiQ,EAASjQ,EAAQ,KAEjB8b,EAAahM,EAAuB9P,EAAQ,MAE5C+b,EAAoBhc,EAAwBC,EAAQ,MAEpDgc,EAAqBjc,EAAwBC,EAAQ,MAErDic,EAAuBlc,EAAwBC,EAAQ,MAEvDkc,EAAsBnc,EAAwBC,EAAQ,MAEtDmc,EAAsBpc,EAAwBC,EAAQ,MAEtDoc,EAAyBrc,EAAwBC,EAAQ,MAEzDqc,EAAmBtc,EAAwBC,EAAQ,MAEnDsc,EAAmBvc,EAAwBC,EAAQ,MAEnDuc,EAAwBxc,EAAwBC,EAAQ,MAExDwc,EAAkBzc,EAAwBC,EAAQ,OAElDyc,EAAoB1c,EAAwBC,EAAQ,OAExD,SAAS8P,EAAuB9Q,GAAO,OAAOA,GAAOA,EAAIC,WAAaD,EAAM,CAAEF,QAASE,GAEvF,SAASG,IAA6B,GAAuB,oBAAZc,QAAwB,OAAO,KAAM,IAAIf,EAAQ,IAAIe,QAAqE,OAA1Dd,EAA2B,WAAc,OAAOD,GAAiBA,EAElL,SAASa,EAAwBf,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEF,QAASE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAMG,IAAIL,GAAQ,IAAIM,EAAS,GAAQC,EAAwBb,OAAOC,gBAAkBD,OAAOc,yBAA0B,IAAK,IAAIC,KAAOT,EAAO,GAAIN,OAAOgB,UAAUC,eAAeC,KAAKZ,EAAKS,GAAM,CAAE,IAAII,EAAON,EAAwBb,OAAOc,yBAAyBR,EAAKS,GAAO,KAAUI,IAASA,EAAKR,KAAOQ,EAAKC,KAAQpB,OAAOC,eAAeW,EAAQG,EAAKI,GAAgBP,EAAOG,GAAOT,EAAIS,GAAyE,OAA7DH,EAAOR,QAAUE,EAASE,GAASA,EAAMY,IAAId,EAAKM,GAAkBA,EAE9tB,IAAMod,GAAQ,EAAIb,EAAO/c,SAAS,SAElCF,EAAQgd,QADQ,EAGhBhd,EAAQ+c,YADY,EAGpB/c,EAAQ8c,YADY,E,IAGdiB,E,WACJ,WAAYhI,EAAK3T,GAAQ,UACvBU,KAAKkb,SAAW,GAChBlb,KAAKrB,MAAQ,KACbqB,KAAKyM,KAAO,KACZzM,KAAKmb,eAAiB,EACtBnb,KAAKuZ,SAAW,KAChBvZ,KAAKf,WAAa,KAClBe,KAAKyB,UAAY,KACjBzB,KAAKyE,QAAU,KACfzE,KAAKjC,IAAM,KACXiC,KAAKjB,KAAO,KACZiB,KAAKoG,KAAO,KACZpG,KAAKV,OAASA,EACdU,KAAKiT,IAAMA,EACXjT,KAAKuW,KAAO,KACZvW,KAAK2E,QAAU,KACf3E,KAAKb,MAAQ,K,2CAwCNA,GACP,OAAOa,KAAKqN,UAAY,IAAI0L,EAAO3b,QAAQ4C,MAAQb,I,8BAG7CpB,EAAKuM,GAKX,OAJiB,MAAbtK,KAAKuW,OACPvW,KAAKuW,KAAOvZ,OAAOiJ,OAAO,OAGrBjG,KAAKuW,KAAKxY,GAAOuM,I,8BAGlBvM,EAAKqd,GACM,MAAbpb,KAAKuW,OACPvW,KAAKuW,KAAOvZ,OAAOiJ,OAAO,OAG5B,IAAIqE,EAAMtK,KAAKuW,KAAKxY,GAEpB,YADYsd,IAAR/Q,QAA6B+Q,IAARD,IAAmB9Q,EAAMtK,KAAKuW,KAAKxY,GAAOqd,GAC5D9Q,I,0CAGWc,GAA0B,IAArBlB,EAAqB,uDAAboR,YAC/B,OAAOtb,KAAKiT,IAAIC,WAAWlT,KAAKjB,KAAMqM,EAAKlB,K,+BAGpCzB,EAAS9J,IAChB,EAAI6F,EAAOpH,SAAS4C,KAAKjB,KAAM0J,EAASzI,KAAKb,MAAOR,EAAOqB,Q,0BAGzDjC,EAAKgB,GACP1B,EAAEke,SAASvb,KAAKjB,KAAMhB,EAAKgB,GAC3BiB,KAAKjB,KAAKhB,GAAOgB,I,wCAIjB,IAAMmG,EAAQ,GACVxG,EAAOsB,KAEX,EAAG,CACD,IAAIjC,EAAMW,EAAKX,IACXW,EAAK8c,SAAQzd,EAAM,GAAH,OAAMW,EAAK+F,QAAX,YAAsB1G,EAAtB,MACpBmH,EAAMgP,QAAQnW,SACPW,EAAOA,EAAKO,YAErB,OAAOiG,EAAMuN,KAAK,O,4BAGdgJ,GACCT,EAAMU,SACXV,EAAM,GAAD,OAAIhb,KAAK2b,kBAAT,YAA8B3b,KAAKoG,KAAnC,aAA4CqV,M,iCAIjD,OAAO,EAAIrB,EAAWhd,SAAS4C,KAAKjB,MAAM6c,O,6BAI1C,QAAS5b,KAAKyE,S,aAGL+W,GACJA,IACHxb,KAAKyE,QAAU,Q,gCAKjB,OAAOzE,KAAKyE,SAAWzE,KAAKjC,M,iCAI5B,SApIgB,EAoINiC,KAAKmb,iB,aAGFU,GACTA,EACF7b,KAAKmb,gBAzIS,EA2Idnb,KAAKmb,iBAAkB,I,iCAKzB,SAlJgB,EAkJNnb,KAAKmb,iB,aAGFU,GACTA,EACF7b,KAAKmb,gBAvJS,EAyJdnb,KAAKmb,iBAAkB,I,8BAKzB,SAhKY,EAgKFnb,KAAKmb,iB,aAGLU,GACNA,EACF7b,KAAKmb,gBArKK,EAuKVnb,KAAKmb,iBAAkB,K,8BArIxB,IANDlI,EAMC,EANDA,IACAhU,EAKC,EALDA,WACAK,EAIC,EAJDA,OACAmC,EAGC,EAHDA,UACAgD,EAEC,EAFDA,QACA1G,EACC,EADDA,IAMA,IAJKkV,GAAOhU,IACVgU,EAAMhU,EAAWgU,MAGd3T,EACH,MAAM,IAAI4K,MAAM,gDAGlB,IAAM4R,EAAara,EAAU1D,GAEzBiF,EAAQuL,EAAO7P,KAAKf,IAAI2B,GAEvB0D,IACHA,EAAQ,IAAI4O,IAEZrD,EAAO7P,KAAKN,IAAIkB,EAAQ0D,IAG1B,IAAItE,EAAOsE,EAAMrF,IAAIme,GAQrB,OANKpd,IACHA,EAAO,IAAIuc,EAAShI,EAAK3T,GACrBwc,GAAY9Y,EAAM5E,IAAI0d,EAAYpd,IAGxCA,EAAKqd,MAAM9c,EAAYwC,EAAWgD,EAAS1G,GACpCW,M,KAgHXxB,EAAQE,QAAU6d,EAClBje,OAAOgN,OAAOiR,EAASjd,UAAWqc,EAAmBC,EAAoBC,EAAsBC,EAAqBC,EAAqBC,EAAwBC,EAAkBC,EAAkBC,EAAuBC,EAAiBC,G,UAE1N1d,EAAE+M,O,yBAAVhE,E,QACH4V,EAAU,KAAH,OAAQ5V,GACfmE,EAAKlN,EAAE2e,GAEbf,EAASjd,UAAUge,GAAW,SAAUvP,GACtC,OAAOlC,EAAGvK,KAAKjB,KAAM0N,IAGvBwO,EAASjd,UAAT,gBAA4BoI,IAAU,SAAUqG,GAC9C,IAAKlC,EAAGvK,KAAKjB,KAAM0N,GACjB,MAAM,IAAIjC,UAAJ,qCAA4CpE,MAVxD,2BAA4B,I,8BAe5B,I,iBAAK,IAAMA,EAAI,KACb,GAAgB,MAAZA,EAAK,GAAY,iBACjB/I,EAAE+M,MAAM7J,QAAQ6F,GAAQ,GAAG/I,EAAE+M,MAAM5K,KAAK4G,GAC5C,IAAM6V,EAAcnT,EAAa1C,GAEjC6U,EAASjd,UAAT,YAAwBoI,IAAU,SAAUqG,GAC1C,OAAOwP,EAAYnR,UAAU9K,KAAMyM,KANvC,MAAmBzP,OAAOmD,KAAK2I,GAA/B,eAA8C,K,6DC/O9C9L,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQE,aAAU,EAElB,IAQgCE,EAR5Bwb,GAQ4Bxb,EARGgB,EAAQ,MAQUhB,EAAIC,WAAaD,EAAM,CAAEF,QAASE,GANnFD,EAIJ,SAAiCC,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEF,QAASE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAMG,IAAIL,GAAQ,IAAIM,EAAS,GAAQC,EAAwBb,OAAOC,gBAAkBD,OAAOc,yBAA0B,IAAK,IAAIC,KAAOT,EAAO,GAAIN,OAAOgB,UAAUC,eAAeC,KAAKZ,EAAKS,GAAM,CAAE,IAAII,EAAON,EAAwBb,OAAOc,yBAAyBR,EAAKS,GAAO,KAAUI,IAASA,EAAKR,KAAOQ,EAAKC,KAAQpB,OAAOC,eAAeW,EAAQG,EAAKI,GAAgBP,EAAOG,GAAOT,EAAIS,GAAYH,EAAOR,QAAUE,EAASE,GAASA,EAAMY,IAAId,EAAKM,GAAW,OAAOA,EAJttBS,CAAwBC,EAAQ,KAExC,SAASb,IAA6B,GAAuB,oBAAZc,QAAwB,OAAO,KAAM,IAAIf,EAAQ,IAAIe,QAAqE,OAA1Dd,EAA2B,WAAc,OAAOD,GAAiBA,EAMlL,IAEM0e,E,WACJ,WAAY/c,EAAOsN,EAAM9N,EAAOM,GAAY,UAC1Ce,KAAKmc,MAAQ,KACbnc,KAAKf,WAAaA,EAClBe,KAAKb,MAAQA,EACba,KAAKrB,MAAQA,EACbqB,KAAKyM,KAAOA,E,8CAGF1N,GACV,IAAM0N,EAAOzM,KAAKyM,KAClB,GAAIA,EAAKtD,OAASsD,EAAK5B,KAAM,OAAO,EACpC,GAAI4B,EAAK1N,EAAKqH,MAAO,OAAO,EAC5B,IAAMjG,EAAO9C,EAAE8b,aAAapa,EAAKqH,MACjC,KAAc,MAARjG,OAAe,EAASA,EAAKkB,QAAS,OAAO,EALnC,UAOElB,GAPF,IAOhB,2BAAwB,CACtB,GAAIpB,EADkB,SACP,OAAO,GARR,8BAWhB,OAAO,I,6BAGFA,EAAMzB,EAAKS,EAAK0G,GACrB,OAAOqU,EAAM1b,QAAQO,IAAI,CACvBsB,WAAYe,KAAKf,WACjBK,OAAQP,EACR0C,UAAWnE,EACXS,IAAKA,EACL0G,c,iCAIO/F,EAAM0d,GACf,GAAIpc,KAAKqc,KACP,MAAM,IAAInS,MAAM,2BAGdlK,KAAKmc,QACHC,EACFpc,KAAKmc,MAAM3c,KAAKd,GAEhBsB,KAAKsc,cAAc9c,KAAKd,M,oCAKhB+C,EAAWnC,EAAQmF,GAC/B,GAAyB,IAArBhD,EAAUJ,OAAc,OAAO,EAGnC,IAFA,IAAM8a,EAAQ,GAELpe,EAAM,EAAGA,EAAM0D,EAAUJ,OAAQtD,IAAO,CAC/C,IAAMgB,EAAO0C,EAAU1D,GAEnBgB,GAAQiB,KAAKuc,YAAYxd,IAC3Bod,EAAM3c,KAAKQ,KAAKiG,OAAO3G,EAAQmC,EAAW1D,EAAK0G,IAInD,OAAOzE,KAAKwc,WAAWL,K,kCAGbpd,EAAMhB,GAChB,QAAIiC,KAAKuc,YAAYxd,EAAKhB,KACjBiC,KAAKwc,WAAW,CAACxc,KAAKiG,OAAOlH,EAAMA,EAAMhB,O,iCAMzCoe,GACTnc,KAAKmc,MAAQA,EACbnc,KAAKsc,cAAgB,GACrB,IAHgB,EAGVG,EAAU,IAAIC,QAChB7c,GAAO,EAJK,IAMGsc,GANH,IAMhB,2BAA0B,KAAfzd,EAAe,QAOxB,GANAA,EAAKie,SAEwB,IAAzBje,EAAKwc,SAAS7Z,QAAgB3C,EAAKwc,SAASxc,EAAKwc,SAAS7Z,OAAS,KAAOrB,MAC5EtB,EAAKke,YAAY5c,MAGF,OAAbtB,EAAKX,IAAT,CArFU8e,MA8Ec,IActB9d,EACEL,EADFK,KAEF,IAAI0d,EAAQ/e,IAAIqB,GAAhB,CAGA,GAFIA,GAAM0d,EAAQK,IAAI/d,GAElBL,EAAK8a,QAAS,CAChB3Z,GAAO,EACP,MAGF,GAAIG,KAAKsc,cAAcjb,SACrBxB,EAAOG,KAAKwc,WAAWxc,KAAKsc,eAC5Btc,KAAKsc,cAAgB,GACrBtc,KAAKmc,MAAQA,EACTtc,GAAM,SAlCE,wCAsCGsc,GAtCH,IAsChB,2BAA0B,SACnBY,cAvCS,8BA2ChB,OADA/c,KAAKmc,MAAQ,KACNtc,I,4BAGHd,EAAMhB,GACV,IAAMif,EAAQje,EAAKhB,GACnB,QAAKif,IAEDzb,MAAMC,QAAQwb,GACThd,KAAKid,cAAcD,EAAOje,EAAMhB,GAEhCiC,KAAKkd,YAAYne,EAAMhB,Q,KAMpCb,EAAQE,QAAU8e,G,qDClJlBlf,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQE,aAAU,EAEHgR,EAAuB9P,EAAQ,MAA9C,IAEI6e,EAAgC/O,EAAuB9P,EAAQ,OAMnE,SAAiChB,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEF,QAASE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAMG,IAAIL,GAAQ,IAAIM,EAAS,GAAQC,EAAwBb,OAAOC,gBAAkBD,OAAOc,yBAA0B,IAAK,IAAIC,KAAOT,EAAO,GAAIN,OAAOgB,UAAUC,eAAeC,KAAKZ,EAAKS,GAAM,CAAE,IAAII,EAAON,EAAwBb,OAAOc,yBAAyBR,EAAKS,GAAO,KAAUI,IAASA,EAAKR,KAAOQ,EAAKC,KAAQpB,OAAOC,eAAeW,EAAQG,EAAKI,GAAgBP,EAAOG,GAAOT,EAAIS,GAAYH,EAAOR,QAAUE,EAASE,GAASA,EAAMY,IAAId,EAAKM,GAJpsBS,CAAwBC,EAAQ,KAExC,SAASb,IAA6B,GAAuB,oBAAZc,QAAwB,OAAO,KAAM,IAAIf,EAAQ,IAAIe,QAAqE,OAA1Dd,EAA2B,WAAc,OAAOD,GAAiBA,EAIlL,SAAS4Q,EAAuB9Q,GAAO,OAAOA,GAAOA,EAAIC,WAAaD,EAAM,CAAEF,QAASE,GAEvF,IAAM8f,EAAgB,CACpB3e,qBADoB,WAGjBE,GAAO,IADRI,EACQ,EADRA,KAEIA,EAAKC,OAASL,EAAMwU,UACtBpU,EAAKC,KAAOL,EAAMyU,UAItBhH,MAToB,SASd1N,EAAMC,GACLD,EAAKS,MAAMiB,wBAAwBzB,EAAMwU,QAASxU,EAAMc,QAAQY,aACnE3B,EAAK2e,QAIT,sDAfoB,SAekC3e,EAAMC,GAC1D,IAAID,EAAKoO,wBAAT,CACA,IAAM9G,EAAMtH,EAAKiH,6BAEjB,IAAK,IAAM3G,KAAQgH,EACbhH,IAASL,EAAMwU,UAASnN,EAAIhH,GAAMA,KAAOL,EAAMyU,YAMnDkK,E,WACJ,WAAY7d,EAAS0T,EAASC,GAAS,UACrCpT,KAAKoT,QAAUA,EACfpT,KAAKmT,QAAUA,EACfnT,KAAKP,QAAUA,E,oEAGiB8d,GAChC,IAAMC,EAAoBD,EAAate,WAElCue,EAAkBjX,wBAInBiX,EAAkBC,+BAAiCD,EAAkB7f,IAAI,eAAeoB,KAAKmH,KAIjG,EAAIiX,EAA8B/f,SAASogB,M,+DAGJ9e,M,8DASDA,M,6BAWjCgT,GAAO,IAEVjS,EAGEO,KAHFP,QACA0T,EAEEnT,KAFFmT,QACAC,EACEpT,KADFoT,QAGAjU,EAEEM,EAFFN,MAGIoe,EADF9d,EADFf,KAEwBgf,MAAK,SAAAhf,GAAI,OAAIA,EAAK+H,iBAAmB/H,EAAKiI,wBAA0BjI,EAAKif,uBAE/FJ,IACiBA,EAAa5X,6BAEjBwN,KAAa1T,EAAQY,YAClCL,KAAK4d,kCAAkCL,IAI3Cpe,EAAMyC,SAAS8P,GAASvS,EAAMuS,MAAO0L,EAAepd,MAE/C0R,IACHvS,EAAM+Y,iBAAiB/E,GACvBhU,EAAMW,SAASsT,GAAW3T,EAC1BO,KAAKP,QAAQY,WAAWrB,KAAOoU,GAG7B3T,EAAQ2G,KAERmX,IACFvd,KAAK6d,yCAAyCN,GAC9Cvd,KAAK8d,wCAAwCP,Q,KAMnDrgB,EAAQE,QAAUkgB,G,6CC1HlBtgB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQkb,WAqBR,SAAoB2F,GAClB,IAAIrf,EAAOsB,KAEX,KAAOtB,EAAOA,EAAKO,YACjB,GAAI8e,EAASrf,GAAO,OAAOA,EAG7B,OAAO,MA3BTxB,EAAQwgB,KA8BR,SAAcK,GACZ,IAAIrf,EAAOsB,KAEX,GACE,GAAI+d,EAASrf,GAAO,OAAOA,QACpBA,EAAOA,EAAKO,YAErB,OAAO,MApCT/B,EAAQ8E,kBAuCR,WACE,OAAOhC,KAAKoY,YAAW,SAAAC,GAAC,OAAIA,EAAEjZ,iBAvChClC,EAAQ8gB,mBA0CR,WACE,IAAItf,EAAOsB,KAEX,EAAG,CACD,IAAKtB,EAAKO,YAAcsC,MAAMC,QAAQ9C,EAAK+C,YAAc/C,EAAKgD,cAC5D,MAEAhD,EAAOA,EAAKO,iBAEPP,GAET,GAAIA,IAASA,EAAKgC,aAAehC,EAAKuf,UACpC,MAAM,IAAI/T,MAAM,wEAGlB,OAAOxL,GAxDTxB,EAAQghB,8BA2DR,SAAuClb,GACrC,OAAOhD,KAAKme,6BAA6Bnb,GAAO,SAAUob,EAAShd,EAAGid,GACpE,IAAIC,EAD4E,EAE1Ene,EAAO9C,EAAE8b,aAAaiF,EAAQhY,MAF4C,IAIzDiY,GAJyD,IAIhF,2BAAmC,KAC3B3f,EAD2B,QACX0C,EAAI,GAE1B,GAAKkd,EAKL,GAAI5f,EAAK+F,SAAW6Z,EAAS7Z,UAAY/F,EAAK+F,SACxC/F,EAAKX,IAAMugB,EAASvgB,IACtBugB,EAAW5f,OAKUyB,EAAKI,QAAQ+d,EAASzd,WACvBV,EAAKI,QAAQ7B,EAAKmC,aAGxCyd,EAAW5f,QAfX4f,EAAW5f,GARiE,8BA2BhF,OAAO4f,MAtFXphB,EAAQihB,6BA0FR,SAAsCnb,EAAOub,GAAQ,WACnD,IAAKvb,EAAM3B,OACT,OAAOrB,KAGT,GAAqB,IAAjBgD,EAAM3B,OACR,OAAO2B,EAAM,GAGf,IACIwb,EAAiBC,EADjBC,EAAWC,IAETN,EAAarb,EAAMsC,KAAI,SAAA5G,GAC3B,IAAMkgB,EAAW,GAEjB,GACEA,EAAS1K,QAAQxV,UACTA,EAAOA,EAAKO,aAAeP,IAAS,GAM9C,OAJIkgB,EAASvd,OAASqd,IACpBA,EAAWE,EAASvd,QAGfud,KAEHC,EAAQR,EAAW,GAEzBS,EAAW,IAAK,IAAI1d,EAAI,EAAGA,EAAIsd,EAAUtd,IAAK,CAC5C,IAD4C,EACtC2d,EAAcF,EAAMzd,GADkB,IAGrBid,GAHqB,IAG5C,2BAAmC,CACjC,GADiC,QACpBjd,KAAO2d,EAClB,MAAMD,GALkC,8BAS5CN,EAAkBpd,EAClBqd,EAAaM,EAGf,GAAIN,EACF,OAAIF,EACKA,EAAOE,EAAYD,EAAiBH,GAEpCI,EAGT,MAAM,IAAIvU,MAAM,+BAvIpBhN,EAAQ8hB,YA2IR,WACE,IAAItgB,EAAOsB,KACLgD,EAAQ,GAEd,GACEA,EAAMxD,KAAKd,SACJA,EAAOA,EAAKO,YAErB,OAAO+D,GAlJT9F,EAAQ+hB,WAqJR,SAAoBC,GAClB,OAAOA,EAAgBC,aAAanf,OArJtC9C,EAAQiiB,aAwJR,SAAsBC,GACpB,QAASpf,KAAKoY,YAAW,SAAA9Y,GAAM,OAAIA,IAAW8f,MAxJhDliB,EAAQmiB,OA2JR,WACE,IAAI3gB,EAAOsB,KAEX,KAAOtB,GAAM,WACQsM,WADR,IACX,2BAA8B,KAAnB5E,EAAmB,QAC5B,GAAI1H,EAAKK,KAAKqH,OAASA,EAAM,OAAO,GAF3B,8BAKX1H,EAAOA,EAAKO,WAGd,OAAO,GApKT,IAIgC3B,EAJ5BD,EAQJ,SAAiCC,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEF,QAASE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAMG,IAAIL,GAAQ,IAAIM,EAAS,GAAQC,EAAwBb,OAAOC,gBAAkBD,OAAOc,yBAA0B,IAAK,IAAIC,KAAOT,EAAO,GAAIN,OAAOgB,UAAUC,eAAeC,KAAKZ,EAAKS,GAAM,CAAE,IAAII,EAAON,EAAwBb,OAAOc,yBAAyBR,EAAKS,GAAO,KAAUI,IAASA,EAAKR,KAAOQ,EAAKC,KAAQpB,OAAOC,eAAeW,EAAQG,EAAKI,GAAgBP,EAAOG,GAAOT,EAAIS,GAAYH,EAAOR,QAAUE,EAASE,GAASA,EAAMY,IAAId,EAAKM,GAAW,OAAOA,EARttBS,CAAwBC,EAAQ,MAIRhB,EAFIgB,EAAQ,MAEShB,EAAIC,WAEzD,SAASE,IAA6B,GAAuB,oBAAZc,QAAwB,OAAO,KAAM,IAAIf,EAAQ,IAAIe,QAAqE,OAA1Dd,EAA2B,WAAc,OAAOD,GAAiBA,I,6CCpBlLR,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQoiB,kBAeR,WACE,GAAItf,KAAKuf,eAAgB,OAAOvf,KAAKuf,eACrC,IAAInZ,EAAOpG,KAAKwf,sBAAwBniB,EAAEoiB,oBACtCpiB,EAAEqiB,iBAAiBtZ,KAAOA,EAAOA,EAAKmZ,gBAC1C,OAAOvf,KAAKuf,eAAiBnZ,GAlB/BlJ,EAAQsiB,mBAuBR,WACE,IAAMzgB,EAAOiB,KAAKjB,KAElB,IAAKA,EAAM,CACT,GAAiB,SAAbiB,KAAKjC,KAAkBiC,KAAKf,WAAWoD,uBAAwB,CACjE,IAAMuN,EAAS5P,KAAKf,WAAWA,WACzB0gB,EAAe/P,EAAO3Q,WAE5B,MAAmB,SAAf2Q,EAAO7R,KAAkB4hB,EAAaC,mBACjCviB,EAAEwiB,uBAGQ,SAAfjQ,EAAO7R,KAAkB4hB,EAAaG,mBACjCziB,EAAEoiB,oBAGJpiB,EAAE0iB,qBAET,OAIJ,GAAIhhB,EAAKwgB,eACP,OAAOxgB,EAAKwgB,eAGd,GAAIS,EAA6BtiB,IAAIqB,GACnC,OAGFihB,EAA6BlD,IAAI/d,GAEjC,IACE,IAAIkhB,EAEAC,EAAUC,EAASphB,EAAKqH,MAE5B,GAAI8Z,EACF,OAAOA,EAAQhiB,KAAK8B,KAAMjB,GAK5B,GAFAmhB,EAAUC,EAASngB,KAAKf,WAAWmH,MAEP,OAAvB6Z,EAAWC,QAAmB,EAASD,EAASG,YACnD,OAAOpgB,KAAKf,WAAWqgB,oBAZ3B,QAeEU,EAA6BrG,OAAO5a,KArExC7B,EAAQmjB,WAyER,SAAoBC,EAAUC,GAC5B,OAAOC,EAAYF,EAAUtgB,KAAKsf,oBAAqBiB,IAzEzDrjB,EAAQujB,gBAoGR,SAAyBzhB,GACvB,IAAMoH,EAAOpG,KAAKsf,oBAClB,GAAIjiB,EAAEqjB,oBAAoBta,GAAO,OAAO,EAExC,GAAI/I,EAAEsjB,sBAAsBva,GAAO,WACbA,EAAKmD,OADQ,IACjC,2BAAgC,KAArBqX,EAAqB,QAC9B,GAAIvjB,EAAEqjB,oBAAoBE,IAAUJ,EAAYxhB,EAAM4hB,GAAO,GAC3D,OAAO,GAHsB,8BAOjC,OAAO,EAEP,OAAOJ,EAAYxhB,EAAMoH,GAAM,IAhHnClJ,EAAQ2jB,wBAoHR,SAAiCrL,GAC/B,IAAMxI,EAAOhN,KAAKsf,oBAGlB,GAFA9J,EAAQA,EAAM8J,qBAETjiB,EAAEqjB,oBAAoB1T,IAAS3P,EAAEyjB,qBAAqB9T,GACzD,OAAOwI,EAAMpP,OAAS4G,EAAK5G,MAxH/BlJ,EAAQyW,cA4HR,SAAuBoN,GACrB,IAAM3a,EAAOpG,KAAKsf,oBAClB,OAAOjiB,EAAE2jB,wBAAwB5a,IAAS/I,EAAEgJ,aAAaD,EAAKF,GAAI,CAChElH,KAAM+hB,KA7HV,IAAIZ,EAAW9hB,EAAwBC,EAAQ,MAE3CjB,EAAIgB,EAAwBC,EAAQ,KAExC,SAASb,IAA6B,GAAuB,oBAAZc,QAAwB,OAAO,KAAM,IAAIf,EAAQ,IAAIe,QAAqE,OAA1Dd,EAA2B,WAAc,OAAOD,GAAiBA,EAElL,SAASa,EAAwBf,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEF,QAASE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAMG,IAAIL,GAAQ,IAAIM,EAAS,GAAQC,EAAwBb,OAAOC,gBAAkBD,OAAOc,yBAA0B,IAAK,IAAIC,KAAOT,EAAO,GAAIN,OAAOgB,UAAUC,eAAeC,KAAKZ,EAAKS,GAAM,CAAE,IAAII,EAAON,EAAwBb,OAAOc,yBAAyBR,EAAKS,GAAO,KAAUI,IAASA,EAAKR,KAAOQ,EAAKC,KAAQpB,OAAOC,eAAeW,EAAQG,EAAKI,GAAgBP,EAAOG,GAAOT,EAAIS,GAAyE,OAA7DH,EAAOR,QAAUE,EAASE,GAASA,EAAMY,IAAId,EAAKM,GAAkBA,EAS9tB,IAAMoiB,EAA+B,IAAItD,QAyDzC,SAAS8D,EAAYF,EAAUla,EAAMma,GACnC,GAAiB,WAAbD,EACF,OAAOjjB,EAAE4jB,uBAAuB7a,GAC3B,GAAiB,WAAbka,EACT,OAAOjjB,EAAE6jB,uBAAuB9a,GAC3B,GAAiB,YAAbka,EACT,OAAOjjB,EAAE8jB,wBAAwB/a,GAC5B,GAAiB,QAAbka,EACT,OAAOjjB,EAAEqjB,oBAAoBta,GACxB,GAAiB,UAAbka,EACT,OAAOjjB,EAAE+jB,sBAAsBhb,GAC1B,GAAiB,UAAbka,EACT,OAAOjjB,EAAEgkB,sBAAsBjb,GAC1B,GAAiB,SAAbka,EACT,OAAOjjB,EAAEikB,qBAAqBlb,GAE9B,GAAIma,EACF,OAAO,EAEP,MAAM,IAAIrW,MAAJ,4BAA+BoW,M,iCCrG3CtjB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQqkB,mBAwCR,WACE,IAAIC,EAGJ,IADWxhB,KAAKrC,IAAI,MACZ0I,eAAgB,OACxB,IAAM6G,EAAOlN,KAAKrC,IAAI,QAClByI,EAAO8G,EAAKoS,oBAEuC,uBAAhC,OAAjBkC,EAAQpb,QAAgB,EAASob,EAAMpb,OACvC8G,EAAKuU,oBAAsBvU,EAAKvP,IAAI,UAAU0I,aAAa,CAC7DrH,KAAM,YACDkO,EAAK/N,MAAMgT,WAAW,SAAS,KACpC/L,EAAOsb,KAIX,OAAOtb,GAvDTlJ,EAAQykB,mBAAqBA,EAC7BzkB,EAAQ0kB,cA+DR,SAAuB7iB,GACrB,GAAIiB,KAAKrC,IAAI,UAAU0I,eACrB,OAAOhJ,EAAEwkB,sBAAsB9iB,EAAKkQ,SAhExC/R,EAAQ4kB,gBAoER,WACE,OAAOzkB,EAAEwiB,wBApEX3iB,EAAQ6T,gBAuER,SAAyBhS,GACvB,IAAMiS,EAAWjS,EAAKiS,SAEtB,GAAiB,SAAbA,EACF,OAAO3T,EAAE0iB,qBACJ,GAAI1iB,EAAE0kB,uBAAuBxhB,QAAQyQ,IAAa,EACvD,OAAO3T,EAAE2kB,uBACJ,GAAI3kB,EAAE4kB,uBAAuB1hB,QAAQyQ,IAAa,EACvD,OAAO3T,EAAEwiB,uBACJ,GAAIxiB,EAAE6kB,wBAAwB3hB,QAAQyQ,IAAa,EACxD,OAAO3T,EAAE8kB,yBAhFbjlB,EAAQklB,iBAoFR,SAA0BrjB,GACxB,IAAMiS,EAAWjS,EAAKiS,SAEtB,GAAI3T,EAAEglB,wBAAwB9hB,QAAQyQ,IAAa,EACjD,OAAO3T,EAAE2kB,uBACJ,GAAI3kB,EAAEilB,yBAAyB/hB,QAAQyQ,IAAa,EACzD,OAAO3T,EAAE8kB,wBACJ,GAAiB,MAAbnR,EAAkB,CAC3B,IAAMwE,EAAQxV,KAAKrC,IAAI,SACjBqP,EAAOhN,KAAKrC,IAAI,QAEtB,OAAIqP,EAAKqT,WAAW,WAAa7K,EAAM6K,WAAW,UACzChjB,EAAE2kB,uBACAhV,EAAKqT,WAAW,WAAa7K,EAAM6K,WAAW,UAChDhjB,EAAEwiB,uBAGJxiB,EAAEklB,oBAAoB,CAACllB,EAAEwiB,uBAAwBxiB,EAAE2kB,2BApG9D9kB,EAAQslB,kBAwGR,WACE,IAAMC,EAAgB,CAACziB,KAAKrC,IAAI,QAAQ2hB,oBAAqBtf,KAAKrC,IAAI,SAAS2hB,qBAE/E,GAAIjiB,EAAEqlB,mBAAmBD,EAAc,KAAOplB,EAAEslB,kBAC9C,OAAOtlB,EAAEslB,kBAAkBF,GAG7B,GAAIplB,EAAEulB,oBACJ,OAAOvlB,EAAEulB,oBAAoBH,GAG/B,OAAOplB,EAAEwlB,0BAA0BJ,IAlHrCvlB,EAAQ4lB,sBAqHR,WACE,IAAML,EAAgB,CAACziB,KAAKrC,IAAI,cAAc2hB,oBAAqBtf,KAAKrC,IAAI,aAAa2hB,qBAEzF,GAAIjiB,EAAEqlB,mBAAmBD,EAAc,KAAOplB,EAAEslB,kBAC9C,OAAOtlB,EAAEslB,kBAAkBF,GAG7B,GAAIplB,EAAEulB,oBACJ,OAAOvlB,EAAEulB,oBAAoBH,GAG/B,OAAOplB,EAAEwlB,0BAA0BJ,IA/HrCvlB,EAAQ6lB,mBAkIR,WACE,OAAO/iB,KAAKrC,IAAI,eAAeqD,MAAMse,qBAlIvCpiB,EAAQ8lB,wBAqIR,WACE,OAAOhjB,KAAKrC,IAAI,cAAc2hB,qBArIhCpiB,EAAQ0T,qBAwIR,WACE,OAAO5Q,KAAKrC,IAAI,SAAS2hB,qBAxI3BpiB,EAAQ4T,iBA2IR,SAA0B/R,GACxB,IAAMiS,EAAWjS,EAAKiS,SAEtB,GAAiB,OAAbA,GAAkC,OAAbA,EACvB,OAAO3T,EAAE2kB,wBA9Ib9kB,EAAQ+lB,cAkJR,WACE,OAAO5lB,EAAEwiB,wBAlJX3iB,EAAQgmB,eAqJR,WACE,OAAO7lB,EAAE2kB,wBArJX9kB,EAAQimB,eAwJR,WACE,OAAO9lB,EAAE8kB,yBAxJXjlB,EAAQkmB,YA2JR,WACE,OAAO/lB,EAAEgmB,6BA3JXnmB,EAAQomB,cA8JR,WACE,OAAOjmB,EAAEwkB,sBAAsBxkB,EAAEgD,WAAW,YA9J9CnD,EAAQqmB,iBAiKR,WACE,OAAOlmB,EAAEwkB,sBAAsBxkB,EAAEgD,WAAW,YAjK9CnD,EAAQwkB,gBAAkBA,EAC1BxkB,EAAQsmB,YAAcA,EACtBtmB,EAAQumB,iBAAmBvmB,EAAQsU,gBAAkBtU,EAAQwmB,oBAAsBxmB,EAAQymB,wBAA0BzmB,EAAQ0mB,mBA4K7H,WACE,OAAOvmB,EAAEwkB,sBAAsBxkB,EAAEgD,WAAW,cA5K9CnD,EAAQ2mB,eAoLR,WAA0B,IAEtB5U,EACEjP,KAAKjB,KADPkQ,OAGF,GAAI6U,EAAa7U,GACf,OAAO5R,EAAE0mB,oBAAoB1mB,EAAEwiB,wBAC1B,GAAImE,EAAY/U,IAAWgV,EAAehV,GAC/C,OAAO5R,EAAE0mB,oBAAoB1mB,EAAEoiB,qBAC1B,GAAIyE,EAAgBjV,GACzB,OAAO5R,EAAE0mB,oBAAoB1mB,EAAE8mB,oBAAoB,CAAC9mB,EAAEwiB,uBAAwBxiB,EAAEoiB,uBAGlF,OAAO2E,EAAYpkB,KAAKrC,IAAI,YAhM9BT,EAAQmnB,yBAmMR,WACE,OAAOD,EAAYpkB,KAAKrC,IAAI,SAnM9BX,OAAOC,eAAeC,EAAS,aAAc,CAC3C2b,YAAY,EACZlb,IAAK,WACH,OAAO2mB,EAAkBlnB,WAI7B,IAIgCE,EAJ5BD,EAQJ,SAAiCC,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEF,QAASE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAMG,IAAIL,GAAQ,IAAIM,EAAS,GAAQC,EAAwBb,OAAOC,gBAAkBD,OAAOc,yBAA0B,IAAK,IAAIC,KAAOT,EAAO,GAAIN,OAAOgB,UAAUC,eAAeC,KAAKZ,EAAKS,GAAM,CAAE,IAAII,EAAON,EAAwBb,OAAOc,yBAAyBR,EAAKS,GAAO,KAAUI,IAASA,EAAKR,KAAOQ,EAAKC,KAAQpB,OAAOC,eAAeW,EAAQG,EAAKI,GAAgBP,EAAOG,GAAOT,EAAIS,GAAYH,EAAOR,QAAUE,EAASE,GAASA,EAAMY,IAAId,EAAKM,GAAW,OAAOA,EARttBS,CAAwBC,EAAQ,KAEpCgmB,GAE4BhnB,EAFegB,EAAQ,OAEFhB,EAAIC,WAAaD,EAAM,CAAEF,QAASE,GAEvF,SAASG,IAA6B,GAAuB,oBAAZc,QAAwB,OAAO,KAAM,IAAIf,EAAQ,IAAIe,QAAqE,OAA1Dd,EAA2B,WAAc,OAAOD,GAAiBA,EAuBlL,SAASmkB,EAAmB5iB,GAC1B,OAAOA,EAAKwgB,eA0Hd,SAASmC,IACP,OAAOrkB,EAAEwkB,sBAAsBxkB,EAAEgD,WAAW,UAG9C,SAASmjB,IACP,OAAO9B,IA5HTC,EAAmBvB,aAAc,EA+HjCoD,EAAYpD,aAAc,EAM1B,IAAM4D,EAAc3mB,EAAEknB,2BAA2B,cAC3CT,EAAezmB,EAAEknB,2BAA2B,eAC5CN,EAAiB5mB,EAAEknB,2BAA2B,iBAC9CL,EAAkB7mB,EAAEknB,2BAA2B,kBAsBrD,SAASH,EAAYnV,GAGnB,IAFAA,EAASA,EAAOuV,WAELplB,aAAc,CACvB,GAAI6P,EAAOwV,GAAG,SACZ,OAAIxV,EAAOwV,GAAG,aACLpnB,EAAEwkB,sBAAsBxkB,EAAEgD,WAAW,kBAErChD,EAAEwkB,sBAAsBxkB,EAAEgD,WAAW,YAG9C,GAAI4O,EAAOlQ,KAAK2lB,WACd,OAAOzV,EAAOlQ,KAAK2lB,c,6CC5O3B1nB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQE,QAQR,SAAkB2B,GAChB,IAAKiB,KAAK0M,eAAgB,OAC1B,IAAMjN,EAAUO,KAAKb,MAAMO,WAAWX,EAAKC,MAE3C,GAAIS,EACF,OAAIA,EAAQY,WAAWkf,eACd9f,EAAQY,WAAWkf,eAahC,SAAoD9f,EAASf,EAAMM,GACjE,IAAMuK,EAAQ,GACRob,EAA6B,GAC/BhlB,EAAqBilB,EAA4BnlB,EAASf,EAAMimB,GAC9DE,EAAWC,EAAyBrlB,EAASf,EAAMM,GAEzD,GAAI6lB,EAAU,CACZ,IAAME,EAAyBH,EAA4BnlB,EAASolB,EAASG,aAC7ErlB,EAAqBA,EAAmB4e,QAAO,SAAA7f,GAAI,OAAIqmB,EAAuBxkB,QAAQ7B,GAAQ,KAC9F6K,EAAM/J,KAAKqlB,EAAStF,gBAGtB,GAAI5f,EAAmB0B,OAAQ,CAC7B1B,EAAqBA,EAAmBoG,OAAO4e,GADlB,UAGLhlB,GAHK,IAG7B,2BAA4C,KAAjCslB,EAAiC,QAC1C1b,EAAM/J,KAAKylB,EAAU3F,sBAJM,+BAQ/B,IAAK/V,EAAMlI,OACT,OAGF,GAAIhE,EAAEqlB,mBAAmBnZ,EAAM,KAAOlM,EAAEslB,kBACtC,OAAOtlB,EAAEslB,kBAAkBpZ,GAG7B,GAAIlM,EAAEulB,oBACJ,OAAOvlB,EAAEulB,oBAAoBrZ,GAG/B,OAAOlM,EAAEwlB,0BAA0BtZ,GA3CxB2b,CAA2CzlB,EAASO,KAAMjB,EAAKC,MAI1E,GAAkB,cAAdD,EAAKC,KACP,OAAO3B,EAAE0iB,qBACJ,GAAkB,QAAdhhB,EAAKC,MAAgC,aAAdD,EAAKC,KACrC,OAAO3B,EAAE2kB,uBACAjjB,EAAKC,MAtBlB,IAAI3B,EAIJ,SAAiCC,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEF,QAASE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAMG,IAAIL,GAAQ,IAAIM,EAAS,GAAQC,EAAwBb,OAAOC,gBAAkBD,OAAOc,yBAA0B,IAAK,IAAIC,KAAOT,EAAO,GAAIN,OAAOgB,UAAUC,eAAeC,KAAKZ,EAAKS,GAAM,CAAE,IAAII,EAAON,EAAwBb,OAAOc,yBAAyBR,EAAKS,GAAO,KAAUI,IAASA,EAAKR,KAAOQ,EAAKC,KAAQpB,OAAOC,eAAeW,EAAQG,EAAKI,GAAgBP,EAAOG,GAAOT,EAAIS,GAAYH,EAAOR,QAAUE,EAASE,GAASA,EAAMY,IAAId,EAAKM,GAAW,OAAOA,EAJttBS,CAAwBC,EAAQ,KAExC,SAASb,IAA6B,GAAuB,oBAAZc,QAAwB,OAAO,KAAM,IAAIf,EAAQ,IAAIe,QAAqE,OAA1Dd,EAA2B,WAAc,OAAOD,GAAiBA,EA0DlL,SAASonB,EAA4BnlB,EAASf,EAAMymB,GAClD,IAAM1R,EAAahU,EAAQE,mBAAmB+S,QAE9C,OADAe,EAAWS,QAAQzU,EAAQf,MACpB+U,EAAW8K,QAAO,SAAA0G,GAGvB,IAAMG,GAFNH,EAAYA,EAAUT,WAEGa,gCAAgC3mB,GAGzD,OADIymB,GAAwB,YAAXC,GAAsBD,EAAU3lB,KAAKylB,GACpC,WAAXG,KAIX,SAASE,EAAoCtmB,EAAMN,GACjD,IAGI6mB,EAyBAC,EACAC,EA7BEzU,EAAWtS,EAAKK,KAAKiS,SACrBwE,EAAQ9W,EAAKf,IAAI,SAAS6mB,UAC1BxX,EAAOtO,EAAKf,IAAI,QAAQ6mB,UAa9B,GAVIxX,EAAK3G,aAAa,CACpBrH,SAEAumB,EAAS/P,EACAA,EAAMnP,aAAa,CAC5BrH,WAEAumB,EAASvY,GAGPuY,EACF,MAAiB,QAAbvU,EACKuU,EAAOjG,oBAGZjiB,EAAEqoB,gCAAgCnlB,QAAQyQ,IAAa,EAClD3T,EAAE2kB,4BAGX,EAGF,IAAiB,QAAbhR,GAAmC,OAAbA,KAItBhE,EAAK+I,kBAAkB,CACzB/E,SAAU,YAEVwU,EAAaxY,EACbyY,EAAWjQ,GACFA,EAAMO,kBAAkB,CACjC/E,SAAU,aAEVwU,EAAahQ,EACbiQ,EAAWzY,GAGRwY,GACAA,EAAW7nB,IAAI,YAAY0I,aAAa,CAC3CrH,WAEFymB,EAAWA,EAASjB,WACN1V,aAAd,CACA,IAAM6W,EAAYF,EAAS1mB,KAAK5B,MAChC,GAAyB,kBAAdwoB,EACX,OAAOtoB,EAAEuoB,kCAAkCD,IAuB7C,SAASb,EAAyBrlB,EAASf,EAAMM,GAC/C,IAAMgmB,EArBR,SAAkCvlB,EAASf,EAAMM,GAG/C,IAFA,IAAIC,EAEGA,EAAaP,EAAKO,YAAY,CACnC,GAAIA,EAAWgE,iBAAmBhE,EAAW4mB,0BAA2B,CACtE,GAAiB,SAAbnnB,EAAKX,IACP,OAGF,OAAOkB,EAGT,GAAIA,EAAWG,cACTH,EAAWA,WAAWE,MAAMO,WAAWV,KAAUS,EAAS,OAGhEf,EAAOO,GAKW6mB,CAAyBrmB,EAASf,EAAMM,GAC5D,GAAKgmB,EAAL,CAKA,IAJA,IACMhiB,EAAQ,CADDgiB,EAAYrnB,IAAI,SAEvB4L,EAAQ,GAELnI,EAAI,EAAGA,EAAI4B,EAAM3B,OAAQD,IAAK,CACrC,IAAM1C,EAAOsE,EAAM5B,GAEnB,GAAI1C,EAAKqnB,sBACoB,OAAvBrnB,EAAKK,KAAKiS,WACZhO,EAAMxD,KAAKd,EAAKf,IAAI,SACpBqF,EAAMxD,KAAKd,EAAKf,IAAI,gBAEjB,GAAIe,EAAKsnB,qBAAsB,CACpC,IAAM5f,EAAOkf,EAAoCtmB,EAAMN,GACnD0H,GAAMmD,EAAM/J,KAAK4G,IAIzB,OAAImD,EAAMlI,OACJhE,EAAEqlB,mBAAmBnZ,EAAM,KAAOlM,EAAEslB,kBAC/B,CACLpD,eAAgBliB,EAAEslB,kBAAkBpZ,GACpCyb,eAIA3nB,EAAEulB,oBACG,CACLrD,eAAgBliB,EAAEulB,oBAAoBrZ,GACtCyb,eAIG,CACLzF,eAAgBliB,EAAEwlB,0BAA0BtZ,GAC5Cyb,eAIGF,EAAyBE,EAAahmB,M,6CCnM/ChC,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQ+oB,oBAqDR,SAA6BjJ,GAC3B,IAAIkJ,EAEJlmB,KAAK2c,SACLK,EAAQhd,KAAKmmB,gBAAgBnJ,GAC7B3f,EAAE+oB,uBAAuBpJ,EAAM,GAAIhd,KAAKjB,MACxC1B,EAAEgpB,wBAAwBrJ,EAAMA,EAAM3b,OAAS,GAAIrB,KAAKjB,MACL,OAAlDmnB,EAAiB3X,EAAO7P,KAAKf,IAAIqC,KAAKV,UAA4B4mB,EAAevM,OAAO3Z,KAAKjB,MAC9FiB,KAAKjB,KAAOiB,KAAKyB,UAAUzB,KAAKjC,KAAO,KACvC,IAAMiF,EAAQhD,KAAKsmB,YAAYtJ,GAE3Bhd,KAAKjB,KACPiB,KAAKumB,UAELvmB,KAAKkE,SAGP,OAAOlB,GArET9F,EAAQspB,wBAwER,SAAiCC,GAC/BzmB,KAAK2c,SAEL,IACE8J,EAAc,IAAH,OAAOA,EAAP,KACXA,GAAc,EAAIC,EAAQC,OAAOF,GACjC,MAAOG,GACP,IAAMpZ,EAAMoZ,EAAIpZ,IAYhB,MAVIA,IACFoZ,EAAInL,SAAW,yCAA0C,EAAIoL,EAAWC,kBAAkBL,EAAa,CACrGM,MAAO,CACL/e,KAAMwF,EAAIxF,KACVgf,OAAQxZ,EAAIwZ,OAAS,KAGzBJ,EAAIhL,KAAO,8BAGPgL,EAOR,OAJAH,EAAcA,EAAYnU,QAAQ8C,KAAK,GAAGhG,WAE1C5K,EAAOpH,QAAQsc,iBAAiB+M,GAEzBzmB,KAAK2C,YAAY8jB,IAjG1BvpB,EAAQyF,YAoGR,SAAqB8jB,GAGnB,GAFAzmB,KAAK2c,SAED3c,KAAKinB,QACP,MAAM,IAAI/c,MAAM,yDAGduc,aAAuBS,EAAQ9pB,UACjCqpB,EAAcA,EAAY1nB,MAG5B,IAAK0nB,EACH,MAAM,IAAIvc,MAAM,6EAGlB,GAAIlK,KAAKjB,OAAS0nB,EAChB,MAAO,CAACzmB,MAGV,GAAIA,KAAKU,cAAgBrD,EAAEqD,UAAU+lB,GACnC,MAAM,IAAIvc,MAAM,sEAGlB,GAAI3I,MAAMC,QAAQilB,GAChB,MAAM,IAAIvc,MAAM,2FAGlB,GAA2B,kBAAhBuc,EACT,MAAM,IAAIvc,MAAM,6FAGlB,IAAIid,EAAW,GAEXnnB,KAAKonB,WAAW,cAAgB/pB,EAAE+P,aAAaqZ,KAC5CzmB,KAAKqnB,0CAA6CrnB,KAAKsnB,qCAAqCb,IAAiBzmB,KAAKf,WAAWwe,+BAChIgJ,EAAcppB,EAAEkqB,oBAAoBd,GACpCU,EAAW,eAIf,GAAInnB,KAAKonB,WAAW,eAAiB/pB,EAAEqE,YAAY+kB,KAC5CzmB,KAAKqnB,2CAA6CrnB,KAAKsnB,qCAAqCb,GAC/F,OAAOzmB,KAAKwnB,gCAAgC,CAACf,IAIjD,IAAMgB,EAAUznB,KAAKjB,KAEjB0oB,IACFpqB,EAAEqqB,iBAAiBjB,EAAagB,GAChCpqB,EAAEsqB,eAAeF,IAQnB,OALAznB,KAAK4nB,aAAanB,GAElBzmB,KAAKoG,KAAOqgB,EAAYrgB,KACxBpG,KAAK6nB,WACL7nB,KAAKumB,UACE,CAACY,EAAWnnB,KAAKrC,IAAIwpB,GAAYnnB,OA7J1C9C,EAAQ0qB,aAgKR,SAAsB7oB,GACpB,IAAI+oB,EAEJ,IAAK9nB,KAAKyB,UACR,MAAM,IAAIkT,eAAe,sBAGvB3U,KAAKwb,OACPne,EAAEke,SAASvb,KAAKV,OAAQU,KAAKjC,IAAK,CAACgB,IAEnC1B,EAAEke,SAASvb,KAAKV,OAAQU,KAAKjC,IAAKgB,GAGpCiB,KAAKgb,MAAL,uBAAmC,MAARjc,OAAe,EAASA,EAAKqH,OACJ,OAAnD0hB,EAAkBvZ,EAAO7P,KAAKf,IAAIqC,KAAKV,UAA4BwoB,EAAgB1pB,IAAIW,EAAMiB,MAAM2Z,OAAO3Z,KAAKjB,MAChHiB,KAAKjB,KAAOiB,KAAKyB,UAAUzB,KAAKjC,KAAOgB,GA9KzC7B,EAAQsqB,gCAiLR,SAAyCxK,GACvChd,KAAK2c,SACL,IAAMoL,EAAuB1qB,EAAE0qB,qBAAqB/K,EAAOhd,KAAKb,OAEhE,GAAI4oB,EACF,OAAO/nB,KAAK2C,YAAYolB,GAAsB,GAAGpqB,IAAI,eAGvD,IAAMqqB,EAAiBhoB,KAAKgC,oBACtBimB,EAAkC,MAAlBD,OAAyB,EAASA,EAAevD,GAAG,SACpEhjB,EAAYpE,EAAE6qB,wBAAwB,GAAI7qB,EAAE8qB,eAAenL,IACjEhd,KAAK2C,YAAYtF,EAAEwW,eAAepS,EAAW,KAC7CzB,KAAK4B,SAASwmB,GACd,IAb8C,EAaxCC,EAAoBroB,KAAKrC,IAAI,UAAUoF,uBAbC,IAe3BslB,GAf2B,IAe9C,2BAAsC,KAA3B3pB,EAA2B,QACpC,GAAKA,EAAKuF,wBAAV,CACA,IAAMqkB,EAAO5pB,EAAK0Z,YAAW,SAAA1Z,GAAI,OAAIA,EAAKkY,YAE1C,GAAI0R,EAAM,CACR,IAAIrmB,EAAMqmB,EAAKpR,QAAQ,kCAEvB,GAAKjV,EAMHA,EAAM5E,EAAEgD,WAAW4B,EAAIjD,UANf,CACR,IAAMiQ,EAASjP,KAAKrC,IAAI,UACxBsE,EAAMgN,EAAO9P,MAAMopB,8BAA8B,OACjDtZ,EAAOtR,IAAI,QAAQ6qB,cAAc,OAAQnrB,EAAEorB,gBAAgBprB,EAAEuF,UAAUX,KACvEqmB,EAAKlR,QAAQ,iCAAkCnV,GAKjDvD,EAAKf,IAAI,cAAcgF,YAAYtF,EAAEqrB,qBAAqB,IAAKrrB,EAAEuF,UAAUX,GAAMvD,EAAKK,KAAKqQ,kBAE3F1Q,EAAKiE,YAAYtF,EAAEorB,gBAAgB/pB,EAAKK,KAAKqQ,eAjCH,8BAqC9C,IAAMH,EAASjP,KAAKrC,IAAI,UACxBsR,EAAO0Z,4BAEHV,GAAiBzjB,EAAOpH,QAAQyc,QAAQ7Z,KAAKrC,IAAI,eAAeoB,KAAM,kBAAmB1B,EAAEurB,kBAC7F3Z,EAAO7Q,IAAI,SAAS,GACpB4B,KAAK2C,YAAYtF,EAAEwrB,gBAAgB7oB,KAAKjB,QAG1C,OAAOkQ,EAAOtR,IAAI,cA7NpBT,EAAQ4rB,cAgOR,SAAuB9L,GAGrB,GAFAhd,KAAK2c,SAEDpb,MAAMC,QAAQwb,GAAQ,CACxB,GAAIzb,MAAMC,QAAQxB,KAAKyB,WAAY,CACjCub,EAAQhd,KAAKmmB,gBAAgBnJ,GAE7B,IAAMha,EAAQhD,KAAK+oB,sBAAsB/L,GAGzC,OADAhd,KAAKkE,SACElB,EAEP,OAAOhD,KAAKimB,oBAAoBjJ,GAGlC,OAAOhd,KAAK2C,YAAYqa,IA7O5B,IAAI6J,EAAavoB,EAAQ,KAErBkG,EAAS4J,EAAuB9P,EAAQ,KAExC4oB,EAAU9Y,EAAuB9P,EAAQ,KAEzCiQ,EAASjQ,EAAQ,KAEjBooB,EAAUpoB,EAAQ,KAElBjB,EAIJ,SAAiCC,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEF,QAASE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAMG,IAAIL,GAAQ,IAAIM,EAAS,GAAQC,EAAwBb,OAAOC,gBAAkBD,OAAOc,yBAA0B,IAAK,IAAIC,KAAOT,EAAO,GAAIN,OAAOgB,UAAUC,eAAeC,KAAKZ,EAAKS,GAAM,CAAE,IAAII,EAAON,EAAwBb,OAAOc,yBAAyBR,EAAKS,GAAO,KAAUI,IAASA,EAAKR,KAAOQ,EAAKC,KAAQpB,OAAOC,eAAeW,EAAQG,EAAKI,GAAgBP,EAAOG,GAAOT,EAAIS,GAAYH,EAAOR,QAAUE,EAASE,GAASA,EAAMY,IAAId,EAAKM,GAAW,OAAOA,EAJttBS,CAAwBC,EAAQ,KAExC,SAASb,IAA6B,GAAuB,oBAAZc,QAAwB,OAAO,KAAM,IAAIf,EAAQ,IAAIe,QAAqE,OAA1Dd,EAA2B,WAAc,OAAOD,GAAiBA,EAIlL,SAAS4Q,EAAuB9Q,GAAO,OAAOA,GAAOA,EAAIC,WAAaD,EAAM,CAAEF,QAASE,GAEvF,IAAM8qB,EAAwB,CAC5BhX,SAD4B,SACnB1S,GACPA,EAAK2e,QAGP2L,oBAL4B,SAKRtqB,GAClB,GAAuB,QAAnBA,EAAKK,KAAK6B,KAAd,CAGA,IAFA,IAAMd,EAAWpB,EAAK+G,wBAEtB,MAAkBzI,OAAOmD,KAAKL,GAA9B,eAAyC,CAApC,IAAM/B,EAAG,KACZW,EAAKS,MAAMK,KAAK,CACd0G,GAAIpG,EAAS/B,KAIjB,IAVwB,EAUlBkrB,EAAQ,GAVU,IAYHvqB,EAAKK,KAAKwR,cAZP,IAYxB,2BAA6C,KAAlCX,EAAkC,QACvCA,EAAO1C,MACT+b,EAAMzpB,KAAKnC,EAAEkqB,oBAAoBlqB,EAAEqrB,qBAAqB,IAAK9Y,EAAO1J,GAAI0J,EAAO1C,SAd3D,8BAkBxBxO,EAAKunB,oBAAoBgD,O,kCCrD7B,Y,YAEAjsB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQgsB,eAKR,WACE,IAAMC,EAAMnpB,KAAKopB,WACjB,GAAID,EAAIE,UAAW,QAASF,EAAIhsB,OANlCD,EAAQksB,SAgYR,WACE,IAAMzqB,EAAQ,CACZ0qB,WAAW,EACXC,UAAW,KACXC,KAAM,IAAI3X,KAERzU,EAAQqsB,EAAexpB,KAAMrB,GAC5BA,EAAM0qB,YAAWlsB,OAAQke,GAC9B,MAAO,CACLgO,UAAW1qB,EAAM0qB,UACjBI,MAAO9qB,EAAM2qB,UACbnsB,MAAOA,IA1YX,IAAMusB,EAAgB,CAAC,SAAU,SAAU,QACrCC,EAAkB,CAAC,UAOzB,SAASF,EAAM/qB,EAAMC,GACdA,EAAM0qB,YACX1qB,EAAM2qB,UAAY5qB,EAClBC,EAAM0qB,WAAY,GAGpB,SAASG,EAAe9qB,EAAMC,GAAO,IAEjCI,EACEL,EADFK,KAGAwqB,EACE5qB,EADF4qB,KAGF,GAAIA,EAAK7rB,IAAIqB,GAAO,CAClB,IAAMgL,EAAWwf,EAAK5rB,IAAIoB,GAE1B,OAAIgL,EAAS6f,SACJ7f,EAAS5M,WAEhBssB,EAAM/qB,EAAMC,GAId,IAAMkrB,EAAO,CACXD,UAAU,GAEZL,EAAKnrB,IAAIW,EAAM8qB,GAEf,IAAMvf,EAWV,SAAmB5L,EAAMC,GACvB,IAAKA,EAAM0qB,UAAW,OADQ,IAG5BtqB,EACEL,EADFK,KAGF,GAAIL,EAAKorB,uBAAwB,CAC/B,IAAMb,EAAQvqB,EAAKf,IAAI,eACvB,OAAO6rB,EAAeP,EAAMA,EAAM5nB,OAAS,GAAI1C,GAGjD,GAAID,EAAKqrB,mBAAqBrrB,EAAKsrB,oBAAsBtrB,EAAKurB,mBAC5D,OAAOlrB,EAAK5B,MAGd,GAAIuB,EAAKwrB,gBACP,OAAO,KAGT,GAAIxrB,EAAK0X,oBACP,OAAO+T,EAAezrB,EAAMK,EAAKqrB,OAAQzrB,GAG3C,GAAID,EAAKsX,8BAAgCtX,EAAKf,IAAI,OAAOgP,qBAAsB,CAC7E,IAAMoC,EAASrQ,EAAKf,IAAI,cAGpBqB,EAEA+P,EAHFhQ,KACEC,KAGEgQ,EAAWtQ,EAAKf,IAAI,gBAE1B,GAAIoR,EAAO1I,gBAA2B,WAATrH,IAAsBN,EAAKS,MAAMO,WAAWV,GAAM,IAASgQ,EAAS3I,cAAuC,QAAvB2I,EAASjQ,KAAKC,KAC7H,OAAOmrB,EAAezrB,EAAMK,EAAKoX,MAAMiU,OAAQzrB,GAAO,GAI1D,GAAID,EAAKmnB,0BAA2B,CAClC,IAAMwE,EAAab,EAAe9qB,EAAKf,IAAI,QAASgB,GACpD,IAAKA,EAAM0qB,UAAW,OAEtB,OACSG,EADLa,EACoB3rB,EAAKf,IAAI,cAETe,EAAKf,IAAI,aAFegB,GAMlD,GAAID,EAAK4rB,sBACP,OAAOd,EAAe9qB,EAAKf,IAAI,cAAegB,GAGhD,GAAID,EAAKiO,uBAAyBjO,EAAKO,WAAWwiB,iBAAiB,CACjExS,OAAQlQ,IACN,CACF,IAAMiQ,EAAWtQ,EAAKf,IAAI,YACpBoR,EAASrQ,EAAKf,IAAI,UAExB,GAAIoR,EAAOD,aAAeE,EAAS3I,eAAgB,CACjD,IAAMlJ,EAAQ4R,EAAOhQ,KAAK5B,MACpBiJ,SAAcjJ,EAEpB,GAAa,WAATiJ,GAA8B,WAATA,EACvB,OAAOjJ,EAAM6R,EAASjQ,KAAKC,OAKjC,GAAIN,EAAKyO,yBAA0B,CACjC,IAAM1N,EAAUf,EAAKS,MAAMO,WAAWX,EAAKC,MAE3C,GAAIS,GAAWA,EAAQE,mBAAmB0B,OAAS,EACjD,OAAOooB,EAAMhqB,EAAQf,KAAMC,GAG7B,GAAIc,GAAWf,EAAKK,KAAKgoB,MAAQtnB,EAAQf,KAAKK,KAAKwrB,IACjD,OAAOd,EAAMhqB,EAAQf,KAAMC,GAG7B,GAAe,MAAXc,OAAkB,EAASA,EAAQmZ,SACrC,OAAOnZ,EAAQtC,MAEf,GAAkB,cAAd4B,EAAKC,KACP,OAAOS,EAAUgqB,EAAMhqB,EAAQf,KAAMC,QAAS0c,EACzC,GAAkB,aAAdtc,EAAKC,KACd,OAAOS,EAAUgqB,EAAMhqB,EAAQf,KAAMC,GAASggB,IACzC,GAAkB,QAAd5f,EAAKC,KACd,OAAOS,EAAUgqB,EAAMhqB,EAAQf,KAAMC,GAAS6rB,IAGhD,IAAMZ,EAAWlrB,EAAK8lB,UAEtB,OAAIoF,IAAalrB,EACR+qB,EAAM/qB,EAAMC,GAEZ6qB,EAAeI,EAAUjrB,GAKtC,GAAID,EAAKqX,kBAAkB,CACzB0U,QAAQ,IACN,CACF,GAAsB,SAAlB1rB,EAAKiS,SACP,OAGF,IAAM7B,EAAWzQ,EAAKf,IAAI,YAE1B,GAAsB,WAAlBoB,EAAKiS,WAA0B7B,EAAS/P,cAAgB+P,EAAS+F,WACnE,MAAO,WAGT,IAAMwV,EAAMlB,EAAera,EAAUxQ,GACrC,IAAKA,EAAM0qB,UAAW,OAEtB,OAAQtqB,EAAKiS,UACX,IAAK,IACH,OAAQ0Z,EAEV,IAAK,IACH,OAAQA,EAEV,IAAK,IACH,OAAQA,EAEV,IAAK,IACH,OAAQA,EAEV,IAAK,SACH,cAAcA,GAIpB,GAAIhsB,EAAKkV,oBAAqB,CAC5B,IAD4B,EACtB+W,EAAM,GACNC,EAAQlsB,EAAKf,IAAI,YAFK,IAITitB,GAJS,IAI5B,2BAA0B,KAClBC,EADkB,QACDzB,WAEvB,IAAIyB,EAAUxB,UAGZ,OAAOI,EAAMoB,EAAUpB,MAAO9qB,GAF9BgsB,EAAInrB,KAAKqrB,EAAU1tB,QARK,8BAc5B,OAAOwtB,EAGT,GAAIjsB,EAAKuP,qBAAsB,CAC7B,IAD6B,EACvB3Q,EAAM,GACNwtB,EAAQpsB,EAAKf,IAAI,cAFM,IAIVmtB,GAJU,IAI7B,2BAA0B,KAAfnV,EAAe,QACxB,GAAIA,EAAKoV,kBAAoBpV,EAAKqV,kBAChC,OAAOvB,EAAM9T,EAAMhX,GAGrB,IACIZ,EADY4X,EAAKhY,IAAI,OAGzB,GAAIgY,EAAK5W,KAAK8W,SAAU,CAGtB,KAFA9X,EAAMA,EAAIqrB,YAEDC,UACP,OAAOI,EAAM1rB,EAAI0rB,MAAO9qB,GAG1BZ,EAAMA,EAAIZ,WAEVY,EADSA,EAAIsI,eACPtI,EAAIgB,KAAKC,KAETjB,EAAIgB,KAAK5B,MAGjB,IACIA,EADcwY,EAAKhY,IAAI,SACLyrB,WAEtB,IAAKjsB,EAAMksB,UACT,OAAOI,EAAMtsB,EAAMssB,MAAO9qB,GAG5BxB,EAAQA,EAAMA,MACdG,EAAIS,GAAOZ,GAlCgB,8BAqC7B,OAAOG,EAGT,GAAIoB,EAAKqnB,sBAAuB,CAC9B,IAAMkF,EAAetsB,EAAM0qB,UACrBrc,EAAOwc,EAAe9qB,EAAKf,IAAI,QAASgB,GACxCusB,EAAgBvsB,EAAM0qB,UAC5B1qB,EAAM0qB,UAAY4B,EAClB,IAAMzV,EAAQgU,EAAe9qB,EAAKf,IAAI,SAAUgB,GAC1CwsB,EAAiBxsB,EAAM0qB,UAE7B,OAAQtqB,EAAKiS,UACX,IAAK,KAEH,GADArS,EAAM0qB,UAAY6B,MAAoBle,GAAQme,IACzCxsB,EAAM0qB,UAAW,OACtB,OAAOrc,GAAQwI,EAEjB,IAAK,KAEH,GADA7W,EAAM0qB,UAAY6B,KAAmBle,GAAQme,IACxCxsB,EAAM0qB,UAAW,OACtB,OAAOrc,GAAQwI,GAIrB,GAAI9W,EAAKsnB,qBAAsB,CAC7B,IAAMhZ,EAAOwc,EAAe9qB,EAAKf,IAAI,QAASgB,GAC9C,IAAKA,EAAM0qB,UAAW,OACtB,IAAM7T,EAAQgU,EAAe9qB,EAAKf,IAAI,SAAUgB,GAChD,IAAKA,EAAM0qB,UAAW,OAEtB,OAAQtqB,EAAKiS,UACX,IAAK,IACH,OAAOhE,EAAOwI,EAEhB,IAAK,IACH,OAAOxI,EAAOwI,EAEhB,IAAK,IACH,OAAOxI,EAAOwI,EAEhB,IAAK,IACH,OAAOxI,EAAOwI,EAEhB,IAAK,IACH,OAAOxI,EAAOwI,EAEhB,IAAK,KACH,OAAO4V,KAAKC,IAAIre,EAAMwI,GAExB,IAAK,IACH,OAAOxI,EAAOwI,EAEhB,IAAK,IACH,OAAOxI,EAAOwI,EAEhB,IAAK,KACH,OAAOxI,GAAQwI,EAEjB,IAAK,KACH,OAAOxI,GAAQwI,EAEjB,IAAK,KACH,OAAOxI,GAAQwI,EAEjB,IAAK,KACH,OAAOxI,GAAQwI,EAEjB,IAAK,MACH,OAAOxI,IAASwI,EAElB,IAAK,MACH,OAAOxI,IAASwI,EAElB,IAAK,IACH,OAAOxI,EAAOwI,EAEhB,IAAK,IACH,OAAOxI,EAAOwI,EAEhB,IAAK,IACH,OAAOxI,EAAOwI,EAEhB,IAAK,KACH,OAAOxI,GAAQwI,EAEjB,IAAK,KACH,OAAOxI,GAAQwI,EAEjB,IAAK,MACH,OAAOxI,IAASwI,GAItB,GAAI9W,EAAK+iB,mBAAoB,CAC3B,IACI9c,EACA2mB,EAFErc,EAASvQ,EAAKf,IAAI,UAQxB,GAJIsR,EAAO5I,iBAAmB3H,EAAKS,MAAMO,WAAWuP,EAAOlQ,KAAKC,MAAM,IAAS0qB,EAAcnpB,QAAQ0O,EAAOlQ,KAAKC,OAAS,IACxHssB,EAAOC,EAAOxsB,EAAKkQ,OAAOjQ,OAGxBiQ,EAAOtC,qBAAsB,CAC/B,IAAMoC,EAASE,EAAOtR,IAAI,UACpBqR,EAAWC,EAAOtR,IAAI,YAO5B,GALIoR,EAAO1I,gBAAkB2I,EAAS3I,gBAAkBqjB,EAAcnpB,QAAQwO,EAAOhQ,KAAKC,OAAS,GAAK2qB,EAAgBppB,QAAQyO,EAASjQ,KAAKC,MAAQ,IAEpJssB,GADA3mB,EAAU4mB,EAAOxc,EAAOhQ,KAAKC,OACdgQ,EAASjQ,KAAKC,OAG3B+P,EAAOD,aAAeE,EAAS3I,eAAgB,CACjD,IAAMD,SAAc2I,EAAOhQ,KAAK5B,MAEnB,WAATiJ,GAA8B,WAATA,IAEvBklB,GADA3mB,EAAUoK,EAAOhQ,KAAK5B,OACP6R,EAASjQ,KAAKC,QAKnC,GAAIssB,EAAM,CACR,IAAMtX,EAAOtV,EAAKf,IAAI,aAAa2H,KAAI,SAAAolB,GAAG,OAAIlB,EAAekB,EAAK/rB,MAClE,IAAKA,EAAM0qB,UAAW,OACtB,OAAOiC,EAAKvgB,MAAMpG,EAASqP,IAI/ByV,EAAM/qB,EAAMC,GAvUE6sB,CAAU9sB,EAAMC,GAO5B,OALIA,EAAM0qB,YACRQ,EAAKD,UAAW,EAChBC,EAAK1sB,MAAQmN,GAGRA,EAmUX,SAAS6f,EAAezrB,EAAM0rB,EAAQzrB,GAAoB,MAAb8sB,EAAa,wDACpDC,EAAM,GACNtqB,EAAI,EACF6nB,EAAQvqB,EAAKf,IAAI,eAHiC,IAKrCysB,GALqC,IAKxD,2BAA2B,KAAhB1U,EAAgB,QACzB,IAAK/W,EAAM0qB,UAAW,MACtBqC,GAAOD,EAAM/V,EAAKvY,MAAMsuB,IAAM/V,EAAKvY,MAAMwuB,OACzC,IAAMC,EAAO3C,EAAM7nB,KACfwqB,IAAMF,GAAOG,OAAOrC,EAAeoC,EAAMjtB,MATS,8BAYxD,GAAKA,EAAM0qB,UACX,OAAOqC,K,mDCjYT1uB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQ4uB,cAgBR,WACE,IACI/tB,EADEgB,EAAOiB,KAAKjB,KAGlB,GAAIiB,KAAK2M,qBACP5O,EAAMgB,EAAKiQ,aACN,KAAIhP,KAAK8V,eAAgB9V,KAAK4V,WAGnC,MAAM,IAAIjB,eAAe,QAFzB5W,EAAMgB,EAAKhB,IAKRgB,EAAK8W,UACJxY,EAAEgJ,aAAatI,KAAMA,EAAMV,EAAE0uB,cAAchuB,EAAIiB,OAGrD,OAAOjB,GA/BTb,EAAQ2Z,YAkCR,WACE,IAAMzB,EAAOpV,KAAKrC,IAAI,QAChBquB,EAAW5W,EAAKrW,KAEtB,GAAIwC,MAAMC,QAAQ4T,GAChB,MAAM,IAAIlL,MAAM,iDAGlB,IAAK8hB,EACH,MAAM,IAAI9hB,MAAM,qCAGlB,GAAIkL,EAAK9R,mBACP,OAAO0oB,EAGT,IAEIjuB,EACA0G,EAHEqC,EAAa,GACfmlB,EAAa,OAIb7W,EAAK1T,eACP+C,EAAU,OACV1G,EAAM,EACN+I,EAAWtH,KAAK4V,EAAKrW,QAErBktB,GAAc,UAEVjsB,KAAKZ,cACPrB,EAAM,WACN+I,EAAWtH,KAAKnC,EAAEorB,gBAAgBrT,EAAKrW,SAEvChB,EAAM,aACN+I,EAAWtH,KAAKnC,EAAEkqB,oBAAoBnS,EAAKrW,SAI/CiB,KAAKjB,KAAKqW,KAAO/X,EAAE8qB,eAAerhB,GAClC,IAAM7H,EAAae,KAAKrC,IAAIsuB,GAE5B,OADA7W,EAAK2G,MAAM9c,EAAYwF,EAAUxF,EAAWF,KAAK0F,GAAWxF,EAAWF,KAAM0F,EAAS1G,GAC/EiC,KAAKjB,MAzEd7B,EAAQgvB,wBA4ER,WACE,IAAKlsB,KAAKX,4BAA6B,OACvCW,KAAK2oB,6BA7EPzrB,EAAQivB,0BAgFR,WACE,IAAKnsB,KAAKX,8BAAgCW,KAAK2G,yBAA2B3G,KAAK0G,wBAC7E,MAAM1G,KAAKosB,oBAAoB,kDAGjCC,EAAyBrsB,OApF3B9C,EAAQyrB,0BAuFR,WAGQ,6DAAJ,GAAI,IAFN2D,wBAEM,aADNC,qBACM,SACN,IAAKvsB,KAAKX,4BACR,MAAMW,KAAKosB,oBAAoB,+DAGjC,IAAMI,EAAcH,EAAyBrsB,KAAMusB,EAAeD,GAIlE,GAHAtsB,KAAK6W,cACL7W,KAAKjB,KAAKqH,KAAO,qBAEbmmB,EAAe,CACjB,IAAME,EAAeD,EAAc,KAAOxsB,KAAKf,WAAWE,MAAM+C,sBAAsB,gBAElFuqB,GACFzsB,KAAKf,WAAWE,MAAMK,KAAK,CACzB0G,GAAIumB,EACJvf,KAAM7P,EAAEqvB,iBAAiB,MAI7B1sB,KAAKrC,IAAI,QAAQwZ,iBAAiB,OAAQ9Z,EAAEkqB,oBAAoBlqB,EAAEwW,eAAe7T,KAAKiT,IAAIkB,UAAU,iBAAkB,CAAC9W,EAAEsvB,iBAAkBF,EAAepvB,EAAEgD,WAAWosB,EAAaztB,MAAQ3B,EAAEgD,WAAWmsB,OACzMxsB,KAAK2C,YAAYtF,EAAEwW,eAAexW,EAAEyW,kBAAiB,EAAI8Y,EAAoBxvB,SAAS4C,MAAM,IAASA,KAAKjB,KAAM1B,EAAEgD,WAAW,SAAU,CAACosB,EAAepvB,EAAEgD,WAAWosB,EAAaztB,MAAQ3B,EAAEsvB,sBA5G/L,IAIgCrvB,EAJ5BD,EAQJ,SAAiCC,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEF,QAASE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAMG,IAAIL,GAAQ,IAAIM,EAAS,GAAQC,EAAwBb,OAAOC,gBAAkBD,OAAOc,yBAA0B,IAAK,IAAIC,KAAOT,EAAO,GAAIN,OAAOgB,UAAUC,eAAeC,KAAKZ,EAAKS,GAAM,CAAE,IAAII,EAAON,EAAwBb,OAAOc,yBAAyBR,EAAKS,GAAO,KAAUI,IAASA,EAAKR,KAAOQ,EAAKC,KAAQpB,OAAOC,eAAeW,EAAQG,EAAKI,GAAgBP,EAAOG,GAAOT,EAAIS,GAAYH,EAAOR,QAAUE,EAASE,GAASA,EAAMY,IAAId,EAAKM,GAAW,OAAOA,EARttBS,CAAwBC,EAAQ,KAEpCsuB,GAE4BtvB,EAFiBgB,EAAQ,OAEJhB,EAAIC,WAAaD,EAAM,CAAEF,QAASE,GAEvF,SAASG,IAA6B,GAAuB,oBAAZc,QAAwB,OAAO,KAAM,IAAIf,EAAQ,IAAIe,QAAqE,OAA1Dd,EAA2B,WAAc,OAAOD,GAAiBA,EA0GlL,SAAS6uB,EAAyBQ,GAAwD,IAAhDN,EAAgD,wDAAzBD,IAAyB,yDAClFQ,EAAYD,EAAOzU,YAAW,SAAAC,GAClC,OAAOA,EAAEjZ,eAAiBiZ,EAAEhZ,6BAA+BgZ,EAAE3X,aAAe2X,EAAE0U,gBAAgB,CAC5FC,QAAQ,OAGNC,EAAuE,iBAAzC,MAAbH,OAAoB,EAASA,EAAU/tB,KAAK6B,MAEnE,GAAIksB,EAAUC,kBACZ,MAAMF,EAAOT,oBAAoB,mDATqD,IA4GpFI,EA5GoF,EAkBpFU,EAAoBL,GALtBM,EAbsF,EAatFA,UACAC,EAdsF,EActFA,eACAC,EAfsF,EAetFA,eACAC,EAhBsF,EAgBtFA,WACAC,EAjBsF,EAiBtFA,WAGF,GAAIN,GAAiBM,EAAWlsB,OAAS,EAAG,CAC1C,IAAKirB,EACH,MAAMiB,EAAW,GAAGnB,oBAAoB,kDAG1C,IAAMoB,EAAgB,GACtBV,EAAUlrB,SAAS,CACjBwP,SADiB,SACRxK,GACHA,EAAMvH,6BACVuH,EAAMyW,QAGRoQ,cANiB,SAMH7mB,GACZA,EAAMyW,QAGRwG,eAViB,SAUFjd,GACRA,EAAMjJ,IAAI,UAAUkV,WACzB2a,EAAchuB,KAAKoH,MAIvB,IAAM8mB,EAAeC,EAAgBb,GACrCU,EAAcI,SAAQ,SAAAC,GACpB,IAAM5e,EAAS5R,EAAEgD,WAAWqtB,GAC5Bze,EAAOzB,IAAMqgB,EAAU9uB,KAAKkQ,OAAOzB,IACnCqgB,EAAUlwB,IAAI,UAAUgF,YAAYsM,MAIxC,GAAIme,EAAe/rB,OAAS,EAAG,CAC7B,IAAMysB,EAAmBpuB,EAAWotB,EAAW,aAAa,kBAAMzvB,EAAEgD,WAAW,gBAC/E+sB,EAAeQ,SAAQ,SAAAG,GACrB,IAAMC,EAAU3wB,EAAEgD,WAAWytB,GAC7BE,EAAQxgB,IAAMugB,EAAehvB,KAAKyO,IAClCugB,EAAeprB,YAAYqrB,MAI/B,GAAIX,EAAehsB,OAAS,EAAG,CAC7B,IAAM4sB,EAAmBvuB,EAAWotB,EAAW,aAAa,kBAAMzvB,EAAE6wB,aAAa7wB,EAAEgD,WAAW,OAAQhD,EAAEgD,WAAW,cACnHgtB,EAAeO,SAAQ,SAAAO,GACrB,IAAMC,EAAY/wB,EAAEgD,WAAW4tB,GAC/BG,EAAU5gB,IAAM2gB,EAAYpvB,KAAKyO,IACjC2gB,EAAYxrB,YAAYyrB,MAI5B,GAAId,EAAWjsB,OAAS,EAAG,CACzB,IAAKirB,EACH,MAAMgB,EAAW,GAAGlB,oBAAoB,4CAG1C,IAAMiC,EAAiBf,EAAWgB,QAAO,SAACC,EAAKC,GAAN,OAAoBD,EAAIxoB,OAAO0oB,EAAyBD,MAAa,IAC9GH,EAAeT,SAAQ,SAAAY,GACrB,IAAMzwB,EAAMywB,EAAUzvB,KAAK8W,SAAW,GAAK2Y,EAAU7wB,IAAI,YAAYoB,KAAKC,KACpE0vB,EAAeF,EAAUvvB,WAAW0vB,uBAAuB,CAC/D3hB,KAAMwhB,EAAUzvB,OAEZ6vB,EAASJ,EAAUvvB,WAAWwiB,iBAAiB,CACnDxS,OAAQuf,EAAUzvB,OAEd2uB,EAAemB,EAAoB/B,EAAW4B,EAAc3wB,GAC5DiW,EAAO,GAMb,GAJIwa,EAAUzvB,KAAK8W,UACjB7B,EAAKxU,KAAKgvB,EAAU7wB,IAAI,YAAYoB,MAGlC2vB,EAAc,CAChB,IAAMvxB,EAAQqxB,EAAUvvB,WAAWF,KAAKyW,MACxCxB,EAAKxU,KAAKrC,GAGZ,IAAMe,EAAOb,EAAEwW,eAAexW,EAAEgD,WAAWqtB,GAAe1Z,GAEtD4a,GACFJ,EAAUvvB,WAAWkY,iBAAiB,YAAa9Z,EAAEsvB,kBACrD6B,EAAU7rB,YAAYtF,EAAEyW,iBAAiB5V,EAAMb,EAAEgD,WAAW,UAC5D8sB,EAAU3tB,KAAKgvB,EAAUvvB,WAAWtB,IAAI,iBAC/B+wB,EACTF,EAAUvvB,WAAW0D,YAAYzE,GAEjCswB,EAAU7rB,YAAYzE,MAoB5B,OAbIivB,EAAU9rB,OAAS,GAAKkrB,KAC1BC,EAAcsC,EAAehC,EAAWG,KAEnCV,GAAiBU,GAAiB8B,EAAcjC,MACnDK,EAAUS,SAAQ,SAAAoB,GAChB,IAAMC,EAAUD,EAAUE,QAAU7xB,EAAE8xB,cAAc3C,GAAenvB,EAAEgD,WAAWmsB,GAChFyC,EAAQzhB,IAAMwhB,EAAUjwB,KAAKyO,IAC7BwhB,EAAUrsB,YAAYssB,MAEpB1C,IAAeC,EAAc,QAI9BA,EAGT,SAASiC,EAAyBD,GAChC,GAAIA,EAAUvvB,WAAW0vB,0BAAmE,MAAvCH,EAAUvvB,WAAWF,KAAKiS,SAAkB,CAC/F,IAAMoe,EAAiBZ,EAAUvvB,WAC3BowB,EAAKD,EAAerwB,KAAKiS,SAAS0B,MAAM,GAAI,GAC5CvV,EAAQiyB,EAAerwB,KAAKyW,MAGlC,GAFA4Z,EAAerwB,KAAKiS,SAAW,IAE3Bwd,EAAUzvB,KAAK8W,SAAU,CAC3B,IAAMyZ,EAAMd,EAAUrvB,MAAMopB,8BAA8B,OAC1D6G,EAAezxB,IAAI,QAAQgF,YAAYtF,EAAEyW,iBAAiB0a,EAAUzvB,KAAKgQ,OAAQ1R,EAAEqrB,qBAAqB,IAAK4G,EAAKd,EAAUzvB,KAAKiQ,WAAW,IAC5IogB,EAAezxB,IAAI,SAASgF,YAAYtF,EAAEkyB,iBAAiBF,EAAIhyB,EAAEyW,iBAAiB0a,EAAUzvB,KAAKgQ,OAAQ1R,EAAEgD,WAAWivB,EAAItwB,OAAO,GAAO7B,SAExIiyB,EAAezxB,IAAI,QAAQgF,YAAYtF,EAAEyW,iBAAiB0a,EAAUzvB,KAAKgQ,OAAQyf,EAAUzvB,KAAKiQ,WAChGogB,EAAezxB,IAAI,SAASgF,YAAYtF,EAAEkyB,iBAAiBF,EAAIhyB,EAAEyW,iBAAiB0a,EAAUzvB,KAAKgQ,OAAQ1R,EAAEgD,WAAWmuB,EAAUzvB,KAAKiQ,SAAShQ,OAAQ7B,IAGxJ,MAAO,CAACiyB,EAAezxB,IAAI,QAASyxB,EAAezxB,IAAI,SAASA,IAAI,SAC/D,GAAI6wB,EAAUvvB,WAAWuwB,qBAAsB,CACpD,IAAMC,EAAajB,EAAUvvB,WACvBqwB,EAAMd,EAAUrvB,MAAMopB,8BAA8B,OACpDmH,EAAclB,EAAUzvB,KAAK8W,SAAW2Y,EAAUrvB,MAAMopB,8BAA8B,QAAU,KAChGrjB,EAAQ,CAAC7H,EAAEqrB,qBAAqB,IAAK4G,EAAKjyB,EAAEyW,iBAAiB0a,EAAUzvB,KAAKgQ,OAAQ2gB,EAAcryB,EAAEqrB,qBAAqB,IAAKgH,EAAalB,EAAUzvB,KAAKiQ,UAAYwf,EAAUzvB,KAAKiQ,SAAUwf,EAAUzvB,KAAK8W,WAAYxY,EAAEqrB,qBAAqB,IAAKrrB,EAAEyW,iBAAiB0a,EAAUzvB,KAAKgQ,OAAQ2gB,EAAcryB,EAAEgD,WAAWqvB,EAAY1wB,MAAQwvB,EAAUzvB,KAAKiQ,SAAUwf,EAAUzvB,KAAK8W,UAAWxY,EAAEkyB,iBAAiB,IAAKlyB,EAAEgD,WAAWivB,EAAItwB,MAAO3B,EAAE4W,eAAe,MASzc,OAPKua,EAAUvvB,WAAWF,KAAK0rB,QAC7BvlB,EAAM1F,KAAKnC,EAAEgD,WAAWivB,EAAItwB,OAG9BywB,EAAW9sB,YAAYtF,EAAEsyB,mBAAmBzqB,IAGrC,CAFMuqB,EAAW9xB,IAAI,uBACd8xB,EAAW9xB,IAAI,uBAI/B,MAAO,CAAC6wB,GAGV,SAASO,EAAcjC,GACrB,OAAOA,EAAU8C,mBAAqB9C,EAAU7tB,WAAWA,WAAWF,KAAKoW,WAG7E,SAAS2Z,EAAehC,EAAWG,GACjC,OAAOvtB,EAAWotB,EAAW,QAAQ,SAAAN,GACnC,IAAKS,IAAkB8B,EAAcjC,GAAY,OAAOzvB,EAAEsvB,iBAC1D,IAAMkD,EAAS,IAAInT,QACnBoQ,EAAUlrB,SAAS,CACjBwP,SADiB,SACRxK,GACHA,EAAMvH,6BACVuH,EAAMyW,QAGRoQ,cANiB,SAMH7mB,GACZA,EAAMyW,QAGRwG,eAViB,SAUFjd,GACRA,EAAMjJ,IAAI,UAAUkV,YACrBgd,EAAOnyB,IAAIkJ,EAAM7H,QACrB8wB,EAAO/S,IAAIlW,EAAM7H,MACjB6H,EAAMqf,oBAAoB,CAACrf,EAAM7H,KAAM1B,EAAEqrB,qBAAqB,IAAKrrB,EAAEgD,WAAWmsB,GAAcnvB,EAAEgD,WAAW,mBAOnH,SAASstB,EAAgBb,GACvB,OAAOptB,EAAWotB,EAAW,aAAa,WACxC,IAAMgD,EAAchD,EAAU3tB,MAAM+C,sBAAsB,QAC1D,OAAO7E,EAAE6qB,wBAAwB,CAAC7qB,EAAE0yB,YAAYD,IAAezyB,EAAEwW,eAAexW,EAAE2yB,QAAS,CAAC3yB,EAAE4yB,cAAc5yB,EAAEgD,WAAWyvB,EAAY9wB,aAIzI,SAAS6vB,EAAoB/B,EAAW4B,EAAcwB,GAEpD,OAAOxwB,EAAWotB,EAAD,oBADN4B,EAAe,MAAQ,MACjB,YAA+BwB,GAAY,KAAM,WAChE,IACIC,EADEC,EAAW,GAGjB,GAAIF,EACFC,EAAS9yB,EAAEyW,iBAAiBzW,EAAE2yB,QAAS3yB,EAAEgD,WAAW6vB,QAC/C,CACL,IAAM5a,EAASwX,EAAU3tB,MAAM+C,sBAAsB,QACrDkuB,EAASlc,QAAQoB,GACjB6a,EAAS9yB,EAAEyW,iBAAiBzW,EAAE2yB,QAAS3yB,EAAEgD,WAAWiV,EAAOtW,OAAO,GAGpE,GAAI0vB,EAAc,CAChB,IAAM2B,EAAavD,EAAU3tB,MAAM+C,sBAAsB,SACzDkuB,EAAS5wB,KAAK6wB,GACdF,EAAS9yB,EAAEqrB,qBAAqB,IAAKyH,EAAQ9yB,EAAEgD,WAAWgwB,EAAWrxB,OAGvE,OAAO3B,EAAE6qB,wBAAwBkI,EAAUD,MAI/C,SAASzwB,EAAWotB,EAAW/uB,EAAKmP,GAClC,IAAMojB,EAAW,WAAavyB,EAC1BwY,EAAOuW,EAAU5V,QAAQoZ,GAE7B,IAAK/Z,EAAM,CACT,IAAMrQ,EAAK4mB,EAAU3tB,MAAM+C,sBAAsBnE,GACjDwY,EAAOrQ,EAAGlH,KACV8tB,EAAU1V,QAAQkZ,EAAU/Z,GAC5BuW,EAAU3tB,MAAMK,KAAK,CACnB0G,GAAIA,EACJgH,KAAMA,EAAKqJ,KAIf,OAAOA,EAGT,SAAS2W,EAAoBL,GAC3B,IAAMM,EAAY,GACZC,EAAiB,GACjBC,EAAiB,GACjBC,EAAa,GACbC,EAAa,GAqDnB,OApDAV,EAAOjrB,SAAS,CACd6rB,cADc,SACA7mB,GACZA,EAAMyW,QAGRjM,SALc,SAKLxK,GACHA,EAAMvH,6BACVuH,EAAMyW,QAGRkT,eAVc,SAUC3pB,GACbumB,EAAU3tB,KAAKoH,IAGjB4pB,cAdc,SAcA5pB,GACY,SAApBA,EAAM7H,KAAKC,OAEV4H,EAAM3H,WAAWC,sBAAsB,CAC1C6P,OAAQnI,EAAM7H,QACT6H,EAAM3H,WAAWwxB,oBAAoB,CAC1CzxB,KAAM4H,EAAM7H,SAKdouB,EAAU3tB,KAAKoH,IAGjBid,eA5Bc,SA4BCjd,GACTA,EAAMjJ,IAAI,UAAUkV,WAAW0a,EAAW/tB,KAAKoH,IAGrD8pB,iBAhCc,SAgCG9pB,GACXA,EAAMjJ,IAAI,UAAUkV,WAAWya,EAAW9tB,KAAKoH,IAGrDnI,qBApCc,SAoCOmI,GACK,cAApBA,EAAM7H,KAAKC,MACfouB,EAAe5tB,KAAKoH,IAGtB+pB,aAzCc,SAyCD/pB,GACNA,EAAMjJ,IAAI,QAAQ0I,aAAa,CAClCrH,KAAM,SAEH4H,EAAMjJ,IAAI,YAAY0I,aAAa,CACtCrH,KAAM,YAERquB,EAAe7tB,KAAKoH,MAIjB,CACLumB,YACAC,iBACAC,iBACAC,aACAC,gB,6CCvaJvwB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQ+Y,eA2BR,SAAwB2a,EAASC,GAC/B,OAAOxzB,EAAE4Y,eAAejW,KAAKjB,KAAM6xB,EAASC,IA3B9C3zB,EAAQQ,IAAMA,EACdR,EAAQ6V,SAuCR,WACE,OAAO/S,KAAKb,MAAM4T,SAAS/S,KAAKjB,OAvClC7B,EAAQ4zB,KA6CR,SAAc/yB,GACZ,OAAQiC,KAAKtC,IAAIK,IA7CnBb,EAAQ6zB,OAgDR,SAAgBhzB,EAAKZ,GACnB,OAAO6C,KAAKjB,KAAKhB,KAASZ,GAhD5BD,EAAQkqB,WAmDR,SAAoBhhB,GAClB,OAAO/I,EAAE2zB,OAAOhxB,KAAKoG,KAAMA,IAnD7BlJ,EAAQmqB,uCAsDR,WACE,OAAqB,SAAbrnB,KAAKjC,KAA+B,SAAbiC,KAAKjC,MAAmBiC,KAAKf,WAAWmE,SAtDzElG,EAAQoqB,qCAyDR,SAA8Cb,GAC5C,GAAiB,SAAbzmB,KAAKjC,MAAmBiC,KAAKf,WAAWI,4BAC1C,OAAO,EAGT,GAAIW,KAAKoN,eACP,OAAO/P,EAAEiG,iBAAiBmjB,GACrB,GAAIzmB,KAAKsD,mBACd,OAAOjG,EAAE+P,aAAaqZ,GAGxB,OAAO,GAnETvpB,EAAQ+zB,mBAsER,SAA4BC,GAC1B,IAAIxyB,EAAOsB,KACP6e,GAAQ,EAEZ,EAAG,CACD,IAAMpd,EAAY/C,EAAK+C,UAEvB,GAAI/C,EAAKU,eAAiByf,EACxB,QAASqS,EAKX,GAFArS,GAAQ,EAEJtd,MAAMC,QAAQC,IAAc/C,EAAKX,MAAQ0D,EAAUJ,OAAS,EAC9D,OAAO,SAED3C,EAAOA,EAAKO,cAAgBP,EAAKgC,aAE3C,OAAO,GAvFTxD,EAAQi0B,mBA0FR,WACE,OAAInxB,KAAKf,WAAW8H,uBAAwB1J,EAAEiG,iBAAiBtD,KAAKyB,YAG3DpE,EAAE+zB,wBAAwBtZ,SAAS9X,KAAKjC,MA7FnDb,EAAQm0B,iBAiGR,SAA0BC,EAAcC,GACtC,IAAKvxB,KAAKmN,yBAA0B,OAAO,EAC3C,IAAM1N,EAAUO,KAAKb,MAAMO,WAAWM,KAAKjB,KAAKC,MAChD,IAAKS,GAA4B,WAAjBA,EAAQmB,KAAmB,OAAO,EAClD,IAAMlC,EAAOe,EAAQf,KACfY,EAASZ,EAAKO,WACpB,IAAKK,EAAOsO,sBAAuB,OAAO,EAE1C,GAAItO,EAAOP,KAAK2P,OAAOvR,QAAUm0B,EAG/B,OAAO,EAFP,IAAKC,EAAY,OAAO,EAK1B,GAAI7yB,EAAK8yB,4BAA6C,YAAfD,EACrC,OAAO,EAGT,GAAI7yB,EAAK+yB,8BAA+C,MAAfF,EACvC,OAAO,EAGT,GAAI7yB,EAAKqP,qBAAuBrP,EAAKK,KAAK2yB,SAAS1yB,OAASuyB,EAC1D,OAAO,EAGT,OAAO,GA1HTr0B,EAAQy0B,UA6HR,WACE,IAAM5yB,EAAOiB,KAAKjB,KAElB,GAAIA,EAAKwrB,IAAK,CACZ,IAAM3O,EAAO5b,KAAKiT,IAAI2e,UACtB,GAAIhW,EAAM,OAAOA,EAAKlJ,MAAM3T,EAAKgoB,MAAOhoB,EAAKwrB,KAG/C,MAAO,IApITrtB,EAAQ20B,wBAuIR,SAAiCtM,GAC/B,MAAwD,UAAjDvlB,KAAKqlB,gCAAgCE,IAvI9CroB,EAAQmoB,gCAgMR,SAAyCE,GACvC,IAAMuM,EAAa,CACjB9xB,KAAM+xB,EAAiB/xB,MACvBulB,OAAQwM,EAAiBxM,IAG3B,GAAIuM,EAAWvM,OAAOxmB,OAAS+yB,EAAW9xB,KAAKjB,KAC7C,OAAOiB,KAAKgyB,kDAAkDF,EAAWvM,QAG3E,IAMI0M,EANEjvB,EAAQ,CACZuiB,OAAQA,EAAOvG,cACfhf,KAAMA,KAAKgf,eAEb,GAAIhc,EAAMuiB,OAAOhlB,QAAQP,OAAS,EAAG,MAAO,QAC5C,GAAIgD,EAAMhD,KAAKO,QAAQglB,IAAW,EAAG,MAAO,SAE5C,IAAM2M,EAAc,CAClB3M,OAAQ,EACRvlB,KAAM,GAGR,MAAQiyB,GAAcC,EAAYlyB,KAAOgD,EAAMhD,KAAKqB,QAAQ,CAC1D,IAAM3C,EAAOsE,EAAMhD,KAAKkyB,EAAYlyB,MACpCkyB,EAAY3M,OAASviB,EAAMuiB,OAAOhlB,QAAQ7B,GAEtCwzB,EAAY3M,QAAU,EACxB0M,EAAavzB,EAEbwzB,EAAYlyB,OAIhB,IAAKiyB,EACH,MAAM,IAAI/nB,MAAM,6FAGlB,GAAIioB,EAA2BnvB,EAAMhD,KAAMkyB,EAAYlyB,KAAO,IAAMmyB,EAA2BnvB,EAAMuiB,OAAQ2M,EAAY3M,OAAS,GAChI,MAAO,UAGT,IAAM6M,EAAa,CACjBpyB,KAAMgD,EAAMhD,KAAKkyB,EAAYlyB,KAAO,GACpCulB,OAAQviB,EAAMuiB,OAAO2M,EAAY3M,OAAS,IAG5C,GAAI6M,EAAW7M,OAAO9gB,SAAW2tB,EAAWpyB,KAAKyE,SAAW2tB,EAAW7M,OAAO9jB,YAAc2wB,EAAWpyB,KAAKyB,UAC1G,OAAO2wB,EAAW7M,OAAOxnB,IAAMq0B,EAAWpyB,KAAKjC,IAAM,SAAW,QAGlE,IAAMoC,EAAO9C,EAAE8b,aAAa8Y,EAAW7rB,MACjCisB,EAAc,CAClBryB,KAAMG,EAAKI,QAAQ6xB,EAAWpyB,KAAKa,WACnC0kB,OAAQplB,EAAKI,QAAQ6xB,EAAW7M,OAAO1kB,YAEzC,OAAOwxB,EAAY9M,OAAS8M,EAAYryB,KAAO,SAAW,SAtP5D9C,EAAQ80B,kDA2PR,SAA2DzM,GACzD,IAAKA,EAAO7e,yBAA2B6e,EAAOtmB,WAAWsH,sBACvD,MAAO,UAGT,IAAM9G,EAAU8lB,EAAOpmB,MAAMO,WAAW6lB,EAAOxmB,KAAKmH,GAAGlH,MACvD,IAAKS,EAAQwQ,WAAY,MAAO,SAChC,IACIqiB,EAR6D,EAO3D9Z,EAAiB/Y,EAAQ+Y,eAPkC,IAU9CA,GAV8C,IAUjE,2BAAmC,KAAxB9Z,EAAwB,QAEjC,MAD0BA,EAAKgf,MAAK,SAAAhf,GAAI,OAAIA,EAAKK,OAASwmB,EAAOxmB,QACjE,CAEA,GAAiB,WAAbL,EAAKX,MAAqBW,EAAKO,WAAWwiB,mBAC5C,MAAO,UAGT,IAAI8Q,EAA2B70B,IAAIgB,EAAKK,MAAxC,CACAwzB,EAA2BzV,IAAIpe,EAAKK,MAEpC,IAAMqmB,EAASplB,KAAKqlB,gCAAgC3mB,GAIpD,GAFA6zB,EAA2B5Y,OAAOjb,EAAKK,MAEnCuzB,GAAaA,IAAclN,EAC7B,MAAO,UAEPkN,EAAYlN,KA5BiD,8BAgCjE,OAAOkN,GA1RTp1B,EAAQsnB,QA6RR,SAAiBgO,EAAW5I,GAC1B,OAAO5pB,KAAKyyB,SAASD,EAAW5I,IAAa5pB,MA7R/C9C,EAAQu1B,SAgSR,SAAkBD,EAAW5I,GAC3B,GAAIA,GAAYA,EAASrpB,QAAQP,OAAS,EAAG,OAI7C,IAHA4pB,EAAWA,GAAY,IACdpqB,KAAKQ,MAEVA,KAAKqC,wBACP,GAAIrC,KAAKrC,IAAI,MAAM0I,eACjB,OAAOrG,KAAKrC,IAAI,QAAQ6mB,QAAQgO,EAAW5I,QAExC,GAAI5pB,KAAKmN,yBAA0B,CACxC,IAAM1N,EAAUO,KAAKb,MAAMO,WAAWM,KAAKjB,KAAKC,MAChD,IAAKS,EAAS,OACd,IAAKA,EAAQkC,SAAU,OACvB,GAAqB,WAAjBlC,EAAQmB,KAAmB,OAE/B,GAAInB,EAAQf,OAASsB,KAAM,CACzB,IAAM0yB,EAAMjzB,EAAQf,KAAK8lB,QAAQgO,EAAW5I,GAC5C,GAAI5pB,KAAK0d,MAAK,SAAApe,GAAM,OAAIA,EAAOP,OAAS2zB,EAAI3zB,QAAO,OACnD,OAAO2zB,OAEJ,IAAI1yB,KAAK2yB,uBACd,OAAO3yB,KAAKrC,IAAI,cAAc6mB,QAAQgO,EAAW5I,GAC5C,GAAI4I,GAAaxyB,KAAK2M,qBAAsB,CACjD,IAAMimB,EAAY5yB,KAAK8rB,gBACvB,IAAKzuB,EAAEyR,UAAU8jB,GAAY,OAC7B,IAAMC,EAAaD,EAAUz1B,MACvBooB,EAASvlB,KAAKrC,IAAI,UAAU6mB,QAAQgO,EAAW5I,GAErD,GAAIrE,EAAOtX,qBAAsB,CAC/B,IAD+B,EACzB6c,EAAQvF,EAAO5nB,IAAI,cADM,IAGZmtB,GAHY,IAG/B,2BAA0B,KAAfnV,EAAe,QACxB,GAAKA,EAAKG,aAAV,CACA,IAAM/X,EAAM4X,EAAKhY,IAAI,OACjBm1B,EAAQnd,EAAKmb,KAAK,aAAe/yB,EAAIsI,aAAa,CACpDrH,KAAM6zB,IAKR,GAHAC,EAAQA,GAAS/0B,EAAI+Q,UAAU,CAC7B3R,MAAO01B,IAEE,OAAOld,EAAKhY,IAAI,SAAS6mB,QAAQgO,EAAW5I,KAZ1B,oCAc1B,GAAIrE,EAAO3R,sBAAwBmf,OAAOF,GAAa,CAC5D,IACMnd,EADQ6P,EAAO5nB,IAAI,YACNk1B,GACnB,GAAInd,EAAM,OAAOA,EAAK8O,QAAQgO,EAAW5I,OA5U/C1sB,EAAQ81B,qBAiVR,WACE,GAAIhzB,KAAKqG,eAAgB,CACvB,IAAM5G,EAAUO,KAAKb,MAAMO,WAAWM,KAAKjB,KAAKC,MAChD,QAAKS,GACEA,EAAQkC,SAGjB,GAAI3B,KAAK8O,YACP,OAAI9O,KAAKizB,qBAILjzB,KAAKoW,qBACApW,KAAKrC,IAAI,eAAeu1B,OAAM,SAAA9jB,GAAU,OAAIA,EAAW4jB,2BAMlE,GAAIhzB,KAAK+V,oBACP,MAAkC,SAA9B/V,KAAKrC,IAAI,YAAYoB,MAIlBiB,KAAKrC,IAAI,YAAYq1B,uBAG9B,GAAIhzB,KAAKgmB,qBACP,OAAOhmB,KAAKrC,IAAI,QAAQq1B,wBAA0BhzB,KAAKrC,IAAI,SAASq1B,uBAGtE,OAAO,GA/WT91B,EAAQi2B,eAkXR,WAwBE,SAvBcnzB,KAAKU,YAAcV,KAAOA,KAAKf,YAClBye,MAAK,SAAAhf,GAC9B,GAAIA,EAAKgC,UAAU,CACjB0yB,WAAY,WACV,OAAO,EACX,GAAI10B,EAAKwW,UAAW,OAAO,EAC3B,IAAKxW,EAAKgC,cAAgBhC,EAAKU,aAAc,OAAO,EAEpD,GAAIV,EAAKW,8BAAgCX,EAAKf,IAAI,QAAQ2F,mBACxD,OAAO,EAR6B,IAYpCvE,EACEL,EADFK,KAEEL,EAAKU,eAAcL,EAAOA,EAAKqW,MAdG,UAgBdrW,EAAKs0B,YAhBS,IAgBtC,2BAAyC,CACvC,GAA8B,eADS,QACzBl2B,MAAMA,MAClB,OAAO,GAlB2B,mCAnX1CD,EAAQunB,QAAK,EAEb,IAAIpnB,EAIJ,SAAiCC,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEF,QAASE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAMG,IAAIL,GAAQ,IAAIM,EAAS,GAAQC,EAAwBb,OAAOC,gBAAkBD,OAAOc,yBAA0B,IAAK,IAAIC,KAAOT,EAAO,GAAIN,OAAOgB,UAAUC,eAAeC,KAAKZ,EAAKS,GAAM,CAAE,IAAII,EAAON,EAAwBb,OAAOc,yBAAyBR,EAAKS,GAAO,KAAUI,IAASA,EAAKR,KAAOQ,EAAKC,KAAQpB,OAAOC,eAAeW,EAAQG,EAAKI,GAAgBP,EAAOG,GAAOT,EAAIS,GAAYH,EAAOR,QAAUE,EAASE,GAASA,EAAMY,IAAId,EAAKM,GAAW,OAAOA,EAJttBS,CAAwBC,EAAQ,KAExC,SAASb,IAA6B,GAAuB,oBAAZc,QAAwB,OAAO,KAAM,IAAIf,EAAQ,IAAIe,QAAqE,OAA1Dd,EAA2B,WAAc,OAAOD,GAAiBA,EAQlL,SAASE,EAAIK,GACX,IAAMuM,EAAMtK,KAAKjB,MAAQiB,KAAKjB,KAAKhB,GAEnC,OAAIuM,GAAO/I,MAAMC,QAAQ8I,KACdA,EAAIjJ,SAEJiJ,EAQb,IAAMma,EAAK/mB,EA0GX,SAASq0B,EAAiBrzB,GACxB,OAAQA,EAAKS,MAAM6C,qBAAuBtD,EAAKS,MAAM0Q,oBAAoBnR,KAG3E,SAAS40B,EAAqBltB,EAAMrI,GAClC,OAAQqI,GACN,IAAK,oBACH,MAAe,UAARrI,EAET,IAAK,wBACL,IAAK,cACH,MAAe,eAARA,GAAgC,cAARA,EAEjC,IAAK,iBACL,IAAK,mBACL,IAAK,iBACL,IAAK,iBACH,MAAe,SAARA,EAET,IAAK,eACH,MAAe,SAARA,GAA0B,WAARA,EAE3B,IAAK,kBACH,MAAe,UAARA,EAET,IAAK,eACH,MAAe,YAARA,EAET,IAAK,oBACH,MAAe,UAARA,EAET,IAAK,2BACH,MAAe,aAARA,EAET,IAAK,yBACH,MAAe,cAARA,EAET,QACE,OAAO,GAIb,SAASo0B,EAA2BnvB,EAAOuwB,GACzC,IAAK,IAAInyB,EAAI,EAAGA,EAAImyB,EAAUnyB,IAAK,CACjC,IAAM1C,EAAOsE,EAAM5B,GAEnB,GAAIkyB,EAAqB50B,EAAKY,OAAO8G,KAAM1H,EAAKmC,WAC9C,OAAO,EAIX,OAAO,EA5JT3D,EAAQunB,GAAKA,EAyNb,IAAM8N,EAA6B,IAAI7V,S,6CC1QvC1f,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQgB,KA2BR,SAAcH,GACZ,IAAM0O,EAAOzM,KAAKyM,KAGlB,GAFAzM,KAAKgb,MAAMjd,GAEPiC,KAAKjB,MACHiB,KAAKwzB,MAAM/mB,EAAK1O,IAAO,OAAO,EAGpC,GAAIiC,KAAKjB,KACP,OAAOiB,KAAKwzB,MAAM/mB,EAAKzM,KAAKjB,KAAKqH,OAASqG,EAAKzM,KAAKjB,KAAKqH,MAAMrI,IAGjE,OAAO,GAtCTb,EAAQs2B,MAyCR,SAAetqB,GACb,IAAKA,EAAK,OAAO,EADC,UAGDA,GAHC,IAGlB,2BAAsB,KAAXqB,EAAW,QACpB,GAAKA,EAAL,CACA,IAAMxL,EAAOiB,KAAKjB,KAClB,IAAKA,EAAM,OAAO,EAClB,IAAM2zB,EAAMnoB,EAAGrM,KAAK8B,KAAKrB,MAAOqB,KAAMA,KAAKrB,OAE3C,GAAI+zB,GAAsB,kBAARA,GAAwC,oBAAbA,EAAIe,KAC/C,MAAM,IAAIvpB,MAAM,gNAGlB,GAAIwoB,EACF,MAAM,IAAIxoB,MAAJ,sDAAyDK,IAGjE,GAAIvK,KAAKjB,OAASA,EAAM,OAAO,EAC/B,GAAIiB,KAAKmb,eAAiB,EAAG,OAAO,IAlBpB,8BAqBlB,OAAO,GA7DTje,EAAQw2B,cAAgBx2B,EAAQy2B,aAgEhC,WACE,IAAIC,EAEE7Z,EAAyD,OAA7C6Z,EAAsB5zB,KAAKyM,KAAKsN,UAAoB6Z,EAAsB5zB,KAAKyM,KAAKonB,UACtG,OAAO9Z,GAAYA,EAASxZ,QAAQP,KAAKjB,KAAKqH,OAAS,GAnEzDlJ,EAAQsc,MAsER,WACE,IAAKxZ,KAAKjB,KACR,OAAO,EAGT,GAAIiB,KAAK2zB,eACP,OAAO,EAGT,GAAI3zB,KAAKyM,KAAKqnB,YAAc9zB,KAAKyM,KAAKqnB,WAAW9zB,MAC/C,OAAO,EAGT,GAAIA,KAAK8zB,YAAc9zB,KAAK9B,KAAK,UAAY8B,KAAK8zB,WAEhD,OADA9zB,KAAKgb,MAAM,WACJhb,KAAK+zB,WAQd,OALA/zB,KAAKgb,MAAM,qBAEXxW,EAAOpH,QAAQ2B,KAAKiB,KAAKjB,KAAMiB,KAAKyM,KAAMzM,KAAKb,MAAOa,KAAKrB,MAAOqB,KAAMA,KAAKuZ,UAE7EvZ,KAAK9B,KAAK,QACH8B,KAAK+zB,YA5Fd72B,EAAQmgB,KA+FR,WACErd,KAAK8zB,YAAa,GA/FpB52B,EAAQ82B,QAkGR,SAAiBj2B,GACM,MAAjBiC,KAAKuZ,WACPvZ,KAAKuZ,SAAW,IAGlBvZ,KAAKuZ,SAASxb,IAAO,GAtGvBb,EAAQ2C,KAyGR,WACEG,KAAKmb,gBAAkB+L,EAAQlN,YAAckN,EAAQjN,aAzGvD/c,EAAQ2qB,SA4GR,WACE,GAAI7nB,KAAKyM,MAAQzM,KAAKyM,KAAKyM,QAAS,OACpC,IACIqM,EADA7mB,EAAOsB,KAAKf,WAGhB,KAAOP,IAAS6mB,GAAQ,CACtB,GAAI7mB,EAAK+N,MAAQ/N,EAAK+N,KAAKyM,QAAS,OACpCqM,EAAS7mB,EAAKS,MACdT,EAAOA,EAAKO,WAGde,KAAKb,MAAQa,KAAKi0B,SAAS1O,GACvBvlB,KAAKb,OAAOa,KAAKb,MAAM+N,QAvH7BhQ,EAAQwH,WA0HR,SAAoBC,GACG,MAAjB3E,KAAKuZ,WACPvZ,KAAKuZ,SAAW,IAGlBvZ,KAAKmb,eAAiB,EAElBxW,IACF3E,KAAK2E,QAAUA,EACf3E,KAAKrB,MAAQgG,EAAQhG,MACrBqB,KAAKyM,KAAO9H,EAAQ8H,MAItB,OADAzM,KAAK6nB,WACE7nB,MAvIT9C,EAAQyf,OA0IR,WACE,GAAI3c,KAAKinB,QAAS,OAElBjnB,KAAKk0B,gBAELl0B,KAAKm0B,cAELn0B,KAAKo0B,cAhJPl3B,EAAQg3B,cAmJR,WACMl0B,KAAKf,aACPe,KAAKV,OAASU,KAAKf,WAAWF,OApJlC7B,EAAQk3B,WAwJR,WACE,IAAKp0B,KAAKyB,UAAW,OACrB,GAAIzB,KAAKjB,OAASiB,KAAKyB,UAAUzB,KAAKjC,KAAM,OAE5C,GAAIwD,MAAMC,QAAQxB,KAAKyB,YACrB,IAAK,IAAIL,EAAI,EAAGA,EAAIpB,KAAKyB,UAAUJ,OAAQD,IACzC,GAAIpB,KAAKyB,UAAUL,KAAOpB,KAAKjB,KAC7B,OAAOiB,KAAKq0B,OAAOjzB,QAIvB,cAAkBpE,OAAOmD,KAAKH,KAAKyB,WAAnC,eAA+C,CAA1C,IAAM1D,EAAG,KACZ,GAAIiC,KAAKyB,UAAU1D,KAASiC,KAAKjB,KAC/B,OAAOiB,KAAKq0B,OAAOt2B,GAKzBiC,KAAKjC,IAAM,MAzKbb,EAAQi3B,YA4KR,WACE,IAAKn0B,KAAKV,SAAWU,KAAKwb,OAAQ,OAClC,IAAM8Y,EAAet0B,KAAKV,OAAOU,KAAKyE,SACtC,GAAIzE,KAAKyB,YAAc6yB,EAAc,OACrCt0B,KAAKyB,UAAY6yB,GAAgB,MA/KnCp3B,EAAQq3B,eAkLR,WACkB,MAAZv0B,KAAKjC,KAAgBiC,KAAKyB,WAAazB,KAAKyB,UAAUzB,KAAKjC,OAASiC,KAAKjB,MAC3EiB,KAAKw0B,gBAnLTt3B,EAAQ6f,WAuLR,WACE/c,KAAKkb,SAASla,MAEVhB,KAAKkb,SAAS7Z,OAAS,EACzBrB,KAAK0E,WAAW1E,KAAKkb,SAASlb,KAAKkb,SAAS7Z,OAAS,IAErDrB,KAAK0E,gBAAW2W,IA5LpBne,EAAQ0f,YAgMR,SAAqBjY,GACnB3E,KAAKkb,SAAS1b,KAAKmF,GACnB3E,KAAK0E,WAAWC,IAjMlBzH,EAAQ6e,MAoMR,SAAe9c,EAAYwC,EAAWgD,EAAS1G,GAC7CiC,KAAKyE,QAAUA,EACfzE,KAAKyB,UAAYA,EACjBzB,KAAKf,WAAaA,GAAce,KAAKf,WACrCe,KAAKq0B,OAAOt2B,IAvMdb,EAAQm3B,OA0MR,SAAgBt2B,GACd,IAAI02B,EAEJz0B,KAAKjC,IAAMA,EACXiC,KAAKjB,KAAOiB,KAAKyB,UAAUzB,KAAKjC,KAChCiC,KAAKoG,KAAmC,OAA3BquB,EAAaz0B,KAAKjB,WAAgB,EAAS01B,EAAWruB,MA9MrElJ,EAAQqpB,QAiNR,WAAqC,IAApBmO,EAAoB,uDAAN10B,KAC7B,GAAI00B,EAAYzN,QAAS,OACzB,IAFmC,EAE7B/L,EAAWlb,KAAKkb,SAFa,IAIbA,GAJa,IAInC,2BAAgC,KAArBvW,EAAqB,QAC9BA,EAAQgwB,WAAWD,IALc,gCAhNrCx3B,EAAQ03B,kBAyNR,WACE,IAAIl2B,EAAOsB,KACPkb,EAAWlb,KAAKkb,SAEpB,MAAQA,EAAS7Z,SACf3C,EAAOA,EAAKO,aAEZic,EAAWxc,EAAKwc,SAGlB,OAAOA,GAjOT,IAIgC5d,EAJ5BkH,GAI4BlH,EAJIgB,EAAQ,MAIShB,EAAIC,WAAaD,EAAM,CAAEF,QAASE,GAFnF4pB,EAAU5oB,EAAQ,K,6CC1BtBtB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQgH,OAaR,WACE,IAAI2wB,EAEJ70B,KAAK80B,mBAEL90B,KAAK2c,UAE6B,OAA3BkY,EAAa70B,KAAKyM,WAAgB,EAASooB,EAAW3b,UAC3DlZ,KAAK+0B,mBAGP,GAAI/0B,KAAKg1B,oBAGP,YAFAh1B,KAAKw0B,eAKPx0B,KAAKmH,4BAELnH,KAAKi1B,UAELj1B,KAAKw0B,gBAjCPt3B,EAAQ63B,iBAoCR,WAA4B,WACpBj1B,EAAWE,KAAKyF,wBACtBzI,OAAOmD,KAAKL,GAAU8tB,SAAQ,SAAA5uB,GAAI,OAAI,EAAKG,MAAM+1B,cAAcl2B,OArCjE9B,EAAQ83B,kBAwCR,WAA6B,UACVG,EAAcC,OADJ,IAC3B,2BAAsC,CACpC,IAAI7qB,EADgC,SAC7BvK,KAAMA,KAAKf,YAAa,OAAO,GAFb,gCAvC7B/B,EAAQ+3B,QA6CR,WACM1zB,MAAMC,QAAQxB,KAAKyB,YACrBzB,KAAKyB,UAAU4zB,OAAOr1B,KAAKjC,IAAK,GAChCiC,KAAKs1B,kBAAkBt1B,KAAKjC,KAAM,IAElCiC,KAAK4nB,aAAa,OAjDtB1qB,EAAQs3B,aAqDR,WACEx0B,KAAKmb,gBAAkB3W,EAAOwV,YAAcxV,EAAO0V,QAC/Cla,KAAKV,QAAQiP,EAAO7P,KAAKf,IAAIqC,KAAKV,QAAQqa,OAAO3Z,KAAKjB,MAC1DiB,KAAKjB,KAAO,MAvDd7B,EAAQ43B,iBA0DR,WACE,GAAI90B,KAAKinB,QACP,MAAMjnB,KAAKosB,oBAAoB,+CA1DnC,IAAI+I,EAAgB72B,EAAQ,KAExBiQ,EAASjQ,EAAQ,KAEjBkG,EAASlG,EAAQ,K,iCCdrBtB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQk4B,WAAQ,EAgChBl4B,EAAQk4B,MA/BM,CAAC,SAAUG,EAAMj2B,GAG7B,GAFkC,SAAbi2B,EAAKx3B,MAAmBuB,EAAO+D,WAAa/D,EAAOk2B,iBAAgC,gBAAbD,EAAKx3B,KAAyBuB,EAAOiH,uBAAsC,SAAbgvB,EAAKx3B,KAAkBuB,EAAOyH,sBAAyC,iBAAjBwuB,EAAK9wB,SAA8BnF,EAAOwN,yBAA+D,IAApCxN,EAAOP,KAAKwR,aAAalP,QAA6B,eAAbk0B,EAAKx3B,KAAwBuB,EAAO2E,wBAI/V,OADA3E,EAAO4E,UACA,GAER,SAAUqxB,EAAMj2B,GACjB,GAAIA,EAAOwqB,wBAA6D,IAAnCxqB,EAAOP,KAAKsX,YAAYhV,OAE3D,OADA/B,EAAOqD,YAAYrD,EAAOP,KAAKsX,YAAY,KACpC,GAER,SAAUkf,EAAMj2B,GACjB,GAAIA,EAAOiW,WAOT,MANiB,SAAbggB,EAAKx3B,IACPuB,EAAOqD,YAAYrD,EAAOP,KAAKyW,OAE/BlW,EAAOqD,YAAYrD,EAAOP,KAAKiO,OAG1B,GAER,SAAUuoB,EAAMj2B,GACjB,GAAIA,EAAO2D,kBAAiC,eAAbsyB,EAAKx3B,KAAqC,cAAbw3B,EAAKx3B,MAAqC,SAAbw3B,EAAKx3B,MAAmBuB,EAAOsX,UAAYtX,EAAOD,6BAKzI,OAJAk2B,EAAK5yB,YAAY,CACfyD,KAAM,iBACNgP,KAAM,MAED,K,6DChCXpY,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQu4B,aAyBR,SAAsBzY,GACpBhd,KAAK80B,mBAEL9X,EAAQhd,KAAKmmB,gBAAgBnJ,GAHF,IAKzB/d,EACEe,KADFf,WAGF,GAAIA,EAAWgF,yBAA2BhF,EAAW8H,sBAAwB9H,EAAWy2B,4BAA8Bz2B,EAAWwe,8BAAgCzd,KAAKyG,gBACpK,OAAOxH,EAAWw2B,aAAazY,GAC1B,GAAIhd,KAAKonB,WAAW,gBAAkBpnB,KAAKwC,gBAAkBvD,EAAWgO,kBAAiC,SAAbjN,KAAKjC,IAEtG,OADIiC,KAAKjB,MAAMie,EAAMxd,KAAKQ,KAAKjB,MACxBiB,KAAKwnB,gCAAgCxK,GACvC,GAAIzb,MAAMC,QAAQxB,KAAKyB,WAC5B,OAAOzB,KAAK21B,uBAAuB3Y,GAC9B,GAAIhd,KAAKmxB,qBAAsB,CACpC,IAAMyE,EAA0B51B,KAAKjB,QAAUiB,KAAKiE,yBAAmD,MAAxBjE,KAAKjB,KAAKqQ,YAEzF,OADApP,KAAK2C,YAAYtF,EAAE8qB,eAAeyN,EAA0B,CAAC51B,KAAKjB,MAAQ,KACnEiB,KAAKmX,iBAAiB,OAAQ6F,GAErC,MAAM,IAAI9S,MAAM,2GA5CpBhN,EAAQ24B,iBAgDR,SAA0BC,EAAM9Y,GAAO,MACrChd,KAAKs1B,kBAAkBQ,EAAM9Y,EAAM3b,QACnC,IAAM2B,EAAQ,IACd,EAAAhD,KAAKyB,WAAU4zB,OAAf,SAAsBS,EAAM,GAA5B,SAAkC9Y,KAElC,IAAK,IAAI5b,EAAI,EAAGA,EAAI4b,EAAM3b,OAAQD,IAAK,CACrC,IAAM20B,EAAKD,EAAO10B,EACZ1C,EAAOsB,KAAK8C,WAAWizB,GAC7B/yB,EAAMxD,KAAKd,GAEPsB,KAAK2E,SAAW3E,KAAK2E,QAAQwX,OAC/Bzd,EAAKke,YAAY5c,KAAK2E,SAM1B,IAFA,IAAMuW,EAAWlb,KAAK40B,oBAEtB,MAAmB5xB,EAAnB,eAA0B,CAArB,IAAMtE,EAAI,KACbA,EAAKmpB,WACLnpB,EAAKsc,MAAM,aAFa,UAIFE,GAJE,IAIxB,2BAAgC,SACtByZ,WAAWj2B,GAAM,IALH,+BAS1B,OAAOsE,GAzET9F,EAAQy4B,uBA4ER,SAAgC3Y,GAC9B,OAAOhd,KAAK61B,iBAAiB71B,KAAKjC,IAAKif,IA5EzC9f,EAAQ6rB,sBA+ER,SAA+B/L,GAC7B,OAAOhd,KAAK61B,iBAAiB71B,KAAKjC,IAAM,EAAGif,IA/E7C9f,EAAQopB,YAkFR,SAAqBtJ,GACnBhd,KAAK80B,mBAEL9X,EAAQhd,KAAKmmB,gBAAgBnJ,GAHH,IAKxB/d,EACEe,KADFf,WAGF,GAAIA,EAAWgF,yBAA2BhF,EAAW8H,sBAAwB9H,EAAWy2B,4BAA8Bz2B,EAAWwe,8BAAgCzd,KAAKyG,gBACpK,OAAOxH,EAAWqnB,YAAYtJ,EAAM1X,KAAI,SAAAvG,GACtC,OAAO1B,EAAE+P,aAAarO,GAAQ1B,EAAEkqB,oBAAoBxoB,GAAQA,MAEzD,GAAIiB,KAAKonB,WAAW,gBAAkBpnB,KAAKwC,iBAAmBvD,EAAWuD,gBAAkBvD,EAAWgO,kBAAiC,SAAbjN,KAAKjC,IAAgB,CACpJ,GAAIiC,KAAKjB,KAAM,KAEXI,EACEa,KADFb,MAGEF,EAAW2W,SAAS,CACtBC,UAAU,EACV9X,IAAKiC,KAAKjB,SAEVI,EAAQA,EAAMG,QAGhB,IAAM02B,EAAO72B,EAAMopB,gCACnBvL,EAAM9I,QAAQ7W,EAAEkqB,oBAAoBlqB,EAAEqrB,qBAAqB,IAAKrrB,EAAEuF,UAAUozB,GAAOh2B,KAAKjB,QACxFie,EAAMxd,KAAKnC,EAAEkqB,oBAAoBlqB,EAAEuF,UAAUozB,KAG/C,OAAOh2B,KAAKwnB,gCAAgCxK,GACvC,GAAIzb,MAAMC,QAAQxB,KAAKyB,WAC5B,OAAOzB,KAAK+oB,sBAAsB/L,GAC7B,GAAIhd,KAAKmxB,qBAAsB,CACpC,IAAMyE,EAA0B51B,KAAKjB,QAAUiB,KAAKiE,yBAAmD,MAAxBjE,KAAKjB,KAAKqQ,YAEzF,OADApP,KAAK2C,YAAYtF,EAAE8qB,eAAeyN,EAA0B,CAAC51B,KAAKjB,MAAQ,KACnEiB,KAAKwoB,cAAc,OAAQxL,GAElC,MAAM,IAAI9S,MAAM,2GAvHpBhN,EAAQo4B,kBA2HR,SAA2BW,EAAWC,GACpC,IAAKl2B,KAAKV,OAAQ,OAElB,IAHiD,EAG3C0D,EAAQuL,EAAO7P,KAAKf,IAAIqC,KAAKV,QAHc,IAK1B0D,GAL0B,IAKjD,2BAA8B,KAAhBtE,EAAgB,gBACxBA,EAAKX,KAAOk4B,IACdv3B,EAAKX,KAAOm4B,IAPiC,gCA1HnDh5B,EAAQipB,gBAsIR,SAAyBnJ,GACvB,IAAKA,EACH,MAAO,GAGLA,EAAMmZ,cAAgB50B,QACxByb,EAAQ,CAACA,IAGX,IAAK,IAAI5b,EAAI,EAAGA,EAAI4b,EAAM3b,OAAQD,IAAK,CACrC,IAAMrC,EAAOie,EAAM5b,GACfgK,OAAG,EAYP,GAVKrM,EAEsB,kBAATA,EAChBqM,EAAM,6BACIrM,EAAKqH,KAENrH,aAAgByF,EAAOpH,UAChCgO,EAAM,gDAFNA,EAAM,iBAJNA,EAAM,iBASJA,EAAK,CACP,IAAMhF,EAAO7E,MAAMC,QAAQzC,GAAQ,eAAiBA,EACpD,MAAM,IAAImL,MAAJ,oBAAuBkB,EAAvB,8BAAgDhK,EAAhD,wBAAiEgF,KAI3E,OAAO4W,GAlKT9f,EAAQia,iBAqKR,SAA0B1S,EAASuY,GAajC,OAZAhd,KAAK80B,mBAEL9X,EAAQhd,KAAKmmB,gBAAgBnJ,GAEhBxY,EAAOpH,QAAQO,IAAI,CAC9BsB,WAAYe,KACZV,OAAQU,KAAKjB,KACb0C,UAAWzB,KAAKjB,KAAK0F,GACrBA,UACA1G,IAAK,IACJ2G,WAAW1E,KAAK2E,SAEPgxB,uBAAuB3Y,IAjLrC9f,EAAQsrB,cAoLR,SAAuB/jB,EAASuY,GAC9Bhd,KAAK80B,mBAEL9X,EAAQhd,KAAKmmB,gBAAgBnJ,GAC7B,IAAMvb,EAAYzB,KAAKjB,KAAK0F,GAU5B,OARaD,EAAOpH,QAAQO,IAAI,CAC9BsB,WAAYe,KACZV,OAAQU,KAAKjB,KACb0C,UAAWA,EACXgD,UACA1G,IAAK0D,EAAUJ,SACdqD,WAAW1E,KAAK2E,SAEPshB,oBAAoBjJ,IAjMlC9f,EAAQk5B,MAoMR,WAAmC,IAApBj3B,EAAoB,uDAAZa,KAAKb,MACpBk3B,EAAU,IAAIC,EAASl5B,QAAQ4C,KAAMb,GAC3C,OAAOk3B,EAAQE,OApMjB,IAAIhoB,EAASjQ,EAAQ,KAEjBg4B,EAAWloB,EAAuB9P,EAAQ,MAE1CkG,EAAS4J,EAAuB9P,EAAQ,KAExCjB,EAIJ,SAAiCC,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEF,QAASE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAMG,IAAIL,GAAQ,IAAIM,EAAS,GAAQC,EAAwBb,OAAOC,gBAAkBD,OAAOc,yBAA0B,IAAK,IAAIC,KAAOT,EAAO,GAAIN,OAAOgB,UAAUC,eAAeC,KAAKZ,EAAKS,GAAM,CAAE,IAAII,EAAON,EAAwBb,OAAOc,yBAAyBR,EAAKS,GAAO,KAAUI,IAASA,EAAKR,KAAOQ,EAAKC,KAAQpB,OAAOC,eAAeW,EAAQG,EAAKI,GAAgBP,EAAOG,GAAOT,EAAIS,GAAYH,EAAOR,QAAUE,EAASE,GAASA,EAAMY,IAAId,EAAKM,GAAW,OAAOA,EAJttBS,CAAwBC,EAAQ,KAExC,SAASb,IAA6B,GAAuB,oBAAZc,QAAwB,OAAO,KAAM,IAAIf,EAAQ,IAAIe,QAAqE,OAA1Dd,EAA2B,WAAc,OAAOD,GAAiBA,EAIlL,SAAS4Q,EAAuB9Q,GAAO,OAAOA,GAAOA,EAAIC,WAAaD,EAAM,CAAEF,QAASE","file":"static/js/vendors-runtime-traverse.ccaf814b.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = t.variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = t.JSXExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(t.cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOpposite = getOpposite;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getSibling = getSibling;\nexports.getPrevSibling = getPrevSibling;\nexports.getNextSibling = getNextSibling;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.get = get;\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n}\n\nfunction addCompletionRecords(path, paths) {\n  if (path) return paths.concat(path.getCompletionRecords());\n  return paths;\n}\n\nfunction findBreak(statements) {\n  let breakStatement;\n\n  if (!Array.isArray(statements)) {\n    statements = [statements];\n  }\n\n  for (const statement of statements) {\n    if (statement.isDoExpression() || statement.isProgram() || statement.isBlockStatement() || statement.isCatchClause() || statement.isLabeledStatement()) {\n      breakStatement = findBreak(statement.get(\"body\"));\n    } else if (statement.isIfStatement()) {\n      var _findBreak;\n\n      breakStatement = (_findBreak = findBreak(statement.get(\"consequent\"))) != null ? _findBreak : findBreak(statement.get(\"alternate\"));\n    } else if (statement.isTryStatement()) {\n      var _findBreak2;\n\n      breakStatement = (_findBreak2 = findBreak(statement.get(\"block\"))) != null ? _findBreak2 : findBreak(statement.get(\"handler\"));\n    } else if (statement.isBreakStatement()) {\n      breakStatement = statement;\n    }\n\n    if (breakStatement) {\n      return breakStatement;\n    }\n  }\n\n  return null;\n}\n\nfunction completionRecordForSwitch(cases, paths) {\n  let isLastCaseWithConsequent = true;\n\n  for (let i = cases.length - 1; i >= 0; i--) {\n    const switchCase = cases[i];\n    const consequent = switchCase.get(\"consequent\");\n    let breakStatement = findBreak(consequent);\n\n    if (breakStatement) {\n      while (breakStatement.key === 0 && breakStatement.parentPath.isBlockStatement()) {\n        breakStatement = breakStatement.parentPath;\n      }\n\n      const prevSibling = breakStatement.getPrevSibling();\n\n      if (breakStatement.key > 0 && (prevSibling.isExpressionStatement() || prevSibling.isBlockStatement())) {\n        paths = addCompletionRecords(prevSibling, paths);\n        breakStatement.remove();\n      } else {\n        breakStatement.replaceWith(breakStatement.scope.buildUndefinedNode());\n        paths = addCompletionRecords(breakStatement, paths);\n      }\n    } else if (isLastCaseWithConsequent) {\n      const statementFinder = statement => !statement.isBlockStatement() || statement.get(\"body\").some(statementFinder);\n\n      const hasConsequent = consequent.some(statementFinder);\n\n      if (hasConsequent) {\n        paths = addCompletionRecords(consequent[consequent.length - 1], paths);\n        isLastCaseWithConsequent = false;\n      }\n    }\n  }\n\n  return paths;\n}\n\nfunction getCompletionRecords() {\n  let paths = [];\n\n  if (this.isIfStatement()) {\n    paths = addCompletionRecords(this.get(\"consequent\"), paths);\n    paths = addCompletionRecords(this.get(\"alternate\"), paths);\n  } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isProgram() || this.isBlockStatement()) {\n    paths = addCompletionRecords(this.get(\"body\").pop(), paths);\n  } else if (this.isFunction()) {\n    return this.get(\"body\").getCompletionRecords();\n  } else if (this.isTryStatement()) {\n    paths = addCompletionRecords(this.get(\"block\"), paths);\n    paths = addCompletionRecords(this.get(\"handler\"), paths);\n  } else if (this.isCatchClause()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isSwitchStatement()) {\n    paths = completionRecordForSwitch(this.get(\"cases\"), paths);\n  } else {\n    paths.push(this);\n  }\n\n  return paths;\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return t.getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return t.getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  let search = [].concat(path);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = t.getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child) || child.node) {\n          search = search.concat(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\nexports.addComment = addComment;\nexports.addComments = addComments;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction shareCommentsWithSiblings() {\n  if (typeof this.key === \"string\") return;\n  const node = this.node;\n  if (!node) return;\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n\n  if (hasPrev && !hasNext) {\n    prev.addComments(\"trailing\", trailing);\n  } else if (hasNext && !hasPrev) {\n    next.addComments(\"leading\", leading);\n  }\n}\n\nfunction addComment(type, content, line) {\n  t.addComment(this.node, type, content, line);\n}\n\nfunction addComments(type, comments) {\n  t.addComments(this.node, type, comments);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.verify = verify;\nexports.merge = merge;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./path/lib/virtual-types\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      for (const type of wrapper.types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = t.FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecratedKey = t.DEPRECATED_KEYS[nodeType];\n\n    if (deprecratedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecratedKey}`);\n      aliases = [deprecratedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (t.TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors, states = [], wrapper) {\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  const newFn = function (path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\" || key === \"blacklist\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Hub {\n  getCode() {}\n\n  getScope() {}\n\n  addHelper() {\n    throw new Error(\"Helpers are not supported by the default hub.\");\n  }\n\n  buildError(node, msg, Error = TypeError) {\n    return new Error(msg);\n  }\n\n}\n\nexports.default = Hub;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clear = clear;\nexports.clearPath = clearPath;\nexports.clearScope = clearScope;\nexports.scope = exports.path = void 0;\nlet path = new WeakMap();\nexports.path = path;\nlet scope = new WeakMap();\nexports.scope = scope;\n\nfunction clear() {\n  clearPath();\n  clearScope();\n}\n\nfunction clearPath() {\n  exports.path = path = new WeakMap();\n}\n\nfunction clearScope() {\n  exports.scope = scope = new WeakMap();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {\n      if (t.isJSXIdentifier(node, opts)) {\n        if (t.react.isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return t.isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return t.isMemberExpression(node) && t.isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (t.isStatement(node)) {\n      if (t.isVariableDeclaration(node)) {\n        if (t.isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (t.isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t.isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return t.isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return t.isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return t.isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return t.isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (t.isFlow(node)) {\n      return true;\n    } else if (t.isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t.isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (t.isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = _interopRequireDefault(require(\"./lib/renamer\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _binding = _interopRequireDefault(require(\"./binding\"));\n\nvar _globals = _interopRequireDefault(require(\"globals\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (t.isModuleDeclaration(node)) {\n        if (node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if (node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if (node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (t.isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (t.isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  For(path) {\n    for (const key of t.FOR_INIT_KEYS) {\n      const declar = path.get(key);\n\n      if (declar.isVar()) {\n        const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        parentScope.registerBinding(\"var\", declar);\n      }\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n\n    if (path.isExportDeclaration() && path.get(\"declaration\").isDeclaration()) {\n      return;\n    }\n\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      const declar = node.declaration;\n\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        if (binding) binding.reference(path);\n      } else if (t.isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(t.getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            if (binding) binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getProgramParent().addGlobal(path.node);\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  Block(path) {\n    const paths = path.get(\"body\");\n\n    for (const bodyPath of paths) {\n      if (bodyPath.isFunctionDeclaration()) {\n        path.scope.getBlockParent().registerDeclaration(bodyPath);\n      }\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    const parent = this.path.findParent(p => p.isScope());\n    return parent == null ? void 0 : parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return t.cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return t.identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = t.toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return t.identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (t.isThisExpression(node) || t.isSuper(node)) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return t.cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, allowArrayLike) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if ((binding == null ? void 0 : binding.constant) && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (t.isArrayExpression(node)) {\n      return node;\n    }\n\n    if (t.isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(\"Array\"), t.identifier(\"prototype\")), t.identifier(\"slice\")), t.identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(t.numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (allowArrayLike) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return t.callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return t.unaryExpression(\"void\", t.numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (t.isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (t.isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (t.isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (t.isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (t.isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (t.isTaggedTemplateExpression(node)) {\n      return t.matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (t.isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return t.isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n\n    if (path.isFunction()) {\n      if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n        this.registerBinding(\"local\", path.get(\"id\"), path);\n      }\n\n      const params = path.get(\"params\");\n\n      for (const param of params) {\n        this.registerBinding(\"param\", param);\n      }\n    }\n\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = t.variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = t.variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind() {\n    const ids = Object.create(null);\n\n    for (const kind of arguments) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if (((_previousPath = previousPath) == null ? void 0 : _previousPath.isPattern()) && binding.kind !== \"param\") {} else {\n          return binding;\n        }\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.default.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Binding {\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind\n  }) {\n    this.constantViolations = [];\n    this.constant = true;\n    this.referencePaths = [];\n    this.referenced = false;\n    this.references = 0;\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n    this.clearValue();\n  }\n\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n\n  setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n\n  reassign(path) {\n    this.constant = false;\n\n    if (this.constantViolations.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.constantViolations.push(path);\n  }\n\n  reference(path) {\n    if (this.referencePaths.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n\n}\n\nexports.default = Binding;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = traverse;\nObject.defineProperty(exports, \"NodePath\", {\n  enumerable: true,\n  get: function () {\n    return _path.default;\n  }\n});\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return _scope.default;\n  }\n});\nObject.defineProperty(exports, \"Hub\", {\n  enumerable: true,\n  get: function () {\n    return _hub.default;\n  }\n});\nexports.visitors = void 0;\n\nvar _context = _interopRequireDefault(require(\"./context\"));\n\nvar visitors = _interopRequireWildcard(require(\"./visitors\"));\n\nexports.visitors = visitors;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar cache = _interopRequireWildcard(require(\"./cache\"));\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar _scope = _interopRequireDefault(require(\"./scope\"));\n\nvar _hub = _interopRequireDefault(require(\"./hub\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction traverse(parent, opts, scope, state, parentPath) {\n  if (!parent) return;\n  if (!opts) opts = {};\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\"You must pass a scope and parentPath unless traversing a Program/File. \" + `Instead of that you tried to traverse a ${parent.type} node without ` + \"passing scope and parentPath.\");\n    }\n  }\n\n  if (!t.VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts);\n  traverse.node(parent, opts, scope, state, parentPath);\n}\n\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node, enter) {\n  return t.traverseFast(node, enter);\n};\n\ntraverse.node = function (node, opts, scope, state, parentPath, skipKeys) {\n  const keys = t.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  const context = new _context.default(scope, opts, state, parentPath);\n\n  for (const key of keys) {\n    if (skipKeys && skipKeys[key]) continue;\n    if (context.visit(node, key)) return;\n  }\n};\n\ntraverse.clearNode = function (node, opts) {\n  t.removeProperties(node, opts);\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (tree, opts) {\n  t.traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\nfunction hasDenylistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (tree, type, denylistTypes) {\n  if (denylistTypes == null ? void 0 : denylistTypes.includes(tree.type)) return false;\n  if (tree.type === type) return true;\n  const state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    noScope: true,\n    denylist: denylistTypes,\n    enter: hasDenylistedType\n  }, null, state);\n  return state.has;\n};\n\ntraverse.cache = cache;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SHOULD_SKIP = exports.SHOULD_STOP = exports.REMOVED = void 0;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./lib/virtual-types\"));\n\nvar _debug = _interopRequireDefault(require(\"debug\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _scope = _interopRequireDefault(require(\"../scope\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nvar _generator = _interopRequireDefault(require(\"@babel/generator\"));\n\nvar NodePath_ancestry = _interopRequireWildcard(require(\"./ancestry\"));\n\nvar NodePath_inference = _interopRequireWildcard(require(\"./inference\"));\n\nvar NodePath_replacement = _interopRequireWildcard(require(\"./replacement\"));\n\nvar NodePath_evaluation = _interopRequireWildcard(require(\"./evaluation\"));\n\nvar NodePath_conversion = _interopRequireWildcard(require(\"./conversion\"));\n\nvar NodePath_introspection = _interopRequireWildcard(require(\"./introspection\"));\n\nvar NodePath_context = _interopRequireWildcard(require(\"./context\"));\n\nvar NodePath_removal = _interopRequireWildcard(require(\"./removal\"));\n\nvar NodePath_modification = _interopRequireWildcard(require(\"./modification\"));\n\nvar NodePath_family = _interopRequireWildcard(require(\"./family\"));\n\nvar NodePath_comments = _interopRequireWildcard(require(\"./comments\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst debug = (0, _debug.default)(\"babel\");\nconst REMOVED = 1 << 0;\nexports.REMOVED = REMOVED;\nconst SHOULD_STOP = 1 << 1;\nexports.SHOULD_STOP = SHOULD_STOP;\nconst SHOULD_SKIP = 1 << 2;\nexports.SHOULD_SKIP = SHOULD_SKIP;\n\nclass NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key\n  }) {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode = container[key];\n\n    let paths = _cache.path.get(parent);\n\n    if (!paths) {\n      paths = new Map();\n\n      _cache.path.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  }\n\n  getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  }\n\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    return this.data[key] = val;\n  }\n\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  buildCodeFrameError(msg, Error = SyntaxError) {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key, node) {\n    t.validate(this.node, key, node);\n    this.node[key] = node;\n  }\n\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  }\n\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n\n}\n\nexports.default = NodePath;\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n\n  NodePath.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === \"_\") continue;\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n  const virtualType = virtualTypes[type];\n\n  NodePath.prototype[`is${type}`] = function (opts) {\n    return virtualType.checkPath(this, opts);\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst testing = process.env.NODE_ENV === \"test\";\n\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = t.VISITOR_KEYS[node.type];\n    if (!(keys == null ? void 0 : keys.length)) return false;\n\n    for (const key of keys) {\n      if (node[key]) return true;\n    }\n\n    return false;\n  }\n\n  create(node, obj, key, listKey) {\n    return _path.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey\n    });\n  }\n\n  maybeQueue(path, notPriority) {\n    if (this.trap) {\n      throw new Error(\"Infinite cycle detected\");\n    }\n\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n\n    for (const path of queue) {\n      path.resync();\n\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        path.pushContext(this);\n      }\n\n      if (path.key === null) continue;\n\n      if (testing && queue.length >= 10000) {\n        this.trap = true;\n      }\n\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    for (const path of queue) {\n      path.popContext();\n    }\n\n    this.queue = null;\n    return stop;\n  }\n\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n\n}\n\nexports.default = TraversalContext;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = _interopRequireDefault(require(\"../binding\"));\n\nvar _helperSplitExportDeclaration = _interopRequireDefault(require(\"@babel/helper-split-export-declaration\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      path.skip();\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = t.identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(t.identifier(this.newName), t.toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = t.identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: t.identifier(this.newName)\n    });\n    path.replaceWith(t.assignmentExpression(\"=\", t.identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    scope.traverse(block || scope.block, renameVisitor, this);\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (binding.type === \"hoisted\") {}\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findParent = findParent;\nexports.find = find;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getAncestry = getAncestry;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\nexports.inType = inType;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction findParent(callback) {\n  let path = this;\n\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n\n  return null;\n}\n\nfunction find(callback) {\n  let path = this;\n\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n\n  return null;\n}\n\nfunction getFunctionParent() {\n  return this.findParent(p => p.isFunction());\n}\n\nfunction getStatementParent() {\n  let path = this;\n\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\"File/Program node, we can't possibly find a statement parent to this\");\n  }\n\n  return path;\n}\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    let earliest;\n    const keys = t.VISITOR_KEYS[deepest.type];\n\n    for (const ancestry of ancestries) {\n      const path = ancestry[i + 1];\n\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      if (path.listKey && earliest.listKey === path.listKey) {\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      const currentKeyIndex = keys.indexOf(path.parentKey);\n\n      if (earliestKeyIndex > currentKeyIndex) {\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  let minDepth = Infinity;\n  let lastCommonIndex, lastCommon;\n  const ancestries = paths.map(path => {\n    const ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n  const first = ancestries[0];\n\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        break depthLoop;\n      }\n    }\n\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\nfunction getAncestry() {\n  let path = this;\n  const paths = [];\n\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n\n  return paths;\n}\n\nfunction isAncestor(maybeDescendant) {\n  return maybeDescendant.isDescendant(this);\n}\n\nfunction isDescendant(maybeAncestor) {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\n\nfunction inType() {\n  let path = this;\n\n  while (path) {\n    for (const type of arguments) {\n      if (path.node.type === type) return true;\n    }\n\n    path = path.parentPath;\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypeAnnotation = getTypeAnnotation;\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.couldBeBaseType = couldBeBaseType;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.isGenericType = isGenericType;\n\nvar inferers = _interopRequireWildcard(require(\"./inferers\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n  let type = this._getTypeAnnotation() || t.anyTypeAnnotation();\n  if (t.isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\nconst typeAnnotationInferringNodes = new WeakSet();\n\nfunction _getTypeAnnotation() {\n  const node = this.node;\n\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return t.stringTypeAnnotation();\n      }\n\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return t.anyTypeAnnotation();\n      }\n\n      return t.voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    var _inferer;\n\n    let inferer = inferers[node.type];\n\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    inferer = inferers[this.parentPath.type];\n\n    if ((_inferer = inferer) == null ? void 0 : _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return t.isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return t.isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return t.isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return t.isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return t.isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return t.isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return t.isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (t.isAnyTypeAnnotation(type)) return true;\n\n  if (t.isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(right) {\n  const left = this.getTypeAnnotation();\n  right = right.getTypeAnnotation();\n\n  if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n}\n\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n  return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, {\n    name: genericName\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariableDeclarator = VariableDeclarator;\nexports.TypeCastExpression = TypeCastExpression;\nexports.NewExpression = NewExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.UnaryExpression = UnaryExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.StringLiteral = StringLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.NullLiteral = NullLiteral;\nexports.RegExpLiteral = RegExpLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ArrayExpression = ArrayExpression;\nexports.RestElement = RestElement;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nexports.CallExpression = CallExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _infererReference = _interopRequireDefault(require(\"./inferer-reference\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return t.genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return t.voidTypeAnnotation();\n  } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.stringTypeAnnotation();\n  } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return t.numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return t.stringTypeAnnotation();\n    }\n\n    return t.unionTypeAnnotation([t.stringTypeAnnotation(), t.numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return t.numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return t.numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return t.booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return t.nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return t.genericTypeAnnotation(t.identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return t.genericTypeAnnotation(t.identifier(\"Function\"));\n}\n\nconst isArrayFrom = t.buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = t.buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = t.buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = t.buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return t.arrayTypeAnnotation(t.stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return t.arrayTypeAnnotation(t.anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return t.arrayTypeAnnotation(t.tupleTypeAnnotation([t.stringTypeAnnotation(), t.anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return t.genericTypeAnnotation(t.identifier(\"AsyncIterator\"));\n      } else {\n        return t.genericTypeAnnotation(t.identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(types);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(types);\n  }\n\n  return t.createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return t.createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n      return {\n        typeAnnotation: t.createTSUnionType(types),\n        ifStatement\n      };\n    }\n\n    if (t.createFlowUnionType) {\n      return {\n        typeAnnotation: t.createFlowUnionType(types),\n        ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\nexports.replaceWith = replaceWith;\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = _interopRequireDefault(require(\"./index\"));\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst hoistVariablesVisitor = {\n  Function(path) {\n    path.skip();\n  },\n\n  VariableDeclaration(path) {\n    if (path.node.kind !== \"var\") return;\n    const bindings = path.getBindingIdentifiers();\n\n    for (const key of Object.keys(bindings)) {\n      path.scope.push({\n        id: bindings[key]\n      });\n    }\n\n    const exprs = [];\n\n    for (const declar of path.node.declarations) {\n      if (declar.init) {\n        exprs.push(t.expressionStatement(t.assignmentExpression(\"=\", declar.id, declar.init)));\n      }\n    }\n\n    path.replaceWithMultiple(exprs);\n  }\n\n};\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  t.inheritLeadingComments(nodes[0], this.node);\n  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = `(${replacement})`;\n    replacement = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n\n  _index.default.removeProperties(replacement);\n\n  return this.replaceWith(replacement);\n}\n\nfunction replaceWith(replacement) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index2.default) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !t.isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && t.isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = t.expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && t.isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    t.inheritsComments(replacement, oldNode);\n    t.removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    t.validate(this.parent, this.key, [node]);\n  } else {\n    t.validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const toSequenceExpression = t.toSequenceExpression(nodes, this.scope);\n\n  if (toSequenceExpression) {\n    return this.replaceWith(toSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const container = t.arrowFunctionExpression([], t.blockStatement(nodes));\n  this.replaceWith(t.callExpression(container, []));\n  this.traverse(hoistVariablesVisitor);\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        const callee = this.get(\"callee\");\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", t.returnStatement(t.cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = t.identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(t.assignmentExpression(\"=\", t.cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(t.returnStatement(path.node.expression));\n    }\n  }\n\n  const callee = this.get(\"callee\");\n  callee.arrowFunctionToExpression();\n\n  if (isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", t.FUNCTION_TYPES)) {\n    callee.set(\"async\", true);\n    this.replaceWith(t.awaitExpression(this.node));\n  }\n\n  return callee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n  const {\n    node\n  } = path;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name, true) && property.isIdentifier && property.node.name === \"raw\") {\n      return evaluateQuasis(path, node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding == null ? void 0 : binding.hasValue) {\n      return binding.value;\n    } else {\n      if (node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, true) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[node.callee.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toComputedKey = toComputedKey;\nexports.ensureBlock = ensureBlock;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _helperFunctionName = _interopRequireDefault(require(\"@babel/helper-function-name\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction toComputedKey() {\n  const node = this.node;\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!node.computed) {\n    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(t.returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(t.expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = t.blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  specCompliant = false\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const thisBinding = hoistFunctionEnvironment(this, specCompliant, allowInsertArrow);\n  this.ensureBlock();\n  this.node.type = \"FunctionExpression\";\n\n  if (specCompliant) {\n    const checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      this.parentPath.scope.push({\n        id: checkBinding,\n        init: t.objectExpression([])\n      });\n    }\n\n    this.get(\"body\").unshiftContainer(\"body\", t.expressionStatement(t.callExpression(this.hub.addHelper(\"newArrowCheck\"), [t.thisExpression(), checkBinding ? t.identifier(checkBinding.name) : t.identifier(thisBinding)])));\n    this.replaceWith(t.callExpression(t.memberExpression((0, _helperFunctionName.default)(this, true) || this.node, t.identifier(\"bind\")), [checkBinding ? t.identifier(checkBinding.name) : t.thisExpression()]));\n  }\n}\n\nfunction hoistFunctionEnvironment(fnPath, specCompliant = false, allowInsertArrow = true) {\n  const thisEnvFn = fnPath.findParent(p => {\n    return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({\n      static: false\n    });\n  });\n  const inConstructor = (thisEnvFn == null ? void 0 : thisEnvFn.node.kind) === \"constructor\";\n\n  if (thisEnvFn.isClassProperty()) {\n    throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        allSuperCalls.push(child);\n      }\n\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = t.identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => t.identifier(\"arguments\"));\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = t.identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => t.metaProperty(t.identifier(\"new\"), t.identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = t.identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = t.callExpression(t.identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", t.thisExpression());\n        superProp.replaceWith(t.memberExpression(call, t.identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || specCompliant) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (!specCompliant || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? t.jsxIdentifier(thisBinding) : t.identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (specCompliant) thisBinding = null;\n    }\n  }\n\n  return thisBinding;\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    assignmentPath.node.operator = \"=\";\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, t.assignmentExpression(\"=\", tmp, superProp.node.property), true));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(tmp.name), true), value));\n    } else {\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, superProp.node.property));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(superProp.node.property.name)), value));\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [t.assignmentExpression(\"=\", tmp, t.memberExpression(superProp.node.object, computedKey ? t.assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), t.assignmentExpression(\"=\", t.memberExpression(superProp.node.object, computedKey ? t.identifier(computedKey.name) : superProp.node.property, superProp.node.computed), t.binaryExpression(\"+\", t.identifier(tmp.name), t.numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(t.identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(t.sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return t.thisExpression();\n    const supers = new WeakSet();\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        if (supers.has(child.node)) return;\n        supers.add(child.node);\n        child.replaceWithMultiple([child.node, t.assignmentExpression(\"=\", t.identifier(thisBinding), t.identifier(\"this\"))]);\n      }\n\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return t.arrowFunctionExpression([t.restElement(argsBinding)], t.callExpression(t.super(), [t.spreadElement(t.identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = t.memberExpression(t.super(), t.identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = t.memberExpression(t.super(), t.identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = t.assignmentExpression(\"=\", fnBody, t.identifier(valueIdent.name));\n    }\n\n    return t.arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse({\n    ClassProperty(child) {\n      child.skip();\n    },\n\n    Function(child) {\n      if (child.isArrowFunctionExpression()) return;\n      child.skip();\n    },\n\n    ThisExpression(child) {\n      thisPaths.push(child);\n    },\n\n    JSXIdentifier(child) {\n      if (child.node.name !== \"this\") return;\n\n      if (!child.parentPath.isJSXMemberExpression({\n        object: child.node\n      }) && !child.parentPath.isJSXOpeningElement({\n        name: child.node\n      })) {\n        return;\n      }\n\n      thisPaths.push(child);\n    },\n\n    CallExpression(child) {\n      if (child.get(\"callee\").isSuper()) superCalls.push(child);\n    },\n\n    MemberExpression(child) {\n      if (child.get(\"object\").isSuper()) superProps.push(child);\n    },\n\n    ReferencedIdentifier(child) {\n      if (child.node.name !== \"arguments\") return;\n      argumentsPaths.push(child);\n    },\n\n    MetaProperty(child) {\n      if (!child.get(\"meta\").isIdentifier({\n        name: \"new\"\n      })) return;\n      if (!child.get(\"property\").isIdentifier({\n        name: \"target\"\n      })) return;\n      newTargetPaths.push(child);\n    }\n\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchesPattern = matchesPattern;\nexports.has = has;\nexports.isStatic = isStatic;\nexports.isnt = isnt;\nexports.equals = equals;\nexports.isNodeType = isNodeType;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.referencesImport = referencesImport;\nexports.getSource = getSource;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;\nexports.resolve = resolve;\nexports._resolve = _resolve;\nexports.isConstantExpression = isConstantExpression;\nexports.isInStrictMode = isInStrictMode;\nexports.is = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction matchesPattern(pattern, allowPartial) {\n  return t.matchesPattern(this.node, pattern, allowPartial);\n}\n\nfunction has(key) {\n  const val = this.node && this.node[key];\n\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\n\nconst is = has;\nexports.is = is;\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\nfunction isNodeType(type) {\n  return t.isType(this.type, type);\n}\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return t.isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return t.isExpression(replacement);\n  }\n\n  return false;\n}\n\nfunction isCompletionRecord(allowInsideFunction) {\n  let path = this;\n  let first = true;\n\n  do {\n    const container = path.container;\n\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return t.STATEMENT_OR_BLOCK_KEYS.includes(this.key);\n  }\n}\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) return false;\n  const binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && path.node.imported.name === importName) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getSource() {\n  const node = this.node;\n\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n\n  return \"\";\n}\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path) {\n  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;\n}\n\nfunction isExecutionUncertain(type, key) {\n  switch (type) {\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths, maxIndex) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  const funcParent = {\n    this: getOuterFunction(this),\n    target: getOuterFunction(target)\n  };\n\n  if (funcParent.target.node !== funcParent.this.node) {\n    return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: this.getAncestry()\n  };\n  if (paths.target.indexOf(this) >= 0) return \"after\";\n  if (paths.this.indexOf(target) >= 0) return \"before\";\n  let commonPath;\n  const commonIndex = {\n    target: 0,\n    this: 0\n  };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\"Internal Babel error - The two compared nodes\" + \" don't appear to belong to the same program.\");\n  }\n\n  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1]\n  };\n\n  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  const keys = t.VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey)\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\nconst executionOrderCheckedNodes = new WeakSet();\n\nfunction _guessExecutionStatusRelativeToDifferentFunctions(target) {\n  if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {\n    return \"unknown\";\n  }\n\n  const binding = target.scope.getBinding(target.node.id.name);\n  if (!binding.references) return \"before\";\n  const referencePaths = binding.referencePaths;\n  let allStatus;\n\n  for (const path of referencePaths) {\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      return \"unknown\";\n    }\n\n    if (executionOrderCheckedNodes.has(path.node)) continue;\n    executionOrderCheckedNodes.add(path.node);\n\n    const status = this._guessExecutionStatusRelativeTo(path);\n\n    executionOrderCheckedNodes.delete(path.node);\n\n    if (allStatus && allStatus !== status) {\n      return \"unknown\";\n    } else {\n      allStatus = status;\n    }\n  }\n\n  return allStatus;\n}\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nfunction _resolve(dangerous, resolved) {\n  if (resolved && resolved.indexOf(this) >= 0) return;\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {}\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n    if (!binding.constant) return;\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    const targetKey = this.toComputedKey();\n    if (!t.isLiteral(targetKey)) return;\n    const targetName = targetKey.value;\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n\n      for (const prop of props) {\n        if (!prop.isProperty()) continue;\n        const key = prop.get(\"key\");\n        let match = prop.isnt(\"computed\") && key.isIdentifier({\n          name: targetName\n        });\n        match = match || key.isLiteral({\n          value: targetName\n        });\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nfunction isConstantExpression() {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression => expression.isConstantExpression());\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.get(\"operator\").node !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    return this.get(\"left\").isConstantExpression() && this.get(\"right\").isConstantExpression();\n  }\n\n  return false;\n}\n\nfunction isInStrictMode() {\n  const start = this.isProgram() ? this : this.parentPath;\n  const strictParent = start.find(path => {\n    if (path.isProgram({\n      sourceType: \"module\"\n    })) return true;\n    if (path.isClass()) return true;\n    if (!path.isProgram() && !path.isFunction()) return false;\n\n    if (path.isArrowFunctionExpression() && !path.get(\"body\").isBlockStatement()) {\n      return false;\n    }\n\n    let {\n      node\n    } = path;\n    if (path.isFunction()) node = node.body;\n\n    for (const directive of node.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n  return !!strictParent;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.call = call;\nexports._call = _call;\nexports.isBlacklisted = exports.isDenylisted = isDenylisted;\nexports.visit = visit;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.setScope = setScope;\nexports.setContext = setContext;\nexports.resync = resync;\nexports._resyncParent = _resyncParent;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncRemoved = _resyncRemoved;\nexports.popContext = popContext;\nexports.pushContext = pushContext;\nexports.setup = setup;\nexports.setKey = setKey;\nexports.requeue = requeue;\nexports._getQueueContexts = _getQueueContexts;\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = require(\"./index\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction call(key) {\n  const opts = this.opts;\n  this.debug(key);\n\n  if (this.node) {\n    if (this._call(opts[key])) return true;\n  }\n\n  if (this.node) {\n    return this._call(opts[this.node.type] && opts[this.node.type][key]);\n  }\n\n  return false;\n}\n\nfunction _call(fns) {\n  if (!fns) return false;\n\n  for (const fn of fns) {\n    if (!fn) continue;\n    const node = this.node;\n    if (!node) return true;\n    const ret = fn.call(this.state, this, this.state);\n\n    if (ret && typeof ret === \"object\" && typeof ret.then === \"function\") {\n      throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n    }\n\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n\n    if (this.node !== node) return true;\n    if (this._traverseFlags > 0) return true;\n  }\n\n  return false;\n}\n\nfunction isDenylisted() {\n  var _this$opts$denylist;\n\n  const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;\n  return denylist && denylist.indexOf(this.node.type) > -1;\n}\n\nfunction visit() {\n  if (!this.node) {\n    return false;\n  }\n\n  if (this.isDenylisted()) {\n    return false;\n  }\n\n  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {\n    return false;\n  }\n\n  if (this.shouldSkip || this.call(\"enter\") || this.shouldSkip) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n\n  this.debug(\"Recursing into...\");\n\n  _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);\n\n  this.call(\"exit\");\n  return this.shouldStop;\n}\n\nfunction skip() {\n  this.shouldSkip = true;\n}\n\nfunction skipKey(key) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n\n  this.skipKeys[key] = true;\n}\n\nfunction stop() {\n  this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;\n}\n\nfunction setScope() {\n  if (this.opts && this.opts.noScope) return;\n  let path = this.parentPath;\n  let target;\n\n  while (path && !target) {\n    if (path.opts && path.opts.noScope) return;\n    target = path.scope;\n    path = path.parentPath;\n  }\n\n  this.scope = this.getScope(target);\n  if (this.scope) this.scope.init();\n}\n\nfunction setContext(context) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n\n  this._traverseFlags = 0;\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n\n  this.setScope();\n  return this;\n}\n\nfunction resync() {\n  if (this.removed) return;\n\n  this._resyncParent();\n\n  this._resyncList();\n\n  this._resyncKey();\n}\n\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\nfunction _resyncKey() {\n  if (!this.container) return;\n  if (this.node === this.container[this.key]) return;\n\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        return this.setKey(i);\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      if (this.container[key] === this.node) {\n        return this.setKey(key);\n      }\n    }\n  }\n\n  this.key = null;\n}\n\nfunction _resyncList() {\n  if (!this.parent || !this.inList) return;\n  const newContainer = this.parent[this.listKey];\n  if (this.container === newContainer) return;\n  this.container = newContainer || null;\n}\n\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    this._markRemoved();\n  }\n}\n\nfunction popContext() {\n  this.contexts.pop();\n\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\n\nfunction pushContext(context) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\n\nfunction setup(parentPath, container, listKey, key) {\n  this.listKey = listKey;\n  this.container = container;\n  this.parentPath = parentPath || this.parentPath;\n  this.setKey(key);\n}\n\nfunction setKey(key) {\n  var _this$node;\n\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;\n}\n\nfunction requeue(pathToQueue = this) {\n  if (pathToQueue.removed) return;\n  const contexts = this.contexts;\n\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\n\nfunction _getQueueContexts() {\n  let path = this;\n  let contexts = this.contexts;\n\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n\n  return contexts;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.remove = remove;\nexports._removeFromScope = _removeFromScope;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._remove = _remove;\nexports._markRemoved = _markRemoved;\nexports._assertUnremoved = _assertUnremoved;\n\nvar _removalHooks = require(\"./lib/removal-hooks\");\n\nvar _cache = require(\"../cache\");\n\nvar _index = require(\"./index\");\n\nfunction remove() {\n  var _this$opts;\n\n  this._assertUnremoved();\n\n  this.resync();\n\n  if (!((_this$opts = this.opts) == null ? void 0 : _this$opts.noScope)) {\n    this._removeFromScope();\n  }\n\n  if (this._callRemovalHooks()) {\n    this._markRemoved();\n\n    return;\n  }\n\n  this.shareCommentsWithSiblings();\n\n  this._remove();\n\n  this._markRemoved();\n}\n\nfunction _removeFromScope() {\n  const bindings = this.getBindingIdentifiers();\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\n\nfunction _callRemovalHooks() {\n  for (const fn of _removalHooks.hooks) {\n    if (fn(this, this.parentPath)) return true;\n  }\n}\n\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    this.updateSiblingKeys(this.key, -1);\n  } else {\n    this._replaceWith(null);\n  }\n}\n\nfunction _markRemoved() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;\n  if (this.parent) _cache.path.get(this.parent).delete(this.node);\n  this.node = null;\n}\n\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\"NodePath has been removed so is read-only.\");\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hooks = void 0;\nconst hooks = [function (self, parent) {\n  const removeParent = self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase()) || self.key === \"declaration\" && parent.isExportDeclaration() || self.key === \"body\" && parent.isLabeledStatement() || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === \"expression\" && parent.isExpressionStatement();\n\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && (self.key === \"consequent\" || self.key === \"alternate\") || self.key === \"body\" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: \"BlockStatement\",\n      body: []\n    });\n    return true;\n  }\n}];\nexports.hooks = hooks;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = _interopRequireDefault(require(\"./lib/hoister\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction insertBefore(nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [this.node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return t.isExpression(node) ? t.expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      let {\n        scope\n      } = this;\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: this.node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", t.cloneNode(temp), this.node)));\n      nodes.push(t.expressionStatement(t.cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [this.node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (nodes.constructor !== Array) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(nodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}"],"sourceRoot":""}