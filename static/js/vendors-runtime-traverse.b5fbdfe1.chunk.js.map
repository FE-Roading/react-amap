{"version":3,"sources":["../../node_modules/@babel/traverse/lib/index.js","../../node_modules/@babel/traverse/lib/path/index.js","../../node_modules/@babel/traverse/lib/cache.js","../../node_modules/@babel/traverse/lib/path/lib/virtual-types.js","../../node_modules/@babel/traverse/lib/scope/index.js","../../node_modules/@babel/traverse/lib/scope/binding.js","../../node_modules/@babel/traverse/lib/context.js","../../node_modules/@babel/traverse/lib/scope/lib/renamer.js","../../node_modules/@babel/traverse/lib/path/ancestry.js","../../node_modules/@babel/traverse/lib/path/inference/index.js","../../node_modules/@babel/traverse/lib/path/inference/inferers.js","../../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js","../../node_modules/@babel/traverse/lib/path/replacement.js","../../node_modules/@babel/traverse/lib/path/evaluation.js","../../node_modules/@babel/traverse/lib/path/conversion.js","../../node_modules/@babel/traverse/lib/path/introspection.js","../../node_modules/@babel/traverse/lib/path/context.js","../../node_modules/@babel/traverse/lib/path/removal.js","../../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js","../../node_modules/@babel/traverse/lib/path/modification.js","../../node_modules/@babel/traverse/lib/path/lib/hoister.js","../../node_modules/@babel/traverse/lib/path/family.js","../../node_modules/@babel/traverse/lib/path/comments.js","../../node_modules/@babel/traverse/lib/visitors.js","../../node_modules/@babel/traverse/lib/hub.js"],"names":["Object","defineProperty","exports","value","enumerable","get","_path","default","_scope","_hub","visitors","_context","require","t","cache","traverse","parent","opts","scope","state","parentPath","noScope","type","Error","VISITOR_KEYS","explode","node","_default","hasDenylistedType","path","has","stop","verify","cheap","enter","traverseFast","skipKeys","keys","context","key","visit","clearNode","removeProperties","delete","tree","hasType","denylistTypes","includes","denylist","SHOULD_SKIP","SHOULD_STOP","REMOVED","virtualTypes","_debug","_index","_cache","_generator","NodePath_ancestry","NodePath_inference","NodePath_replacement","NodePath_evaluation","NodePath_conversion","NodePath_introspection","NodePath_context","NodePath_removal","NodePath_modification","NodePath_family","NodePath_comments","debug","NodePath","hub","this","contexts","_traverseFlags","container","listKey","data","isScope","val","create","def","undefined","msg","SyntaxError","buildError","visitor","validate","parts","inList","unshift","join","message","enabled","getPathLocation","code","v","targetNode","paths","Map","set","setup","assign","prototype","TYPES","typeKey","fn","TypeError","indexOf","push","virtualType","checkPath","clear","clearPath","clearScope","WeakMap","ForAwaitStatement","NumericLiteralTypeAnnotation","ExistentialTypeParam","SpreadProperty","RestProperty","Flow","Pure","Generated","User","Var","BlockScoped","Referenced","Scope","Expression","Statement","BindingIdentifier","ReferencedMemberExpression","ReferencedIdentifier","types","isIdentifier","isJSXMemberExpression","isJSXIdentifier","react","isCompatTag","name","isReferenced","isMemberExpression","grandparent","isBinding","isStatement","isVariableDeclaration","isForXStatement","left","isForStatement","init","isReferencedIdentifier","isExpression","isBlockScoped","isVar","loc","isUser","isPure","isFlow","isImportDeclaration","importKind","isExportDeclaration","exportKind","isImportSpecifier","isObjectPattern","isObjectExpression","await","_renamer","_binding","_globals","gatherNodeParts","isModuleDeclaration","isExportAllDeclaration","isExportNamedDeclaration","source","specifiers","length","isExportDefaultDeclaration","declaration","isModuleSpecifier","local","isLiteral","object","property","callee","properties","argument","id","expression","meta","openingElement","openingFragment","namespace","collectorVisitor","For","FOR_INIT_KEYS","declar","getFunctionParent","getProgramParent","registerBinding","Declaration","registerDeclaration","ImportDeclaration","getBlockParent","references","ForXStatement","isPattern","constantViolations","ExportDeclaration","exit","isClassDeclaration","isFunctionDeclaration","binding","getBinding","reference","declarations","decl","getBindingIdentifiers","LabeledStatement","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","bindings","CatchClause","Function","isFunctionExpression","NOT_LOCAL_BINDING","params","param","ClassExpression","uid","block","labels","inited","globals","uids","crawling","cached","_parent","isKey","isMethod","generateUidIdentifier","cloneNode","identifier","generateUid","toIdentifier","replace","i","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","defaultName","slice","generateUidBasedOnNode","isThisExpression","isSuper","constant","dontPush","isStatic","generateUidIdentifierBasedOnNode","kind","oldName","newName","rename","map","sep","repeat","console","log","violations","arrayLikeIsIterable","isGenericType","isArrayExpression","callExpression","memberExpression","helperName","args","numericLiteral","addHelper","getLabel","label","isLabeledStatement","registerLabel","specifier","unaryExpression","ids","reassign","bindingPath","ReferenceError","declarators","getOuterBindingIdentifiers","getOwnBinding","checkBlockScopedCollisions","registerConstantViolation","constantsOnly","isClass","superClass","body","isClassBody","method","isBinary","right","elements","elem","prop","computed","isProperty","isUnaryExpression","isTaggedTemplateExpression","matchesPattern","tag","quasi","isTemplateLiteral","expressions","isPureish","crawl","programParent","_exploded","typeVisitors","addGlobal","ref","isBlockStatement","isProgram","isSwitchStatement","isLoop","isCatchClause","isFunction","ensureBlock","unique","blockHoist","_blockHoist","dataKey","declarPath","getData","variableDeclaration","unshiftContainer","setData","declarator","variableDeclarator","pop","isFunctionParent","isBlockParent","kinds","getBindingIdentifier","previousPath","_previousPath","_this$getBinding","noGlobals","hasOwnBinding","parentHasBinding","hasUid","contextVariables","_this$parent","info","removeOwnBinding","_this$getBinding2","builtin","Binding","referencePaths","referenced","clearValue","hasDeoptedValue","hasValue","TraversalContext","queue","priorityQueue","obj","notPriority","shouldVisit","visitQueue","visited","WeakSet","resync","pushContext","add","popContext","nodes","Array","isArray","visitMultiple","visitSingle","_helperSplitExportDeclaration","renameVisitor","bindingIdentifierEquals","skip","skipKey","skipAllButComputedMethodKey","Renamer","parentDeclar","maybeExportDeclar","find","isDeclaration","isClassExpression","maybeConvertFromExportDeclaration","blockToTraverse","cases","forEach","c","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","findParent","callback","p","getStatementParent","isFile","getEarliestCommonAncestorFrom","getDeepestCommonAncestorFrom","deepest","ancestries","earliest","parentKey","filter","lastCommonIndex","lastCommon","minDepth","Infinity","ancestry","first","depthLoop","shouldMatch","getAncestry","isAncestor","maybeDescendant","isDescendant","maybeAncestor","inType","candidateTypes","getTypeAnnotation","typeAnnotation","_getTypeAnnotation","anyTypeAnnotation","isTypeAnnotation","isVariableDeclarator","declarParent","isForInStatement","stringTypeAnnotation","isForOfStatement","voidTypeAnnotation","typeAnnotationInferringNodes","_inferer","inferer","inferers","call","validParent","isBaseType","baseName","soft","_isBaseType","couldBeBaseType","isAnyTypeAnnotation","isUnionTypeAnnotation","type2","baseTypeStrictlyMatches","rightArg","isFlowBaseAnnotation","genericName","isGenericTypeAnnotation","isStringTypeAnnotation","isNumberTypeAnnotation","isBooleanTypeAnnotation","isMixedTypeAnnotation","isEmptyTypeAnnotation","isVoidTypeAnnotation","VariableDeclarator","_type","isCallExpression","ArrayExpression","TypeCastExpression","NewExpression","genericTypeAnnotation","TemplateLiteral","NUMBER_UNARY_OPERATORS","numberTypeAnnotation","STRING_UNARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","booleanTypeAnnotation","BinaryExpression","NUMBER_BINARY_OPERATORS","BOOLEAN_BINARY_OPERATORS","unionTypeAnnotation","LogicalExpression","argumentTypes","isTSTypeAnnotation","createTSUnionType","createFlowUnionType","createUnionTypeAnnotation","ConditionalExpression","SequenceExpression","ParenthesizedExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","nullLiteralTypeAnnotation","RegExpLiteral","ObjectExpression","RestElement","ClassDeclaration","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","CallExpression","isObjectKeys","arrayTypeAnnotation","isArrayFrom","isObjectValues","isObjectEntries","tupleTypeAnnotation","resolveCall","TaggedTemplateExpression","_infererReference","buildMatchMemberExpression","resolve","is","returnType","functionConstantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","concat","violation","getTypeAnnotationBindingConstantViolations","functions","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","target","typeofPath","typePath","BOOLEAN_NUMBER_BINARY_OPERATORS","typeValue","createTypeAnnotationBasedOnTypeof","isIfStatement","isConditionalExpression","getParentConditionalPath","isLogicalExpression","isBinaryExpression","replaceWithMultiple","_pathCache$get","_verifyNodeList","inheritLeadingComments","inheritTrailingComments","insertAfter","requeue","remove","replaceWithSourceString","replacement","_parser","parse","err","_codeFrame","codeFrameColumns","start","line","column","replaceWith","removed","_index2","nodePath","isNodeType","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","expressionStatement","replaceExpressionWithStatements","oldNode","inheritsComments","removeComments","_replaceWith","setScope","_pathCache$get2","toSequenceExpression","functionParent","isParentAsync","isParentGenerator","arrowFunctionExpression","blockStatement","_helperHoistVariables","completionRecords","getCompletionRecords","isExpressionStatement","loop","generateDeclaredUidIdentifier","pushContainer","returnStatement","assignmentExpression","arrowFunctionToExpression","newCallee","needToAwaitFunction","FUNCTION_TYPES","needToYieldFunction","awaitExpression","yieldExpression","replaceInline","_containerInsertAfter","evaluateTruthy","res","evaluate","confident","deoptPath","seen","evaluateCached","deopt","VALID_CALLEES","INVALID_METHODS","existing","resolved","item","isSequenceExpression","exprs","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","evaluateQuasis","quasis","testResult","isExpressionWrapper","end","NaN","prefix","arg","arr","elems","elemValue","props","isObjectMethod","isSpreadElement","wasConfident","leftConfident","rightConfident","Math","pow","func","global","apply","_evaluate","raw","str","cooked","expr","String","toComputedKey","stringLiteral","bodyNode","statements","stringPath","arrowFunctionToShadowed","isArrowFunctionExpression","unwrapFunctionEnvironment","buildCodeFrameError","hoistFunctionEnvironment","allowInsertArrow","specCompliant","noNewArrows","thisBinding","checkBinding","objectExpression","thisExpression","_helperFunctionName","fnPath","thisEnvFn","isClassProperty","static","inConstructor","getScopeInformation","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","allSuperCalls","child","ClassProperty","superBinding","getSuperBinding","superCall","argumentsBinding","conditionalExpression","binaryExpression","buildUndefinedNode","argumentsChild","argsRef","newTargetBinding","metaProperty","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","standardizeSuperProperty","isAssignment","isAssignmentExpression","isCall","getSuperPropBinding","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","jsxIdentifier","assignmentPath","op","tmp","isUpdateExpression","updateExpr","computedKey","sequenceExpression","isClassMethod","supers","argsBinding","restElement","super","spreadElement","propName","fnBody","argsList","valueIdent","cacheKey","ThisExpression","JSXIdentifier","isJSXOpeningElement","MemberExpression","curr","MetaProperty","pattern","allowPartial","isnt","equals","isType","isFor","isCompletionRecord","allowInsideFunction","isStatementOrBlock","STATEMENT_OR_BLOCK_KEYS","referencesImport","moduleSource","importName","isOptionalMemberExpression","isImportDefaultSpecifier","isImportNamespaceSpecifier","imported","getSource","getCode","willIMaybeExecuteBefore","funcParent","getOuterFunction","_guessExecutionStatusRelativeToDifferentFunctions","commonPath","commonIndex","isExecutionUncertainInList","divergence","keyPosition","allStatus","executionOrderCheckedNodes","dangerous","_resolve","ret","isTypeCastExpression","targetKey","targetName","match","isNaN","isConstantExpression","isRegExpLiteral","every","isInStrictMode","sourceType","directives","isExecutionUncertain","maxIndex","_call","fns","then","isBlacklisted","isDenylisted","_this$opts$denylist","blacklist","shouldSkip","shouldStop","getScope","setContext","_resyncParent","_resyncList","_resyncKey","setKey","newContainer","_resyncRemoved","_markRemoved","_this$node","pathToQueue","maybeQueue","_getQueueContexts","_this$opts","_assertUnremoved","_removeFromScope","_callRemovalHooks","shareCommentsWithSiblings","_remove","removeBinding","_removalHooks","hooks","splice","updateSiblingKeys","self","isWhile","isSwitchCase","insertBefore","nodes_","isJSXElement","_containerInsertBefore","shouldInsertCurrentNode","_containerInsert","from","to","getSibling","assertExpression","temp","fromIndex","incrementBy","verifiedNodes","hoist","hoister","_hoister","run","referenceVisitor","breakOnScopePaths","mutableBinding","PathHoister","scopes","attachAfter","isCompatibleScope","_getAttachmentPath","targetScope","getAttachmentParentForPath","violationPath","hasOwnParamBindings","getNextScopeAttachmentParent","bodies","getCompatibleScopes","attachTo","getAttachmentPath","attached","children","jsxExpressionContainer","getOpposite","_getCompletionRecords","canHaveBreak","shouldPopulateBreak","inCaseClause","r","getPrevSibling","getNextSibling","getAllNextSiblings","_key","sibling","siblings","getAllPrevSiblings","split","_getKey","_getPattern","_","part","duplicates","getBindingIdentifierPaths","outerOnly","search","shift","_ids","getOuterBindingIdentifierPaths","addCompletionRecords","records","normalCompletionToBreak","completions","replaceBreakStatementInBreakCompletion","reachable","isBreakStatement","getStatementListCompletion","lastNormalCompletions","newContext","statementCompletions","some","pathCompletions","isDoExpression","isTryStatement","caseCompletions","normalCompletions","breakCompletions","completionRecordForSwitch","BreakCompletion","NormalCompletion","trailing","trailingComments","leading","leadingComments","prev","next","hasPrev","Boolean","hasNext","addComments","addComment","content","comments","merge","states","wrapper","rootVisitor","visitorType","wrapWithStateOrWrapper","nodeVisitor","mergePair","nodeType","shouldIgnoreKey","__esModule","ensureEntranceObjects","ensureCallbackArrays","wrapCheck","aliases","FLIPPED_ALIAS_KEYS","deprecatedKey","DEPRECATED_KEYS","trace","alias","_verified","validateVisitorMethods","visitorKey","oldVisitor","newVisitor","newFn","toString","arguments","dest","src","Hub"],"mappings":"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","file":"static/js/vendors-runtime-traverse.b5fbdfe1.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"NodePath\", {\n  enumerable: true,\n  get: function () {\n    return _path.default;\n  }\n});\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return _scope.default;\n  }\n});\nObject.defineProperty(exports, \"Hub\", {\n  enumerable: true,\n  get: function () {\n    return _hub.default;\n  }\n});\nexports.visitors = exports.default = void 0;\n\nvar _context = require(\"./context\");\n\nvar visitors = require(\"./visitors\");\n\nexports.visitors = visitors;\n\nvar t = require(\"@babel/types\");\n\nvar cache = require(\"./cache\");\n\nvar _path = require(\"./path\");\n\nvar _scope = require(\"./scope\");\n\nvar _hub = require(\"./hub\");\n\nfunction traverse(parent, opts = {}, scope, state, parentPath) {\n  if (!parent) return;\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\"You must pass a scope and parentPath unless traversing a Program/File. \" + `Instead of that you tried to traverse a ${parent.type} node without ` + \"passing scope and parentPath.\");\n    }\n  }\n\n  if (!t.VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts);\n  traverse.node(parent, opts, scope, state, parentPath);\n}\n\nvar _default = traverse;\nexports.default = _default;\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node, enter) {\n  return t.traverseFast(node, enter);\n};\n\ntraverse.node = function (node, opts, scope, state, parentPath, skipKeys) {\n  const keys = t.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  const context = new _context.default(scope, opts, state, parentPath);\n\n  for (const key of keys) {\n    if (skipKeys && skipKeys[key]) continue;\n    if (context.visit(node, key)) return;\n  }\n};\n\ntraverse.clearNode = function (node, opts) {\n  t.removeProperties(node, opts);\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (tree, opts) {\n  t.traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\nfunction hasDenylistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (tree, type, denylistTypes) {\n  if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;\n  if (tree.type === type) return true;\n  const state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    noScope: true,\n    denylist: denylistTypes,\n    enter: hasDenylistedType\n  }, null, state);\n  return state.has;\n};\n\ntraverse.cache = cache;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SHOULD_SKIP = exports.SHOULD_STOP = exports.REMOVED = void 0;\n\nvar virtualTypes = require(\"./lib/virtual-types\");\n\nvar _debug = require(\"debug\");\n\nvar _index = require(\"../index\");\n\nvar _scope = require(\"../scope\");\n\nvar t = require(\"@babel/types\");\n\nvar _cache = require(\"../cache\");\n\nvar _generator = require(\"@babel/generator\");\n\nvar NodePath_ancestry = require(\"./ancestry\");\n\nvar NodePath_inference = require(\"./inference\");\n\nvar NodePath_replacement = require(\"./replacement\");\n\nvar NodePath_evaluation = require(\"./evaluation\");\n\nvar NodePath_conversion = require(\"./conversion\");\n\nvar NodePath_introspection = require(\"./introspection\");\n\nvar NodePath_context = require(\"./context\");\n\nvar NodePath_removal = require(\"./removal\");\n\nvar NodePath_modification = require(\"./modification\");\n\nvar NodePath_family = require(\"./family\");\n\nvar NodePath_comments = require(\"./comments\");\n\nconst debug = _debug(\"babel\");\n\nconst REMOVED = 1 << 0;\nexports.REMOVED = REMOVED;\nconst SHOULD_STOP = 1 << 1;\nexports.SHOULD_STOP = SHOULD_STOP;\nconst SHOULD_SKIP = 1 << 2;\nexports.SHOULD_SKIP = SHOULD_SKIP;\n\nclass NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key\n  }) {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode = container[key];\n\n    let paths = _cache.path.get(parent);\n\n    if (!paths) {\n      paths = new Map();\n\n      _cache.path.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  }\n\n  getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  }\n\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    return this.data[key] = val;\n  }\n\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  buildCodeFrameError(msg, Error = SyntaxError) {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key, node) {\n    t.validate(this.node, key, node);\n    this.node[key] = node;\n  }\n\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  }\n\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n\n}\n\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n\n  NodePath.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === \"_\") continue;\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n  const virtualType = virtualTypes[type];\n\n  NodePath.prototype[`is${type}`] = function (opts) {\n    return virtualType.checkPath(this, opts);\n  };\n}\n\nvar _default = NodePath;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clear = clear;\nexports.clearPath = clearPath;\nexports.clearScope = clearScope;\nexports.scope = exports.path = void 0;\nlet path = new WeakMap();\nexports.path = path;\nlet scope = new WeakMap();\nexports.scope = scope;\n\nfunction clear() {\n  clearPath();\n  clearScope();\n}\n\nfunction clearPath() {\n  exports.path = path = new WeakMap();\n}\n\nfunction clearScope() {\n  exports.scope = scope = new WeakMap();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar t = require(\"@babel/types\");\n\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {\n      if (t.isJSXIdentifier(node, opts)) {\n        if (t.react.isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return t.isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return t.isMemberExpression(node) && t.isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (t.isStatement(node)) {\n      if (t.isVariableDeclaration(node)) {\n        if (t.isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (t.isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t.isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return t.isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return t.isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return t.isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return t.isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (t.isFlow(node)) {\n      return true;\n    } else if (t.isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t.isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (t.isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = require(\"./lib/renamer\");\n\nvar _index = require(\"../index\");\n\nvar _binding = require(\"./binding\");\n\nvar _globals = require(\"globals\");\n\nvar t = require(\"@babel/types\");\n\nvar _cache = require(\"../cache\");\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (t.isModuleDeclaration(node)) {\n        if ((t.isExportAllDeclaration(node) || t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((t.isExportDefaultDeclaration(node) || t.isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (t.isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (t.isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  For(path) {\n    for (const key of t.FOR_INIT_KEYS) {\n      const declar = path.get(key);\n\n      if (declar.isVar()) {\n        const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        parentScope.registerBinding(\"var\", declar);\n      }\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isImportDeclaration()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ImportDeclaration(path) {\n    const parent = path.scope.getBlockParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (t.isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        if (binding) binding.reference(path);\n      } else if (t.isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(t.getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            if (binding) binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const isKey = path.key === \"key\";\n      path = path.parentPath;\n      if (isKey && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return t.cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return t.identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = t.toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return t.identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (t.isThisExpression(node) || t.isSuper(node)) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return t.cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (t.isArrayExpression(node)) {\n      return node;\n    }\n\n    if (t.isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(\"Array\"), t.identifier(\"prototype\")), t.identifier(\"slice\")), t.identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(t.numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return t.callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return t.unaryExpression(\"void\", t.numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (t.isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (t.isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (t.isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (t.isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (t.isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (t.isTaggedTemplateExpression(node)) {\n      return t.matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (t.isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return t.isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = t.variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = t.variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind(...kinds) {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\") {} else {\n          return binding;\n        }\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Binding {\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind\n  }) {\n    this.identifier = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.kind = void 0;\n    this.constantViolations = [];\n    this.constant = true;\n    this.referencePaths = [];\n    this.referenced = false;\n    this.references = 0;\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n    this.clearValue();\n  }\n\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n\n  setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n\n  reassign(path) {\n    this.constant = false;\n\n    if (this.constantViolations.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.constantViolations.push(path);\n  }\n\n  reference(path) {\n    if (this.referencePaths.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n\n}\n\nexports.default = Binding;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = require(\"./path\");\n\nvar t = require(\"@babel/types\");\n\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.priorityQueue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = t.VISITOR_KEYS[node.type];\n    if (!(keys != null && keys.length)) return false;\n\n    for (const key of keys) {\n      if (node[key]) return true;\n    }\n\n    return false;\n  }\n\n  create(node, obj, key, listKey) {\n    return _path.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey\n    });\n  }\n\n  maybeQueue(path, notPriority) {\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n\n    for (const path of queue) {\n      path.resync();\n\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        path.pushContext(this);\n      }\n\n      if (path.key === null) continue;\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    for (const path of queue) {\n      path.popContext();\n    }\n\n    this.queue = null;\n    return stop;\n  }\n\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n\n}\n\nexports.default = TraversalContext;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = require(\"../binding\");\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nvar t = require(\"@babel/types\");\n\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      skipAllButComputedMethodKey(path);\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = t.identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(t.identifier(this.newName), t.toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = t.identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: t.identifier(this.newName)\n    });\n    path.replaceWith(t.assignmentExpression(\"=\", t.identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;\n\nfunction skipAllButComputedMethodKey(path) {\n  if (!path.isMethod() || !path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = t.VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findParent = findParent;\nexports.find = find;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getAncestry = getAncestry;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\nexports.inType = inType;\n\nvar t = require(\"@babel/types\");\n\nvar _index = require(\"./index\");\n\nfunction findParent(callback) {\n  let path = this;\n\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n\n  return null;\n}\n\nfunction find(callback) {\n  let path = this;\n\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n\n  return null;\n}\n\nfunction getFunctionParent() {\n  return this.findParent(p => p.isFunction());\n}\n\nfunction getStatementParent() {\n  let path = this;\n\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\"File/Program node, we can't possibly find a statement parent to this\");\n  }\n\n  return path;\n}\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    let earliest;\n    const keys = t.VISITOR_KEYS[deepest.type];\n\n    for (const ancestry of ancestries) {\n      const path = ancestry[i + 1];\n\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      if (path.listKey && earliest.listKey === path.listKey) {\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      const currentKeyIndex = keys.indexOf(path.parentKey);\n\n      if (earliestKeyIndex > currentKeyIndex) {\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  let minDepth = Infinity;\n  let lastCommonIndex, lastCommon;\n  const ancestries = paths.map(path => {\n    const ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n  const first = ancestries[0];\n\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        break depthLoop;\n      }\n    }\n\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\nfunction getAncestry() {\n  let path = this;\n  const paths = [];\n\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n\n  return paths;\n}\n\nfunction isAncestor(maybeDescendant) {\n  return maybeDescendant.isDescendant(this);\n}\n\nfunction isDescendant(maybeAncestor) {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\n\nfunction inType(...candidateTypes) {\n  let path = this;\n\n  while (path) {\n    for (const type of candidateTypes) {\n      if (path.node.type === type) return true;\n    }\n\n    path = path.parentPath;\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypeAnnotation = getTypeAnnotation;\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.couldBeBaseType = couldBeBaseType;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.isGenericType = isGenericType;\n\nvar inferers = require(\"./inferers\");\n\nvar t = require(\"@babel/types\");\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n  let type = this._getTypeAnnotation() || t.anyTypeAnnotation();\n  if (t.isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\nconst typeAnnotationInferringNodes = new WeakSet();\n\nfunction _getTypeAnnotation() {\n  const node = this.node;\n\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return t.stringTypeAnnotation();\n      }\n\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return t.anyTypeAnnotation();\n      }\n\n      return t.voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    var _inferer;\n\n    let inferer = inferers[node.type];\n\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    inferer = inferers[this.parentPath.type];\n\n    if ((_inferer = inferer) != null && _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return t.isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return t.isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return t.isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return t.isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return t.isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return t.isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return t.isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (t.isAnyTypeAnnotation(type)) return true;\n\n  if (t.isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(rightArg) {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n\n  if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n\n  return false;\n}\n\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n  return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, {\n    name: genericName\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariableDeclarator = VariableDeclarator;\nexports.TypeCastExpression = TypeCastExpression;\nexports.NewExpression = NewExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.UnaryExpression = UnaryExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.StringLiteral = StringLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.NullLiteral = NullLiteral;\nexports.RegExpLiteral = RegExpLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ArrayExpression = ArrayExpression;\nexports.RestElement = RestElement;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nexports.CallExpression = CallExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\n\nvar t = require(\"@babel/types\");\n\nvar _infererReference = require(\"./inferer-reference\");\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return t.genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return t.voidTypeAnnotation();\n  } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.stringTypeAnnotation();\n  } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return t.numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return t.stringTypeAnnotation();\n    }\n\n    return t.unionTypeAnnotation([t.stringTypeAnnotation(), t.numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return t.numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return t.numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return t.booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return t.nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return t.genericTypeAnnotation(t.identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return t.genericTypeAnnotation(t.identifier(\"Function\"));\n}\n\nconst isArrayFrom = t.buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = t.buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = t.buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = t.buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return t.arrayTypeAnnotation(t.stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return t.arrayTypeAnnotation(t.anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return t.arrayTypeAnnotation(t.tupleTypeAnnotation([t.stringTypeAnnotation(), t.anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return t.genericTypeAnnotation(t.identifier(\"AsyncIterator\"));\n      } else {\n        return t.genericTypeAnnotation(t.identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar t = require(\"@babel/types\");\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(types);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(types);\n  }\n\n  return t.createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return t.createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n      return {\n        typeAnnotation: t.createTSUnionType(types),\n        ifStatement\n      };\n    }\n\n    if (t.createFlowUnionType) {\n      return {\n        typeAnnotation: t.createFlowUnionType(types),\n        ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\nexports.replaceWith = replaceWith;\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = require(\"../index\");\n\nvar _index2 = require(\"./index\");\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar t = require(\"@babel/types\");\n\nvar _helperHoistVariables = require(\"@babel/helper-hoist-variables\");\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  t.inheritLeadingComments(nodes[0], this.node);\n  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = `(${replacement})`;\n    replacement = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n\n  _index.default.removeProperties(replacement);\n\n  return this.replaceWith(replacement);\n}\n\nfunction replaceWith(replacement) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index2.default) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !t.isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && t.isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = t.expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && t.isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    t.inheritsComments(replacement, oldNode);\n    t.removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    t.validate(this.parent, this.key, [node]);\n  } else {\n    t.validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const toSequenceExpression = t.toSequenceExpression(nodes, this.scope);\n\n  if (toSequenceExpression) {\n    return this.replaceWith(toSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const isParentGenerator = functionParent == null ? void 0 : functionParent.is(\"generator\");\n  const container = t.arrowFunctionExpression([], t.blockStatement(nodes));\n  this.replaceWith(t.callExpression(container, []));\n  const callee = this.get(\"callee\");\n  (0, _helperHoistVariables.default)(callee.get(\"body\"), id => {\n    this.scope.push({\n      id\n    });\n  }, \"var\");\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", t.returnStatement(t.cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = t.identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(t.assignmentExpression(\"=\", t.cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(t.returnStatement(path.node.expression));\n    }\n  }\n\n  callee.arrowFunctionToExpression();\n  const newCallee = callee;\n\n  const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", t.FUNCTION_TYPES);\n\n  const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get(\"callee.body\").node, \"YieldExpression\", t.FUNCTION_TYPES);\n\n  if (needToAwaitFunction) {\n    newCallee.set(\"async\", true);\n\n    if (!needToYieldFunction) {\n      this.replaceWith(t.awaitExpression(this.node));\n    }\n  }\n\n  if (needToYieldFunction) {\n    newCallee.set(\"generator\", true);\n    this.replaceWith(t.yieldExpression(this.node, true));\n  }\n\n  return newCallee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding != null && binding.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toComputedKey = toComputedKey;\nexports.ensureBlock = ensureBlock;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\n\nvar t = require(\"@babel/types\");\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nfunction toComputedKey() {\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!this.node.computed) {\n    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(t.returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(t.expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = t.blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  specCompliant = false,\n  noNewArrows = !specCompliant\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const thisBinding = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);\n  this.ensureBlock();\n  this.node.type = \"FunctionExpression\";\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      this.parentPath.scope.push({\n        id: checkBinding,\n        init: t.objectExpression([])\n      });\n    }\n\n    this.get(\"body\").unshiftContainer(\"body\", t.expressionStatement(t.callExpression(this.hub.addHelper(\"newArrowCheck\"), [t.thisExpression(), checkBinding ? t.identifier(checkBinding.name) : t.identifier(thisBinding)])));\n    this.replaceWith(t.callExpression(t.memberExpression((0, _helperFunctionName.default)(this, true) || this.node, t.identifier(\"bind\")), [checkBinding ? t.identifier(checkBinding.name) : t.thisExpression()]));\n  }\n}\n\nfunction hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true) {\n  const thisEnvFn = fnPath.findParent(p => {\n    return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({\n      static: false\n    });\n  });\n  const inConstructor = (thisEnvFn == null ? void 0 : thisEnvFn.node.kind) === \"constructor\";\n\n  if (thisEnvFn.isClassProperty()) {\n    throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        allSuperCalls.push(child);\n      }\n\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = t.identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => {\n      const args = () => t.identifier(\"arguments\");\n\n      if (thisEnvFn.scope.path.isProgram()) {\n        return t.conditionalExpression(t.binaryExpression(\"===\", t.unaryExpression(\"typeof\", args()), t.stringLiteral(\"undefined\")), thisEnvFn.scope.buildUndefinedNode(), args());\n      } else {\n        return args();\n      }\n    });\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = t.identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => t.metaProperty(t.identifier(\"new\"), t.identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = t.identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = t.callExpression(t.identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", t.thisExpression());\n        superProp.replaceWith(t.memberExpression(call, t.identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? t.jsxIdentifier(thisBinding) : t.identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return thisBinding;\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    assignmentPath.node.operator = \"=\";\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, t.assignmentExpression(\"=\", tmp, superProp.node.property), true));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(tmp.name), true), value));\n    } else {\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, superProp.node.property));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(superProp.node.property.name)), value));\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [t.assignmentExpression(\"=\", tmp, t.memberExpression(superProp.node.object, computedKey ? t.assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), t.assignmentExpression(\"=\", t.memberExpression(superProp.node.object, computedKey ? t.identifier(computedKey.name) : superProp.node.property, superProp.node.computed), t.binaryExpression(\"+\", t.identifier(tmp.name), t.numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(t.identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(t.sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return t.thisExpression();\n    const supers = new WeakSet();\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        if (supers.has(child.node)) return;\n        supers.add(child.node);\n        child.replaceWithMultiple([child.node, t.assignmentExpression(\"=\", t.identifier(thisBinding), t.identifier(\"this\"))]);\n      }\n\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return t.arrowFunctionExpression([t.restElement(argsBinding)], t.callExpression(t.super(), [t.spreadElement(t.identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = t.memberExpression(t.super(), t.identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = t.memberExpression(t.super(), t.identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = t.assignmentExpression(\"=\", fnBody, t.identifier(valueIdent.name));\n    }\n\n    return t.arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse({\n    ClassProperty(child) {\n      child.skip();\n    },\n\n    Function(child) {\n      if (child.isArrowFunctionExpression()) return;\n      child.skip();\n    },\n\n    ThisExpression(child) {\n      thisPaths.push(child);\n    },\n\n    JSXIdentifier(child) {\n      if (child.node.name !== \"this\") return;\n\n      if (!child.parentPath.isJSXMemberExpression({\n        object: child.node\n      }) && !child.parentPath.isJSXOpeningElement({\n        name: child.node\n      })) {\n        return;\n      }\n\n      thisPaths.push(child);\n    },\n\n    CallExpression(child) {\n      if (child.get(\"callee\").isSuper()) superCalls.push(child);\n    },\n\n    MemberExpression(child) {\n      if (child.get(\"object\").isSuper()) superProps.push(child);\n    },\n\n    ReferencedIdentifier(child) {\n      if (child.node.name !== \"arguments\") return;\n      let curr = child.scope;\n\n      do {\n        if (curr.hasOwnBinding(\"arguments\")) {\n          curr.rename(\"arguments\");\n          return;\n        }\n\n        if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (curr = curr.parent);\n\n      argumentsPaths.push(child);\n    },\n\n    MetaProperty(child) {\n      if (!child.get(\"meta\").isIdentifier({\n        name: \"new\"\n      })) return;\n      if (!child.get(\"property\").isIdentifier({\n        name: \"target\"\n      })) return;\n      newTargetPaths.push(child);\n    }\n\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchesPattern = matchesPattern;\nexports.has = has;\nexports.isStatic = isStatic;\nexports.isnt = isnt;\nexports.equals = equals;\nexports.isNodeType = isNodeType;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.referencesImport = referencesImport;\nexports.getSource = getSource;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;\nexports.resolve = resolve;\nexports._resolve = _resolve;\nexports.isConstantExpression = isConstantExpression;\nexports.isInStrictMode = isInStrictMode;\nexports.is = void 0;\n\nvar t = require(\"@babel/types\");\n\nfunction matchesPattern(pattern, allowPartial) {\n  return t.matchesPattern(this.node, pattern, allowPartial);\n}\n\nfunction has(key) {\n  const val = this.node && this.node[key];\n\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\n\nconst is = has;\nexports.is = is;\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\nfunction isNodeType(type) {\n  return t.isType(this.type, type);\n}\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return t.isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return t.isExpression(replacement);\n  }\n\n  return false;\n}\n\nfunction isCompletionRecord(allowInsideFunction) {\n  let path = this;\n  let first = true;\n\n  do {\n    const container = path.container;\n\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return t.STATEMENT_OR_BLOCK_KEYS.includes(this.key);\n  }\n}\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) {\n    if ((this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? t.isStringLiteral(this.node.property, {\n      value: importName\n    }) : this.node.property.name === importName)) {\n      const object = this.get(\"object\");\n      return object.isReferencedIdentifier() && object.referencesImport(moduleSource, \"*\");\n    }\n\n    return false;\n  }\n\n  const binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && t.isIdentifier(path.node.imported, {\n    name: importName\n  })) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getSource() {\n  const node = this.node;\n\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n\n  return \"\";\n}\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path) {\n  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;\n}\n\nfunction isExecutionUncertain(type, key) {\n  switch (type) {\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths, maxIndex) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  const funcParent = {\n    this: getOuterFunction(this),\n    target: getOuterFunction(target)\n  };\n\n  if (funcParent.target.node !== funcParent.this.node) {\n    return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: this.getAncestry()\n  };\n  if (paths.target.indexOf(this) >= 0) return \"after\";\n  if (paths.this.indexOf(target) >= 0) return \"before\";\n  let commonPath;\n  const commonIndex = {\n    target: 0,\n    this: 0\n  };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\"Internal Babel error - The two compared nodes\" + \" don't appear to belong to the same program.\");\n  }\n\n  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1]\n  };\n\n  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  const keys = t.VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey)\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\nconst executionOrderCheckedNodes = new WeakSet();\n\nfunction _guessExecutionStatusRelativeToDifferentFunctions(target) {\n  if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {\n    return \"unknown\";\n  }\n\n  const binding = target.scope.getBinding(target.node.id.name);\n  if (!binding.references) return \"before\";\n  const referencePaths = binding.referencePaths;\n  let allStatus;\n\n  for (const path of referencePaths) {\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      return \"unknown\";\n    }\n\n    if (executionOrderCheckedNodes.has(path.node)) continue;\n    executionOrderCheckedNodes.add(path.node);\n\n    const status = this._guessExecutionStatusRelativeTo(path);\n\n    executionOrderCheckedNodes.delete(path.node);\n\n    if (allStatus && allStatus !== status) {\n      return \"unknown\";\n    } else {\n      allStatus = status;\n    }\n  }\n\n  return allStatus;\n}\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nfunction _resolve(dangerous, resolved) {\n  if (resolved && resolved.indexOf(this) >= 0) return;\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {}\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n    if (!binding.constant) return;\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    const targetKey = this.toComputedKey();\n    if (!t.isLiteral(targetKey)) return;\n    const targetName = targetKey.value;\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n\n      for (const prop of props) {\n        if (!prop.isProperty()) continue;\n        const key = prop.get(\"key\");\n        let match = prop.isnt(\"computed\") && key.isIdentifier({\n          name: targetName\n        });\n        match = match || key.isLiteral({\n          value: targetName\n        });\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nfunction isConstantExpression() {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression => expression.isConstantExpression());\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.node.operator !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    return this.get(\"left\").isConstantExpression() && this.get(\"right\").isConstantExpression();\n  }\n\n  return false;\n}\n\nfunction isInStrictMode() {\n  const start = this.isProgram() ? this : this.parentPath;\n  const strictParent = start.find(path => {\n    if (path.isProgram({\n      sourceType: \"module\"\n    })) return true;\n    if (path.isClass()) return true;\n    if (!path.isProgram() && !path.isFunction()) return false;\n\n    if (path.isArrowFunctionExpression() && !path.get(\"body\").isBlockStatement()) {\n      return false;\n    }\n\n    const body = path.isFunction() ? path.node.body : path.node;\n\n    for (const directive of body.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n  return !!strictParent;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.call = call;\nexports._call = _call;\nexports.isBlacklisted = exports.isDenylisted = isDenylisted;\nexports.visit = visit;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.setScope = setScope;\nexports.setContext = setContext;\nexports.resync = resync;\nexports._resyncParent = _resyncParent;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncRemoved = _resyncRemoved;\nexports.popContext = popContext;\nexports.pushContext = pushContext;\nexports.setup = setup;\nexports.setKey = setKey;\nexports.requeue = requeue;\nexports._getQueueContexts = _getQueueContexts;\n\nvar _index = require(\"../index\");\n\nvar _index2 = require(\"./index\");\n\nfunction call(key) {\n  const opts = this.opts;\n  this.debug(key);\n\n  if (this.node) {\n    if (this._call(opts[key])) return true;\n  }\n\n  if (this.node) {\n    return this._call(opts[this.node.type] && opts[this.node.type][key]);\n  }\n\n  return false;\n}\n\nfunction _call(fns) {\n  if (!fns) return false;\n\n  for (const fn of fns) {\n    if (!fn) continue;\n    const node = this.node;\n    if (!node) return true;\n    const ret = fn.call(this.state, this, this.state);\n\n    if (ret && typeof ret === \"object\" && typeof ret.then === \"function\") {\n      throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n    }\n\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n\n    if (this.node !== node) return true;\n    if (this._traverseFlags > 0) return true;\n  }\n\n  return false;\n}\n\nfunction isDenylisted() {\n  var _this$opts$denylist;\n\n  const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;\n  return denylist && denylist.indexOf(this.node.type) > -1;\n}\n\nfunction visit() {\n  if (!this.node) {\n    return false;\n  }\n\n  if (this.isDenylisted()) {\n    return false;\n  }\n\n  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {\n    return false;\n  }\n\n  if (this.shouldSkip || this.call(\"enter\") || this.shouldSkip) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n\n  this.debug(\"Recursing into...\");\n\n  _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);\n\n  this.call(\"exit\");\n  return this.shouldStop;\n}\n\nfunction skip() {\n  this.shouldSkip = true;\n}\n\nfunction skipKey(key) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n\n  this.skipKeys[key] = true;\n}\n\nfunction stop() {\n  this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;\n}\n\nfunction setScope() {\n  if (this.opts && this.opts.noScope) return;\n  let path = this.parentPath;\n  if (this.key === \"key\" && path.isMethod()) path = path.parentPath;\n  let target;\n\n  while (path && !target) {\n    if (path.opts && path.opts.noScope) return;\n    target = path.scope;\n    path = path.parentPath;\n  }\n\n  this.scope = this.getScope(target);\n  if (this.scope) this.scope.init();\n}\n\nfunction setContext(context) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n\n  this._traverseFlags = 0;\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n\n  this.setScope();\n  return this;\n}\n\nfunction resync() {\n  if (this.removed) return;\n\n  this._resyncParent();\n\n  this._resyncList();\n\n  this._resyncKey();\n}\n\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\nfunction _resyncKey() {\n  if (!this.container) return;\n  if (this.node === this.container[this.key]) return;\n\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        return this.setKey(i);\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      if (this.container[key] === this.node) {\n        return this.setKey(key);\n      }\n    }\n  }\n\n  this.key = null;\n}\n\nfunction _resyncList() {\n  if (!this.parent || !this.inList) return;\n  const newContainer = this.parent[this.listKey];\n  if (this.container === newContainer) return;\n  this.container = newContainer || null;\n}\n\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    this._markRemoved();\n  }\n}\n\nfunction popContext() {\n  this.contexts.pop();\n\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\n\nfunction pushContext(context) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\n\nfunction setup(parentPath, container, listKey, key) {\n  this.listKey = listKey;\n  this.container = container;\n  this.parentPath = parentPath || this.parentPath;\n  this.setKey(key);\n}\n\nfunction setKey(key) {\n  var _this$node;\n\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;\n}\n\nfunction requeue(pathToQueue = this) {\n  if (pathToQueue.removed) return;\n  ;\n  const contexts = this.contexts;\n\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\n\nfunction _getQueueContexts() {\n  let path = this;\n  let contexts = this.contexts;\n\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n\n  return contexts;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.remove = remove;\nexports._removeFromScope = _removeFromScope;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._remove = _remove;\nexports._markRemoved = _markRemoved;\nexports._assertUnremoved = _assertUnremoved;\n\nvar _removalHooks = require(\"./lib/removal-hooks\");\n\nvar _cache = require(\"../cache\");\n\nvar _index = require(\"./index\");\n\nfunction remove() {\n  var _this$opts;\n\n  this._assertUnremoved();\n\n  this.resync();\n\n  if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {\n    this._removeFromScope();\n  }\n\n  if (this._callRemovalHooks()) {\n    this._markRemoved();\n\n    return;\n  }\n\n  this.shareCommentsWithSiblings();\n\n  this._remove();\n\n  this._markRemoved();\n}\n\nfunction _removeFromScope() {\n  const bindings = this.getBindingIdentifiers();\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\n\nfunction _callRemovalHooks() {\n  for (const fn of _removalHooks.hooks) {\n    if (fn(this, this.parentPath)) return true;\n  }\n}\n\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    this.updateSiblingKeys(this.key, -1);\n  } else {\n    this._replaceWith(null);\n  }\n}\n\nfunction _markRemoved() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;\n  if (this.parent) _cache.path.get(this.parent).delete(this.node);\n  this.node = null;\n}\n\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\"NodePath has been removed so is read-only.\");\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hooks = void 0;\nconst hooks = [function (self, parent) {\n  const removeParent = self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase()) || self.key === \"declaration\" && parent.isExportDeclaration() || self.key === \"body\" && parent.isLabeledStatement() || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === \"expression\" && parent.isExpressionStatement();\n\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && (self.key === \"consequent\" || self.key === \"alternate\") || self.key === \"body\" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: \"BlockStatement\",\n      body: []\n    });\n    return true;\n  }\n}];\nexports.hooks = hooks;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = require(\"./lib/hoister\");\n\nvar _index = require(\"./index\");\n\nvar t = require(\"@babel/types\");\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return t.isExpression(node) ? t.expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        t.assertExpression(node);\n        this.replaceWith(t.callExpression(t.arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", t.cloneNode(temp), node)));\n      nodes.push(t.expressionStatement(t.cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar t = require(\"@babel/types\");\n\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = t.variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = t.jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(t.cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOpposite = getOpposite;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getSibling = getSibling;\nexports.getPrevSibling = getPrevSibling;\nexports.getNextSibling = getNextSibling;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.get = get;\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\n\nvar _index = require(\"./index\");\n\nvar t = require(\"@babel/types\");\n\nconst NORMAL_COMPLETION = 0;\nconst BREAK_COMPLETION = 1;\n\nfunction NormalCompletion(path) {\n  return {\n    type: NORMAL_COMPLETION,\n    path\n  };\n}\n\nfunction BreakCompletion(path) {\n  return {\n    type: BREAK_COMPLETION,\n    path\n  };\n}\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n\n  return null;\n}\n\nfunction addCompletionRecords(path, records, context) {\n  if (path) return records.concat(_getCompletionRecords(path, context));\n  return records;\n}\n\nfunction completionRecordForSwitch(cases, records, context) {\n  let lastNormalCompletions = [];\n\n  for (let i = 0; i < cases.length; i++) {\n    const casePath = cases[i];\n\n    const caseCompletions = _getCompletionRecords(casePath, context);\n\n    const normalCompletions = [];\n    const breakCompletions = [];\n\n    for (const c of caseCompletions) {\n      if (c.type === NORMAL_COMPLETION) {\n        normalCompletions.push(c);\n      }\n\n      if (c.type === BREAK_COMPLETION) {\n        breakCompletions.push(c);\n      }\n    }\n\n    if (normalCompletions.length) {\n      lastNormalCompletions = normalCompletions;\n    }\n\n    records = records.concat(breakCompletions);\n  }\n\n  records = records.concat(lastNormalCompletions);\n  return records;\n}\n\nfunction normalCompletionToBreak(completions) {\n  completions.forEach(c => {\n    c.type = BREAK_COMPLETION;\n  });\n}\n\nfunction replaceBreakStatementInBreakCompletion(completions, reachable) {\n  completions.forEach(c => {\n    if (c.path.isBreakStatement({\n      label: null\n    })) {\n      if (reachable) {\n        c.path.replaceWith(t.unaryExpression(\"void\", t.numericLiteral(0)));\n      } else {\n        c.path.remove();\n      }\n    }\n  });\n}\n\nfunction getStatementListCompletion(paths, context) {\n  let completions = [];\n\n  if (context.canHaveBreak) {\n    let lastNormalCompletions = [];\n\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const newContext = Object.assign({}, context, {\n        inCaseClause: false\n      });\n\n      if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {\n          newContext.shouldPopulateBreak = true;\n        } else {\n        newContext.shouldPopulateBreak = false;\n      }\n\n      const statementCompletions = _getCompletionRecords(path, newContext);\n\n      if (statementCompletions.length > 0 && statementCompletions.every(c => c.type === BREAK_COMPLETION)) {\n        if (lastNormalCompletions.length > 0 && statementCompletions.every(c => c.path.isBreakStatement({\n          label: null\n        }))) {\n          normalCompletionToBreak(lastNormalCompletions);\n          completions = completions.concat(lastNormalCompletions);\n\n          if (lastNormalCompletions.some(c => c.path.isDeclaration())) {\n            completions = completions.concat(statementCompletions);\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n\n          replaceBreakStatementInBreakCompletion(statementCompletions, false);\n        } else {\n          completions = completions.concat(statementCompletions);\n\n          if (!context.shouldPopulateBreak) {\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n        }\n\n        break;\n      }\n\n      if (i === paths.length - 1) {\n        completions = completions.concat(statementCompletions);\n      } else {\n        completions = completions.concat(statementCompletions.filter(c => c.type === BREAK_COMPLETION));\n        lastNormalCompletions = statementCompletions.filter(c => c.type === NORMAL_COMPLETION);\n      }\n    }\n  } else if (paths.length) {\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const pathCompletions = _getCompletionRecords(paths[i], context);\n\n      if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {\n        completions = completions.concat(pathCompletions);\n        break;\n      }\n    }\n  }\n\n  return completions;\n}\n\nfunction _getCompletionRecords(path, context) {\n  let records = [];\n\n  if (path.isIfStatement()) {\n    records = addCompletionRecords(path.get(\"consequent\"), records, context);\n    records = addCompletionRecords(path.get(\"alternate\"), records, context);\n  } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {\n    records = addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isProgram() || path.isBlockStatement()) {\n    records = records.concat(getStatementListCompletion(path.get(\"body\"), context));\n  } else if (path.isFunction()) {\n    return _getCompletionRecords(path.get(\"body\"), context);\n  } else if (path.isTryStatement()) {\n    records = addCompletionRecords(path.get(\"block\"), records, context);\n    records = addCompletionRecords(path.get(\"handler\"), records, context);\n  } else if (path.isCatchClause()) {\n    records = addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isSwitchStatement()) {\n    records = completionRecordForSwitch(path.get(\"cases\"), records, context);\n  } else if (path.isSwitchCase()) {\n    records = records.concat(getStatementListCompletion(path.get(\"consequent\"), {\n      canHaveBreak: true,\n      shouldPopulateBreak: false,\n      inCaseClause: true\n    }));\n  } else if (path.isBreakStatement()) {\n    records.push(BreakCompletion(path));\n  } else {\n    records.push(NormalCompletion(path));\n  }\n\n  return records;\n}\n\nfunction getCompletionRecords() {\n  const records = _getCompletionRecords(this, {\n    canHaveBreak: false,\n    shouldPopulateBreak: false,\n    inCaseClause: false\n  });\n\n  return records.map(r => r.path);\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return t.getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return t.getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  let search = [].concat(path);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = t.getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child) || child.node) {\n          search = search.concat(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\nexports.addComment = addComment;\nexports.addComments = addComments;\n\nvar t = require(\"@babel/types\");\n\nfunction shareCommentsWithSiblings() {\n  if (typeof this.key === \"string\") return;\n  const node = this.node;\n  if (!node) return;\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n\n  if (hasPrev && !hasNext) {\n    prev.addComments(\"trailing\", trailing);\n  } else if (hasNext && !hasPrev) {\n    next.addComments(\"leading\", leading);\n  }\n}\n\nfunction addComment(type, content, line) {\n  t.addComment(this.node, type, content, line);\n}\n\nfunction addComments(type, comments) {\n  t.addComments(this.node, type, comments);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.verify = verify;\nexports.merge = merge;\n\nvar virtualTypes = require(\"./path/lib/virtual-types\");\n\nvar t = require(\"@babel/types\");\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      for (const type of wrapper.types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = t.FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecatedKey = t.DEPRECATED_KEYS[nodeType];\n\n    if (deprecatedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`);\n      aliases = [deprecatedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (t.TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors, states = [], wrapper) {\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  const newFn = function (path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\" || key === \"blacklist\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Hub {\n  getCode() {}\n\n  getScope() {}\n\n  addHelper() {\n    throw new Error(\"Helpers are not supported by the default hub.\");\n  }\n\n  buildError(node, msg, Error = TypeError) {\n    return new Error(msg);\n  }\n\n}\n\nexports.default = Hub;"],"sourceRoot":""}