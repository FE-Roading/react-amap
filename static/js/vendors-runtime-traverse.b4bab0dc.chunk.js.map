{"version":3,"sources":["../../node_modules/@babel/traverse/lib/path/index.js","../../node_modules/@babel/traverse/lib/cache.js","../../node_modules/@babel/traverse/lib/path/lib/virtual-types.js","../../node_modules/@babel/traverse/lib/scope/index.js","../../node_modules/@babel/traverse/lib/scope/binding.js","../../node_modules/@babel/traverse/lib/context.js","../../node_modules/@babel/traverse/lib/scope/lib/renamer.js","../../node_modules/@babel/traverse/lib/path/ancestry.js","../../node_modules/@babel/traverse/lib/path/inference/index.js","../../node_modules/@babel/traverse/lib/path/inference/inferers.js","../../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js","../../node_modules/@babel/traverse/lib/path/replacement.js","../../node_modules/@babel/traverse/lib/path/evaluation.js","../../node_modules/@babel/traverse/lib/path/conversion.js","../../node_modules/@babel/traverse/lib/path/introspection.js","../../node_modules/@babel/traverse/lib/path/context.js","../../node_modules/@babel/traverse/lib/path/removal.js","../../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js","../../node_modules/@babel/traverse/lib/path/modification.js","../../node_modules/@babel/traverse/lib/path/lib/hoister.js","../../node_modules/@babel/traverse/lib/path/family.js","../../node_modules/@babel/traverse/lib/path/comments.js","../../node_modules/@babel/traverse/lib/visitors.js","../../node_modules/@babel/traverse/lib/hub.js","../../node_modules/@babel/traverse/lib/index.js"],"names":["Object","defineProperty","exports","value","default","SHOULD_STOP","SHOULD_SKIP","REMOVED","virtualTypes","require","_debug","_index","_scope","_t","t","_cache","_generator","NodePath_ancestry","NodePath_inference","NodePath_replacement","NodePath_evaluation","NodePath_conversion","NodePath_introspection","NodePath_context","NodePath_removal","NodePath_modification","NodePath_family","NodePath_comments","validate","debug","NodePath","hub","parent","this","contexts","state","opts","_traverseFlags","skipKeys","parentPath","container","listKey","key","node","type","data","context","scope","isScope","val","create","def","undefined","msg","Error","SyntaxError","buildError","visitor","parts","path","inList","unshift","join","message","enabled","getPathLocation","code","v","targetNode","paths","get","Map","set","setup","assign","prototype","TYPES","typeKey","fn","TypeError","indexOf","push","virtualType","checkPath","keys","_default","clear","clearPath","clearScope","WeakMap","Var","User","Statement","SpreadProperty","Scope","RestProperty","ReferencedMemberExpression","ReferencedIdentifier","Referenced","Pure","NumericLiteralTypeAnnotation","Generated","ForAwaitStatement","Flow","Expression","ExistentialTypeParam","BlockScoped","BindingIdentifier","isBinding","isBlockScoped","isExportDeclaration","isExpression","isFlow","isForStatement","isForXStatement","isIdentifier","isImportDeclaration","isImportSpecifier","isJSXIdentifier","isJSXMemberExpression","isMemberExpression","isReferenced","isStatement","isVar","isVariableDeclaration","isCompatTag","react","types","name","grandparent","left","init","isReferencedIdentifier","loc","isUser","isPure","importKind","exportKind","isObjectPattern","isObjectExpression","await","_renamer","_binding","_globals","NOT_LOCAL_BINDING","callExpression","cloneNode","getBindingIdentifiers","identifier","isArrayExpression","isBinary","isClass","isClassBody","isClassDeclaration","isExportAllDeclaration","isExportDefaultDeclaration","isExportNamedDeclaration","isFunctionDeclaration","isLiteral","isMethod","isModuleDeclaration","isModuleSpecifier","isProperty","isPureish","isSuper","isTaggedTemplateExpression","isTemplateLiteral","isThisExpression","isUnaryExpression","matchesPattern","memberExpression","numericLiteral","toIdentifier","unaryExpression","variableDeclaration","variableDeclarator","gatherNodeParts","source","specifiers","length","declaration","local","object","property","callee","properties","argument","id","expression","meta","openingElement","openingFragment","namespace","collectorVisitor","ForStatement","declar","getFunctionParent","getProgramParent","registerBinding","Declaration","registerDeclaration","ImportDeclaration","getBlockParent","references","ForXStatement","isPattern","constantViolations","ExportDeclaration","exit","binding","getBinding","reference","declarations","decl","LabeledStatement","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","bindings","CatchClause","Function","params","param","isFunctionExpression","has","ClassExpression","uid","block","labels","inited","globals","uids","crawling","cached","_parent","isKey","generateUidIdentifier","generateUid","replace","i","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","defaultName","slice","generateUidBasedOnNode","constant","dontPush","isStatic","generateUidIdentifierBasedOnNode","kind","oldName","newName","rename","map","sep","repeat","console","log","violations","arrayLikeIsIterable","isGenericType","helperName","args","addHelper","getLabel","label","isLabeledStatement","registerLabel","specifier","ids","reassign","bindingPath","ReferenceError","declarators","getOuterBindingIdentifiers","getOwnBinding","checkBlockScopedCollisions","registerConstantViolation","constantsOnly","superClass","body","method","right","elements","elem","prop","computed","tag","quasi","expressions","crawl","programParent","_exploded","enter","visit","typeVisitors","traverse","addGlobal","ref","isBlockStatement","isProgram","isSwitchStatement","isLoop","isCatchClause","isFunction","ensureBlock","unique","blockHoist","_blockHoist","dataKey","declarPath","getData","unshiftContainer","setData","declarator","pop","isFunctionParent","isBlockParent","kinds","getBindingIdentifier","previousPath","_previousPath","_this$getBinding","noGlobals","hasOwnBinding","parentHasBinding","hasUid","includes","contextVariables","_this$parent","info","removeOwnBinding","_this$getBinding2","builtin","Binding","referencePaths","referenced","clearValue","hasDeoptedValue","hasValue","_path","VISITOR_KEYS","TraversalContext","queue","priorityQueue","obj","notPriority","shouldVisit","visitQueue","visited","WeakSet","stop","resync","pushContext","add","popContext","nodes","Array","isArray","visitMultiple","visitSingle","_helperSplitExportDeclaration","renameVisitor","assignmentExpression","toExpression","bindingIdentifierEquals","skip","skipKey","skipAllButComputedMethodKey","Renamer","parentDeclar","maybeExportDeclar","find","isDeclaration","isClassExpression","maybeConvertFromExportDeclaration","blockToTraverse","cases","forEach","c","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","callback","findParent","getAncestry","getDeepestCommonAncestorFrom","filter","lastCommonIndex","lastCommon","minDepth","Infinity","ancestries","ancestry","first","depthLoop","shouldMatch","getEarliestCommonAncestorFrom","deepest","earliest","parentKey","p","getStatementParent","isFile","inType","candidateTypes","isAncestor","maybeDescendant","isDescendant","maybeAncestor","_getTypeAnnotation","isVariableDeclarator","declarParent","isForInStatement","stringTypeAnnotation","isForOfStatement","anyTypeAnnotation","voidTypeAnnotation","typeAnnotation","typeAnnotationInferringNodes","_inferer","inferer","inferers","call","validParent","getTypeAnnotation","delete","baseTypeStrictlyMatches","rightArg","isAnyTypeAnnotation","isFlowBaseAnnotation","couldBeBaseType","isUnionTypeAnnotation","type2","_isBaseType","isTypeAnnotation","isBaseType","baseName","soft","genericName","isGenericTypeAnnotation","isBooleanTypeAnnotation","isEmptyTypeAnnotation","isMixedTypeAnnotation","isNumberTypeAnnotation","isStringTypeAnnotation","isVoidTypeAnnotation","ArrayExpression","BinaryExpression","NUMBER_BINARY_OPERATORS","numberTypeAnnotation","BOOLEAN_BINARY_OPERATORS","booleanTypeAnnotation","unionTypeAnnotation","BooleanLiteral","CallExpression","isObjectKeys","arrayTypeAnnotation","isArrayFrom","isObjectValues","isObjectEntries","tupleTypeAnnotation","resolveCall","ConditionalExpression","argumentTypes","isTSTypeAnnotation","createTSUnionType","createFlowUnionType","createUnionTypeAnnotation","ClassDeclaration","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","genericTypeAnnotation","enumerable","_infererReference","LogicalExpression","NewExpression","NullLiteral","nullLiteralTypeAnnotation","NumericLiteral","ObjectExpression","ParenthesizedExpression","RegExpLiteral","RestElement","SequenceExpression","StringLiteral","TaggedTemplateExpression","TemplateLiteral","TypeCastExpression","NUMBER_UNARY_OPERATORS","STRING_UNARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","VariableDeclarator","_type","isCallExpression","buildMatchMemberExpression","resolve","is","returnType","functionConstantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","violation","getTypeAnnotationBindingConstantViolations","BOOLEAN_NUMBER_BINARY_OPERATORS","createTypeAnnotationBasedOnTypeof","functions","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","target","typeofPath","typePath","typeValue","isIfStatement","isConditionalExpression","getParentConditionalPath","isLogicalExpression","isBinaryExpression","_replaceWith","_pathCache$get2","replaceExpressionWithStatements","nodesAsSequenceExpression","toSequenceExpression","replaceWith","functionParent","isParentAsync","isParentGenerator","arrowFunctionExpression","blockStatement","_helperHoistVariables","completionRecords","getCompletionRecords","isExpressionStatement","loop","generateDeclaredUidIdentifier","pushContainer","returnStatement","arrowFunctionToExpression","newCallee","needToAwaitFunction","hasType","FUNCTION_TYPES","needToYieldFunction","awaitExpression","yieldExpression","replaceInline","_verifyNodeList","_containerInsertAfter","remove","replaceWithMultiple","replacement","removed","_index2","nodePath","isNodeType","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","expressionStatement","oldNode","inheritsComments","removeComments","setScope","requeue","_pathCache$get","inheritLeadingComments","inheritTrailingComments","insertAfter","replaceWithSourceString","_parser","parse","err","_codeFrame","codeFrameColumns","start","line","column","removeProperties","evaluate","confident","deoptPath","seen","evaluateCached","deopt","evaluateTruthy","res","VALID_CALLEES","INVALID_METHODS","existing","resolved","item","isSequenceExpression","exprs","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","evaluateQuasis","quasis","testResult","isExpressionWrapper","end","NaN","prefix","arg","arr","elems","elemValue","props","isObjectMethod","isSpreadElement","wasConfident","leftConfident","rightConfident","Math","pow","func","global","apply","_evaluate","raw","str","cooked","expr","String","allowInsertArrow","specCompliant","noNewArrows","isArrowFunctionExpression","buildCodeFrameError","hoistFunctionEnvironment","thisBinding","fnPath","checkBinding","objectExpression","thisExpression","_helperFunctionName","arrowFunctionToShadowed","bodyNode","statements","stringPath","toComputedKey","stringLiteral","unwrapFunctionEnvironment","binaryExpression","conditionalExpression","jsxIdentifier","metaProperty","restElement","sequenceExpression","spreadElement","_super","super","arrowParent","thisEnvFn","isClassProperty","static","isClassPrivateProperty","inConstructor","isClassMethod","getScopeInformation","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","allSuperCalls","child","ClassProperty","superBinding","getSuperBinding","superCall","argumentsBinding","buildUndefinedNode","argumentsChild","argsRef","newTargetBinding","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","concat","standardizeSuperProperty","isAssignment","isAssignmentExpression","isCall","getSuperPropBinding","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","assignmentPath","op","tmp","isUpdateExpression","updateExpr","computedKey","supers","argsBinding","propName","fnBody","argsList","valueIdent","cacheKey","ThisExpression","JSXIdentifier","isJSXOpeningElement","MemberExpression","curr","MetaProperty","funcParent","getOuterFunction","_guessExecutionStatusRelativeToDifferentFunctions","commonPath","commonIndex","isExecutionUncertainInList","divergence","keyPosition","allStatus","executionOrderCheckedNodes","_resolve","dangerous","ret","isTypeCastExpression","targetKey","targetName","match","isnt","isNaN","isFor","equals","getSource","getCode","isCompletionRecord","allowInsideFunction","isConstantExpression","isRegExpLiteral","every","isInStrictMode","sourceType","directives","isType","isStatementOrBlock","STATEMENT_OR_BLOCK_KEYS","pattern","allowPartial","_matchesPattern","referencesImport","moduleSource","importName","isOptionalMemberExpression","isImportDefaultSpecifier","isImportNamespaceSpecifier","imported","willIMaybeExecuteBefore","isExecutionUncertain","maxIndex","_call","fns","then","_getQueueContexts","_resyncKey","setKey","_resyncList","newContainer","_resyncParent","_resyncRemoved","_markRemoved","isBlacklisted","isDenylisted","_this$opts$denylist","denylist","blacklist","setContext","pathToQueue","maybeQueue","_this$node","noScope","getScope","shouldSkip","currentContext","shouldStop","restoreContext","_assertUnremoved","_callRemovalHooks","_removalHooks","hooks","_remove","splice","updateSiblingKeys","_removeFromScope","removeBinding","_this$opts","shareCommentsWithSiblings","self","isWhile","isSwitchCase","_containerInsert","from","to","getSibling","_containerInsertBefore","hoist","hoister","_hoister","run","nodes_","isJSXElement","assertExpression","temp","shouldInsertCurrentNode","insertBefore","verifiedNodes","fromIndex","incrementBy","_t2","jsxExpressionContainer","referenceVisitor","breakOnScopePaths","mutableBinding","PathHoister","scopes","attachAfter","isCompatibleScope","_getAttachmentPath","targetScope","getAttachmentParentForPath","violationPath","hasOwnParamBindings","getNextScopeAttachmentParent","bodies","getCompatibleScopes","attachTo","getAttachmentPath","attached","children","_getKey","_","_getPattern","part","split","getAllNextSiblings","_key","sibling","siblings","getAllPrevSiblings","getBindingIdentifierPaths","duplicates","outerOnly","search","shift","_getBindingIdentifiers","_ids","_getCompletionRecords","canHaveBreak","shouldPopulateBreak","inCaseClause","r","getNextSibling","getOpposite","getOuterBindingIdentifierPaths","_getOuterBindingIdentifiers","getPrevSibling","addCompletionRecords","records","normalCompletionToBreak","completions","replaceBreakStatementInBreakCompletion","reachable","isBreakStatement","getStatementListCompletion","lastNormalCompletions","newContext","statementCompletions","some","pathCompletions","isDoExpression","isTryStatement","caseCompletions","normalCompletions","breakCompletions","completionRecordForSwitch","BreakCompletion","NormalCompletion","addComment","content","_addComment","addComments","comments","_addComments","trailing","trailingComments","leading","leadingComments","prev","next","hasPrev","Boolean","hasNext","explode","merge","visitors","states","wrapper","rootVisitor","visitorType","wrapWithStateOrWrapper","nodeVisitor","mergePair","verify","DEPRECATED_KEYS","FLIPPED_ALIAS_KEYS","nodeType","shouldIgnoreKey","__esModule","ensureEntranceObjects","ensureCallbackArrays","wrapCheck","aliases","deprecatedKey","trace","alias","_verified","validateVisitorMethods","visitorKey","oldVisitor","newVisitor","newFn","toString","arguments","dest","src","Hub","_hub","_context","cache","traverseFast","hasDenylistedType","cheap","clearNode","tree","denylistTypes"],"mappings":"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","file":"static/js/vendors-runtime-traverse.b4bab0dc.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SHOULD_STOP = exports.SHOULD_SKIP = exports.REMOVED = void 0;\n\nvar virtualTypes = require(\"./lib/virtual-types\");\n\nvar _debug = require(\"debug\");\n\nvar _index = require(\"../index\");\n\nvar _scope = require(\"../scope\");\n\nvar _t = require(\"@babel/types\");\n\nvar t = _t;\n\nvar _cache = require(\"../cache\");\n\nvar _generator = require(\"@babel/generator\");\n\nvar NodePath_ancestry = require(\"./ancestry\");\n\nvar NodePath_inference = require(\"./inference\");\n\nvar NodePath_replacement = require(\"./replacement\");\n\nvar NodePath_evaluation = require(\"./evaluation\");\n\nvar NodePath_conversion = require(\"./conversion\");\n\nvar NodePath_introspection = require(\"./introspection\");\n\nvar NodePath_context = require(\"./context\");\n\nvar NodePath_removal = require(\"./removal\");\n\nvar NodePath_modification = require(\"./modification\");\n\nvar NodePath_family = require(\"./family\");\n\nvar NodePath_comments = require(\"./comments\");\n\nconst {\n  validate\n} = _t;\n\nconst debug = _debug(\"babel\");\n\nconst REMOVED = 1 << 0;\nexports.REMOVED = REMOVED;\nconst SHOULD_STOP = 1 << 1;\nexports.SHOULD_STOP = SHOULD_STOP;\nconst SHOULD_SKIP = 1 << 2;\nexports.SHOULD_SKIP = SHOULD_SKIP;\n\nclass NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key\n  }) {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode = container[key];\n\n    let paths = _cache.path.get(parent);\n\n    if (!paths) {\n      paths = new Map();\n\n      _cache.path.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  }\n\n  getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  }\n\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    return this.data[key] = val;\n  }\n\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  buildCodeFrameError(msg, Error = SyntaxError) {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key, node) {\n    validate(this.node, key, node);\n    this.node[key] = node;\n  }\n\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  }\n\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n\n}\n\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n\n  NodePath.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === \"_\") continue;\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n  const virtualType = virtualTypes[type];\n\n  NodePath.prototype[`is${type}`] = function (opts) {\n    return virtualType.checkPath(this, opts);\n  };\n}\n\nvar _default = NodePath;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clear = clear;\nexports.clearPath = clearPath;\nexports.clearScope = clearScope;\nexports.scope = exports.path = void 0;\nlet path = new WeakMap();\nexports.path = path;\nlet scope = new WeakMap();\nexports.scope = scope;\n\nfunction clear() {\n  clearPath();\n  clearScope();\n}\n\nfunction clearPath() {\n  exports.path = path = new WeakMap();\n}\n\nfunction clearScope() {\n  exports.scope = scope = new WeakMap();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Var = exports.User = exports.Statement = exports.SpreadProperty = exports.Scope = exports.RestProperty = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = exports.Referenced = exports.Pure = exports.NumericLiteralTypeAnnotation = exports.Generated = exports.ForAwaitStatement = exports.Flow = exports.Expression = exports.ExistentialTypeParam = exports.BlockScoped = exports.BindingIdentifier = void 0;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isBinding,\n  isBlockScoped,\n  isExportDeclaration,\n  isExpression,\n  isFlow,\n  isForStatement,\n  isForXStatement,\n  isIdentifier,\n  isImportDeclaration,\n  isImportSpecifier,\n  isJSXIdentifier,\n  isJSXMemberExpression,\n  isMemberExpression,\n  isReferenced,\n  isScope,\n  isStatement,\n  isVar,\n  isVariableDeclaration,\n  react\n} = _t;\nconst {\n  isCompatTag\n} = react;\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {\n      if (isJSXIdentifier(node, opts)) {\n        if (isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return isMemberExpression(node) && isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return isIdentifier(node) && isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (isStatement(node)) {\n      if (isVariableDeclaration(node)) {\n        if (isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (isFlow(node)) {\n      return true;\n    } else if (isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = require(\"./lib/renamer\");\n\nvar _index = require(\"../index\");\n\nvar _binding = require(\"./binding\");\n\nvar _globals = require(\"globals\");\n\nvar _t = require(\"@babel/types\");\n\nvar _cache = require(\"../cache\");\n\nconst {\n  NOT_LOCAL_BINDING,\n  callExpression,\n  cloneNode,\n  getBindingIdentifiers,\n  identifier,\n  isArrayExpression,\n  isBinary,\n  isClass,\n  isClassBody,\n  isClassDeclaration,\n  isExportAllDeclaration,\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isImportDeclaration,\n  isLiteral,\n  isMethod,\n  isModuleDeclaration,\n  isModuleSpecifier,\n  isObjectExpression,\n  isProperty,\n  isPureish,\n  isSuper,\n  isTaggedTemplateExpression,\n  isTemplateLiteral,\n  isThisExpression,\n  isUnaryExpression,\n  isVariableDeclaration,\n  matchesPattern,\n  memberExpression,\n  numericLiteral,\n  toIdentifier,\n  unaryExpression,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (isModuleDeclaration(node)) {\n        if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  ForStatement(path) {\n    const declar = path.get(\"init\");\n\n    if (declar.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", declar);\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isImportDeclaration()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ImportDeclaration(path) {\n    const parent = path.scope.getBlockParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    } else if (left.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", left);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        binding == null ? void 0 : binding.reference(path);\n      } else if (isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            binding == null ? void 0 : binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const isKey = path.key === \"key\";\n      path = path.parentPath;\n      if (isKey && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (isThisExpression(node) || isSuper(node)) {\n      return true;\n    }\n\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (isArrayExpression(node)) {\n      return node;\n    }\n\n    if (isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return callExpression(memberExpression(memberExpression(memberExpression(identifier(\"Array\"), identifier(\"prototype\")), identifier(\"slice\")), identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return unaryExpression(\"void\", numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (isTaggedTemplateExpression(node)) {\n      return matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind(...kinds) {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\" && binding.kind !== \"local\") {} else {\n          return binding;\n        }\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Binding {\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind\n  }) {\n    this.identifier = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.kind = void 0;\n    this.constantViolations = [];\n    this.constant = true;\n    this.referencePaths = [];\n    this.referenced = false;\n    this.references = 0;\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n    this.clearValue();\n  }\n\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n\n  setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n\n  reassign(path) {\n    this.constant = false;\n\n    if (this.constantViolations.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.constantViolations.push(path);\n  }\n\n  reference(path) {\n    if (this.referencePaths.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n\n}\n\nexports.default = Binding;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = require(\"./path\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  VISITOR_KEYS\n} = _t;\n\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.priorityQueue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = VISITOR_KEYS[node.type];\n    if (!(keys != null && keys.length)) return false;\n\n    for (const key of keys) {\n      if (node[key]) return true;\n    }\n\n    return false;\n  }\n\n  create(node, obj, key, listKey) {\n    return _path.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey\n    });\n  }\n\n  maybeQueue(path, notPriority) {\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n\n    for (const path of queue) {\n      path.resync();\n\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        path.pushContext(this);\n      }\n\n      if (path.key === null) continue;\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    for (const path of queue) {\n      path.popContext();\n    }\n\n    this.queue = null;\n    return stop;\n  }\n\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n\n}\n\nexports.default = TraversalContext;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = require(\"../binding\");\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  VISITOR_KEYS,\n  assignmentExpression,\n  identifier,\n  toExpression,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      skipAllButComputedMethodKey(path);\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(variableDeclaration(\"let\", [variableDeclarator(identifier(this.newName), toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: identifier(this.newName)\n    });\n    path.replaceWith(assignmentExpression(\"=\", identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;\n\nfunction skipAllButComputedMethodKey(path) {\n  if (!path.isMethod() || !path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.find = find;\nexports.findParent = findParent;\nexports.getAncestry = getAncestry;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.inType = inType;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\n\nvar _t = require(\"@babel/types\");\n\nvar _index = require(\"./index\");\n\nconst {\n  VISITOR_KEYS\n} = _t;\n\nfunction findParent(callback) {\n  let path = this;\n\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n\n  return null;\n}\n\nfunction find(callback) {\n  let path = this;\n\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n\n  return null;\n}\n\nfunction getFunctionParent() {\n  return this.findParent(p => p.isFunction());\n}\n\nfunction getStatementParent() {\n  let path = this;\n\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\"File/Program node, we can't possibly find a statement parent to this\");\n  }\n\n  return path;\n}\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    let earliest;\n    const keys = VISITOR_KEYS[deepest.type];\n\n    for (const ancestry of ancestries) {\n      const path = ancestry[i + 1];\n\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      if (path.listKey && earliest.listKey === path.listKey) {\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      const currentKeyIndex = keys.indexOf(path.parentKey);\n\n      if (earliestKeyIndex > currentKeyIndex) {\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  let minDepth = Infinity;\n  let lastCommonIndex, lastCommon;\n  const ancestries = paths.map(path => {\n    const ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n  const first = ancestries[0];\n\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        break depthLoop;\n      }\n    }\n\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\nfunction getAncestry() {\n  let path = this;\n  const paths = [];\n\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n\n  return paths;\n}\n\nfunction isAncestor(maybeDescendant) {\n  return maybeDescendant.isDescendant(this);\n}\n\nfunction isDescendant(maybeAncestor) {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\n\nfunction inType(...candidateTypes) {\n  let path = this;\n\n  while (path) {\n    for (const type of candidateTypes) {\n      if (path.node.type === type) return true;\n    }\n\n    path = path.parentPath;\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.couldBeBaseType = couldBeBaseType;\nexports.getTypeAnnotation = getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.isGenericType = isGenericType;\n\nvar inferers = require(\"./inferers\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  anyTypeAnnotation,\n  isAnyTypeAnnotation,\n  isBooleanTypeAnnotation,\n  isEmptyTypeAnnotation,\n  isFlowBaseAnnotation,\n  isGenericTypeAnnotation,\n  isIdentifier,\n  isMixedTypeAnnotation,\n  isNumberTypeAnnotation,\n  isStringTypeAnnotation,\n  isTypeAnnotation,\n  isUnionTypeAnnotation,\n  isVoidTypeAnnotation,\n  stringTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n  let type = this._getTypeAnnotation() || anyTypeAnnotation();\n  if (isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\nconst typeAnnotationInferringNodes = new WeakSet();\n\nfunction _getTypeAnnotation() {\n  const node = this.node;\n\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return stringTypeAnnotation();\n      }\n\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return anyTypeAnnotation();\n      }\n\n      return voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    var _inferer;\n\n    let inferer = inferers[node.type];\n\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    inferer = inferers[this.parentPath.type];\n\n    if ((_inferer = inferer) != null && _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (isAnyTypeAnnotation(type)) return true;\n\n  if (isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(rightArg) {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n\n  if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n\n  return false;\n}\n\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n  return isGenericTypeAnnotation(type) && isIdentifier(type.id, {\n    name: genericName\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayExpression = ArrayExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.BooleanLiteral = BooleanLiteral;\nexports.CallExpression = CallExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\nexports.LogicalExpression = LogicalExpression;\nexports.NewExpression = NewExpression;\nexports.NullLiteral = NullLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.RegExpLiteral = RegExpLiteral;\nexports.RestElement = RestElement;\nexports.SequenceExpression = SequenceExpression;\nexports.StringLiteral = StringLiteral;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.TypeCastExpression = TypeCastExpression;\nexports.UnaryExpression = UnaryExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.VariableDeclarator = VariableDeclarator;\n\nvar _t = require(\"@babel/types\");\n\nvar _infererReference = require(\"./inferer-reference\");\n\nconst {\n  BOOLEAN_BINARY_OPERATORS,\n  BOOLEAN_UNARY_OPERATORS,\n  NUMBER_BINARY_OPERATORS,\n  NUMBER_UNARY_OPERATORS,\n  STRING_UNARY_OPERATORS,\n  anyTypeAnnotation,\n  arrayTypeAnnotation,\n  booleanTypeAnnotation,\n  buildMatchMemberExpression,\n  createFlowUnionType,\n  createTSUnionType,\n  createUnionTypeAnnotation,\n  genericTypeAnnotation,\n  identifier,\n  isTSTypeAnnotation,\n  nullLiteralTypeAnnotation,\n  numberTypeAnnotation,\n  stringTypeAnnotation,\n  tupleTypeAnnotation,\n  unionTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return voidTypeAnnotation();\n  } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return stringTypeAnnotation();\n  } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return stringTypeAnnotation();\n    }\n\n    return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {\n    return createTSUnionType(argumentTypes);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(argumentTypes);\n  }\n\n  return createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {\n    return createTSUnionType(argumentTypes);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(argumentTypes);\n  }\n\n  return createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return genericTypeAnnotation(identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return genericTypeAnnotation(identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return genericTypeAnnotation(identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return genericTypeAnnotation(identifier(\"Function\"));\n}\n\nconst isArrayFrom = buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return arrayTypeAnnotation(stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return arrayTypeAnnotation(anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return genericTypeAnnotation(identifier(\"AsyncIterator\"));\n      } else {\n        return genericTypeAnnotation(identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  BOOLEAN_NUMBER_BINARY_OPERATORS,\n  createFlowUnionType,\n  createTSUnionType,\n  createTypeAnnotationBasedOnTypeof,\n  createUnionTypeAnnotation,\n  isTSTypeAnnotation,\n  numberTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations.push(...functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (isTSTypeAnnotation(types[0]) && createTSUnionType) {\n    return createTSUnionType(types);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(types);\n  }\n\n  return createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (isTSTypeAnnotation(types[0]) && createTSUnionType) {\n      return {\n        typeAnnotation: createTSUnionType(types),\n        ifStatement\n      };\n    }\n\n    if (createFlowUnionType) {\n      return {\n        typeAnnotation: createFlowUnionType(types),\n        ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\nexports.replaceWith = replaceWith;\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = require(\"../index\");\n\nvar _index2 = require(\"./index\");\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar _t = require(\"@babel/types\");\n\nvar _helperHoistVariables = require(\"@babel/helper-hoist-variables\");\n\nconst {\n  FUNCTION_TYPES,\n  arrowFunctionExpression,\n  assignmentExpression,\n  awaitExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  identifier,\n  inheritLeadingComments,\n  inheritTrailingComments,\n  inheritsComments,\n  isExpression,\n  isProgram,\n  isStatement,\n  removeComments,\n  returnStatement,\n  toSequenceExpression,\n  validate,\n  yieldExpression\n} = _t;\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  inheritLeadingComments(nodes[0], this.node);\n  inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = `(${replacement})`;\n    replacement = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n\n  _index.default.removeProperties(replacement);\n\n  return this.replaceWith(replacement);\n}\n\nfunction replaceWith(replacement) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index2.default) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    inheritsComments(replacement, oldNode);\n    removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    validate(this.parent, this.key, [node]);\n  } else {\n    validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const nodesAsSequenceExpression = toSequenceExpression(nodes, this.scope);\n\n  if (nodesAsSequenceExpression) {\n    return this.replaceWith(nodesAsSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const isParentGenerator = functionParent == null ? void 0 : functionParent.is(\"generator\");\n  const container = arrowFunctionExpression([], blockStatement(nodes));\n  this.replaceWith(callExpression(container, []));\n  const callee = this.get(\"callee\");\n  (0, _helperHoistVariables.default)(callee.get(\"body\"), id => {\n    this.scope.push({\n      id\n    });\n  }, \"var\");\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", returnStatement(cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(assignmentExpression(\"=\", cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(returnStatement(path.node.expression));\n    }\n  }\n\n  callee.arrowFunctionToExpression();\n  const newCallee = callee;\n\n  const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", FUNCTION_TYPES);\n\n  const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get(\"callee.body\").node, \"YieldExpression\", FUNCTION_TYPES);\n\n  if (needToAwaitFunction) {\n    newCallee.set(\"async\", true);\n\n    if (!needToYieldFunction) {\n      this.replaceWith(awaitExpression(this.node));\n    }\n  }\n\n  if (needToYieldFunction) {\n    newCallee.set(\"generator\", true);\n    this.replaceWith(yieldExpression(this.node, true));\n  }\n\n  return newCallee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluate = evaluate;\nexports.evaluateTruthy = evaluateTruthy;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding != null && binding.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.ensureBlock = ensureBlock;\nexports.toComputedKey = toComputedKey;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\n\nvar _t = require(\"@babel/types\");\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nconst {\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  conditionalExpression,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  jsxIdentifier,\n  memberExpression,\n  metaProperty,\n  numericLiteral,\n  objectExpression,\n  restElement,\n  returnStatement,\n  sequenceExpression,\n  spreadElement,\n  stringLiteral,\n  super: _super,\n  thisExpression,\n  toExpression,\n  unaryExpression\n} = _t;\n\nfunction toComputedKey() {\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!this.node.computed) {\n    if (isIdentifier(key)) key = stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  specCompliant = false,\n  noNewArrows = !specCompliant\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const {\n    thisBinding,\n    fnPath: fn\n  } = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);\n  fn.ensureBlock();\n  fn.node.type = \"FunctionExpression\";\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      fn.parentPath.scope.push({\n        id: checkBinding,\n        init: objectExpression([])\n      });\n    }\n\n    fn.get(\"body\").unshiftContainer(\"body\", expressionStatement(callExpression(this.hub.addHelper(\"newArrowCheck\"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));\n    fn.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this, true) || fn.node, identifier(\"bind\")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));\n  }\n}\n\nfunction hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true) {\n  let arrowParent;\n  let thisEnvFn = fnPath.findParent(p => {\n    if (p.isArrowFunctionExpression()) {\n      var _arrowParent;\n\n      (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;\n      return false;\n    }\n\n    return p.isFunction() || p.isProgram() || p.isClassProperty({\n      static: false\n    }) || p.isClassPrivateProperty({\n      static: false\n    });\n  });\n  const inConstructor = thisEnvFn.isClassMethod({\n    kind: \"constructor\"\n  });\n\n  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {\n    if (arrowParent) {\n      thisEnvFn = arrowParent;\n    } else if (allowInsertArrow) {\n      fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));\n      thisEnvFn = fnPath.get(\"callee\");\n      fnPath = thisEnvFn.get(\"body\");\n    } else {\n      throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n    }\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        allSuperCalls.push(child);\n      }\n\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => {\n      const args = () => identifier(\"arguments\");\n\n      if (thisEnvFn.scope.path.isProgram()) {\n        return conditionalExpression(binaryExpression(\"===\", unaryExpression(\"typeof\", args()), stringLiteral(\"undefined\")), thisEnvFn.scope.buildUndefinedNode(), args());\n      } else {\n        return args();\n      }\n    });\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => metaProperty(identifier(\"new\"), identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = callExpression(identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", thisExpression());\n        superProp.replaceWith(memberExpression(call, identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return {\n    thisBinding,\n    fnPath\n  };\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    assignmentPath.node.operator = \"=\";\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      assignmentPath.get(\"left\").replaceWith(memberExpression(superProp.node.object, assignmentExpression(\"=\", tmp, superProp.node.property), true));\n      assignmentPath.get(\"right\").replaceWith(binaryExpression(op, memberExpression(superProp.node.object, identifier(tmp.name), true), value));\n    } else {\n      assignmentPath.get(\"left\").replaceWith(memberExpression(superProp.node.object, superProp.node.property));\n      assignmentPath.get(\"right\").replaceWith(binaryExpression(op, memberExpression(superProp.node.object, identifier(superProp.node.property.name)), value));\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [assignmentExpression(\"=\", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression(\"=\", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(\"+\", identifier(tmp.name), numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();\n    const supers = new WeakSet();\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        if (supers.has(child.node)) return;\n        supers.add(child.node);\n        child.replaceWithMultiple([child.node, assignmentExpression(\"=\", identifier(thisBinding), identifier(\"this\"))]);\n      }\n\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = memberExpression(_super(), identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = memberExpression(_super(), identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = assignmentExpression(\"=\", fnBody, identifier(valueIdent.name));\n    }\n\n    return arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse({\n    ClassProperty(child) {\n      child.skip();\n    },\n\n    Function(child) {\n      if (child.isArrowFunctionExpression()) return;\n      child.skip();\n    },\n\n    ThisExpression(child) {\n      thisPaths.push(child);\n    },\n\n    JSXIdentifier(child) {\n      if (child.node.name !== \"this\") return;\n\n      if (!child.parentPath.isJSXMemberExpression({\n        object: child.node\n      }) && !child.parentPath.isJSXOpeningElement({\n        name: child.node\n      })) {\n        return;\n      }\n\n      thisPaths.push(child);\n    },\n\n    CallExpression(child) {\n      if (child.get(\"callee\").isSuper()) superCalls.push(child);\n    },\n\n    MemberExpression(child) {\n      if (child.get(\"object\").isSuper()) superProps.push(child);\n    },\n\n    ReferencedIdentifier(child) {\n      if (child.node.name !== \"arguments\") return;\n      let curr = child.scope;\n\n      do {\n        if (curr.hasOwnBinding(\"arguments\")) {\n          curr.rename(\"arguments\");\n          return;\n        }\n\n        if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (curr = curr.parent);\n\n      argumentsPaths.push(child);\n    },\n\n    MetaProperty(child) {\n      if (!child.get(\"meta\").isIdentifier({\n        name: \"new\"\n      })) return;\n      if (!child.get(\"property\").isIdentifier({\n        name: \"target\"\n      })) return;\n      newTargetPaths.push(child);\n    }\n\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;\nexports._resolve = _resolve;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.equals = equals;\nexports.getSource = getSource;\nexports.has = has;\nexports.is = void 0;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isConstantExpression = isConstantExpression;\nexports.isInStrictMode = isInStrictMode;\nexports.isNodeType = isNodeType;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.isStatic = isStatic;\nexports.isnt = isnt;\nexports.matchesPattern = matchesPattern;\nexports.referencesImport = referencesImport;\nexports.resolve = resolve;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  STATEMENT_OR_BLOCK_KEYS,\n  VISITOR_KEYS,\n  isBlockStatement,\n  isExpression,\n  isIdentifier,\n  isLiteral,\n  isStringLiteral,\n  isType,\n  matchesPattern: _matchesPattern\n} = _t;\n\nfunction matchesPattern(pattern, allowPartial) {\n  return _matchesPattern(this.node, pattern, allowPartial);\n}\n\nfunction has(key) {\n  const val = this.node && this.node[key];\n\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\n\nconst is = has;\nexports.is = is;\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\nfunction isNodeType(type) {\n  return isType(this.type, type);\n}\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return isExpression(replacement);\n  }\n\n  return false;\n}\n\nfunction isCompletionRecord(allowInsideFunction) {\n  let path = this;\n  let first = true;\n\n  do {\n    const container = path.container;\n\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return STATEMENT_OR_BLOCK_KEYS.includes(this.key);\n  }\n}\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) {\n    if ((this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {\n      value: importName\n    }) : this.node.property.name === importName)) {\n      const object = this.get(\"object\");\n      return object.isReferencedIdentifier() && object.referencesImport(moduleSource, \"*\");\n    }\n\n    return false;\n  }\n\n  const binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && isIdentifier(path.node.imported, {\n    name: importName\n  })) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getSource() {\n  const node = this.node;\n\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n\n  return \"\";\n}\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path) {\n  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;\n}\n\nfunction isExecutionUncertain(type, key) {\n  switch (type) {\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths, maxIndex) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  const funcParent = {\n    this: getOuterFunction(this),\n    target: getOuterFunction(target)\n  };\n\n  if (funcParent.target.node !== funcParent.this.node) {\n    return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: this.getAncestry()\n  };\n  if (paths.target.indexOf(this) >= 0) return \"after\";\n  if (paths.this.indexOf(target) >= 0) return \"before\";\n  let commonPath;\n  const commonIndex = {\n    target: 0,\n    this: 0\n  };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\"Internal Babel error - The two compared nodes\" + \" don't appear to belong to the same program.\");\n  }\n\n  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1]\n  };\n\n  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  const keys = VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey)\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\nconst executionOrderCheckedNodes = new WeakSet();\n\nfunction _guessExecutionStatusRelativeToDifferentFunctions(target) {\n  if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {\n    return \"unknown\";\n  }\n\n  const binding = target.scope.getBinding(target.node.id.name);\n  if (!binding.references) return \"before\";\n  const referencePaths = binding.referencePaths;\n  let allStatus;\n\n  for (const path of referencePaths) {\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      return \"unknown\";\n    }\n\n    if (executionOrderCheckedNodes.has(path.node)) continue;\n    executionOrderCheckedNodes.add(path.node);\n\n    const status = this._guessExecutionStatusRelativeTo(path);\n\n    executionOrderCheckedNodes.delete(path.node);\n\n    if (allStatus && allStatus !== status) {\n      return \"unknown\";\n    } else {\n      allStatus = status;\n    }\n  }\n\n  return allStatus;\n}\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nfunction _resolve(dangerous, resolved) {\n  if (resolved && resolved.indexOf(this) >= 0) return;\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {}\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n    if (!binding.constant) return;\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    const targetKey = this.toComputedKey();\n    if (!isLiteral(targetKey)) return;\n    const targetName = targetKey.value;\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n\n      for (const prop of props) {\n        if (!prop.isProperty()) continue;\n        const key = prop.get(\"key\");\n        let match = prop.isnt(\"computed\") && key.isIdentifier({\n          name: targetName\n        });\n        match = match || key.isLiteral({\n          value: targetName\n        });\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nfunction isConstantExpression() {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression => expression.isConstantExpression());\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.node.operator !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    return this.get(\"left\").isConstantExpression() && this.get(\"right\").isConstantExpression();\n  }\n\n  return false;\n}\n\nfunction isInStrictMode() {\n  const start = this.isProgram() ? this : this.parentPath;\n  const strictParent = start.find(path => {\n    if (path.isProgram({\n      sourceType: \"module\"\n    })) return true;\n    if (path.isClass()) return true;\n    if (!path.isProgram() && !path.isFunction()) return false;\n\n    if (path.isArrowFunctionExpression() && !path.get(\"body\").isBlockStatement()) {\n      return false;\n    }\n\n    const body = path.isFunction() ? path.node.body : path.node;\n\n    for (const directive of body.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n  return !!strictParent;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._call = _call;\nexports._getQueueContexts = _getQueueContexts;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncParent = _resyncParent;\nexports._resyncRemoved = _resyncRemoved;\nexports.call = call;\nexports.isBlacklisted = exports.isDenylisted = isDenylisted;\nexports.popContext = popContext;\nexports.pushContext = pushContext;\nexports.requeue = requeue;\nexports.resync = resync;\nexports.setContext = setContext;\nexports.setKey = setKey;\nexports.setScope = setScope;\nexports.setup = setup;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.visit = visit;\n\nvar _index = require(\"../index\");\n\nvar _index2 = require(\"./index\");\n\nfunction call(key) {\n  const opts = this.opts;\n  this.debug(key);\n\n  if (this.node) {\n    if (this._call(opts[key])) return true;\n  }\n\n  if (this.node) {\n    return this._call(opts[this.node.type] && opts[this.node.type][key]);\n  }\n\n  return false;\n}\n\nfunction _call(fns) {\n  if (!fns) return false;\n\n  for (const fn of fns) {\n    if (!fn) continue;\n    const node = this.node;\n    if (!node) return true;\n    const ret = fn.call(this.state, this, this.state);\n\n    if (ret && typeof ret === \"object\" && typeof ret.then === \"function\") {\n      throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n    }\n\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n\n    if (this.node !== node) return true;\n    if (this._traverseFlags > 0) return true;\n  }\n\n  return false;\n}\n\nfunction isDenylisted() {\n  var _this$opts$denylist;\n\n  const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;\n  return denylist && denylist.indexOf(this.node.type) > -1;\n}\n\nfunction restoreContext(path, context) {\n  if (path.context !== context) {\n    path.context = context;\n    path.state = context.state;\n    path.opts = context.opts;\n  }\n}\n\nfunction visit() {\n  if (!this.node) {\n    return false;\n  }\n\n  if (this.isDenylisted()) {\n    return false;\n  }\n\n  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {\n    return false;\n  }\n\n  const currentContext = this.context;\n\n  if (this.shouldSkip || this.call(\"enter\")) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n\n  restoreContext(this, currentContext);\n  this.debug(\"Recursing into...\");\n\n  _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);\n\n  restoreContext(this, currentContext);\n  this.call(\"exit\");\n  return this.shouldStop;\n}\n\nfunction skip() {\n  this.shouldSkip = true;\n}\n\nfunction skipKey(key) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n\n  this.skipKeys[key] = true;\n}\n\nfunction stop() {\n  this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;\n}\n\nfunction setScope() {\n  if (this.opts && this.opts.noScope) return;\n  let path = this.parentPath;\n  if (this.key === \"key\" && path.isMethod()) path = path.parentPath;\n  let target;\n\n  while (path && !target) {\n    if (path.opts && path.opts.noScope) return;\n    target = path.scope;\n    path = path.parentPath;\n  }\n\n  this.scope = this.getScope(target);\n  if (this.scope) this.scope.init();\n}\n\nfunction setContext(context) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n\n  this._traverseFlags = 0;\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n\n  this.setScope();\n  return this;\n}\n\nfunction resync() {\n  if (this.removed) return;\n\n  this._resyncParent();\n\n  this._resyncList();\n\n  this._resyncKey();\n}\n\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\nfunction _resyncKey() {\n  if (!this.container) return;\n  if (this.node === this.container[this.key]) return;\n\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        return this.setKey(i);\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      if (this.container[key] === this.node) {\n        return this.setKey(key);\n      }\n    }\n  }\n\n  this.key = null;\n}\n\nfunction _resyncList() {\n  if (!this.parent || !this.inList) return;\n  const newContainer = this.parent[this.listKey];\n  if (this.container === newContainer) return;\n  this.container = newContainer || null;\n}\n\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    this._markRemoved();\n  }\n}\n\nfunction popContext() {\n  this.contexts.pop();\n\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\n\nfunction pushContext(context) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\n\nfunction setup(parentPath, container, listKey, key) {\n  this.listKey = listKey;\n  this.container = container;\n  this.parentPath = parentPath || this.parentPath;\n  this.setKey(key);\n}\n\nfunction setKey(key) {\n  var _this$node;\n\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;\n}\n\nfunction requeue(pathToQueue = this) {\n  if (pathToQueue.removed) return;\n  ;\n  const contexts = this.contexts;\n\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\n\nfunction _getQueueContexts() {\n  let path = this;\n  let contexts = this.contexts;\n\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n\n  return contexts;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._assertUnremoved = _assertUnremoved;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._markRemoved = _markRemoved;\nexports._remove = _remove;\nexports._removeFromScope = _removeFromScope;\nexports.remove = remove;\n\nvar _removalHooks = require(\"./lib/removal-hooks\");\n\nvar _cache = require(\"../cache\");\n\nvar _index = require(\"./index\");\n\nfunction remove() {\n  var _this$opts;\n\n  this._assertUnremoved();\n\n  this.resync();\n\n  if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {\n    this._removeFromScope();\n  }\n\n  if (this._callRemovalHooks()) {\n    this._markRemoved();\n\n    return;\n  }\n\n  this.shareCommentsWithSiblings();\n\n  this._remove();\n\n  this._markRemoved();\n}\n\nfunction _removeFromScope() {\n  const bindings = this.getBindingIdentifiers();\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\n\nfunction _callRemovalHooks() {\n  for (const fn of _removalHooks.hooks) {\n    if (fn(this, this.parentPath)) return true;\n  }\n}\n\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    this.updateSiblingKeys(this.key, -1);\n  } else {\n    this._replaceWith(null);\n  }\n}\n\nfunction _markRemoved() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;\n  if (this.parent) _cache.path.get(this.parent).delete(this.node);\n  this.node = null;\n}\n\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\"NodePath has been removed so is read-only.\");\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hooks = void 0;\nconst hooks = [function (self, parent) {\n  const removeParent = self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase()) || self.key === \"declaration\" && parent.isExportDeclaration() || self.key === \"body\" && parent.isLabeledStatement() || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === \"expression\" && parent.isExpressionStatement();\n\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && (self.key === \"consequent\" || self.key === \"alternate\") || self.key === \"body\" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: \"BlockStatement\",\n      body: []\n    });\n    return true;\n  }\n}];\nexports.hooks = hooks;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._containerInsert = _containerInsert;\nexports._containerInsertAfter = _containerInsertAfter;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._verifyNodeList = _verifyNodeList;\nexports.hoist = hoist;\nexports.insertAfter = insertAfter;\nexports.insertBefore = insertBefore;\nexports.pushContainer = pushContainer;\nexports.unshiftContainer = unshiftContainer;\nexports.updateSiblingKeys = updateSiblingKeys;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = require(\"./lib/hoister\");\n\nvar _index = require(\"./index\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  arrowFunctionExpression,\n  assertExpression,\n  assignmentExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  isExpression\n} = _t;\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return isExpression(node) ? expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        assertExpression(node);\n        this.replaceWith(callExpression(arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(expressionStatement(assignmentExpression(\"=\", cloneNode(temp), node)));\n      nodes.push(expressionStatement(cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _t = require(\"@babel/types\");\n\nvar _t2 = _t;\nconst {\n  react\n} = _t;\nconst {\n  cloneNode,\n  jsxExpressionContainer,\n  variableDeclaration,\n  variableDeclarator\n} = _t2;\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.get = get;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getNextSibling = getNextSibling;\nexports.getOpposite = getOpposite;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getPrevSibling = getPrevSibling;\nexports.getSibling = getSibling;\n\nvar _index = require(\"./index\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  getBindingIdentifiers: _getBindingIdentifiers,\n  getOuterBindingIdentifiers: _getOuterBindingIdentifiers,\n  isDeclaration,\n  numericLiteral,\n  unaryExpression\n} = _t;\nconst NORMAL_COMPLETION = 0;\nconst BREAK_COMPLETION = 1;\n\nfunction NormalCompletion(path) {\n  return {\n    type: NORMAL_COMPLETION,\n    path\n  };\n}\n\nfunction BreakCompletion(path) {\n  return {\n    type: BREAK_COMPLETION,\n    path\n  };\n}\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n\n  return null;\n}\n\nfunction addCompletionRecords(path, records, context) {\n  if (path) {\n    records.push(..._getCompletionRecords(path, context));\n  }\n\n  return records;\n}\n\nfunction completionRecordForSwitch(cases, records, context) {\n  let lastNormalCompletions = [];\n\n  for (let i = 0; i < cases.length; i++) {\n    const casePath = cases[i];\n\n    const caseCompletions = _getCompletionRecords(casePath, context);\n\n    const normalCompletions = [];\n    const breakCompletions = [];\n\n    for (const c of caseCompletions) {\n      if (c.type === NORMAL_COMPLETION) {\n        normalCompletions.push(c);\n      }\n\n      if (c.type === BREAK_COMPLETION) {\n        breakCompletions.push(c);\n      }\n    }\n\n    if (normalCompletions.length) {\n      lastNormalCompletions = normalCompletions;\n    }\n\n    records.push(...breakCompletions);\n  }\n\n  records.push(...lastNormalCompletions);\n  return records;\n}\n\nfunction normalCompletionToBreak(completions) {\n  completions.forEach(c => {\n    c.type = BREAK_COMPLETION;\n  });\n}\n\nfunction replaceBreakStatementInBreakCompletion(completions, reachable) {\n  completions.forEach(c => {\n    if (c.path.isBreakStatement({\n      label: null\n    })) {\n      if (reachable) {\n        c.path.replaceWith(unaryExpression(\"void\", numericLiteral(0)));\n      } else {\n        c.path.remove();\n      }\n    }\n  });\n}\n\nfunction getStatementListCompletion(paths, context) {\n  const completions = [];\n\n  if (context.canHaveBreak) {\n    let lastNormalCompletions = [];\n\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const newContext = Object.assign({}, context, {\n        inCaseClause: false\n      });\n\n      if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {\n        newContext.shouldPopulateBreak = true;\n      } else {\n        newContext.shouldPopulateBreak = false;\n      }\n\n      const statementCompletions = _getCompletionRecords(path, newContext);\n\n      if (statementCompletions.length > 0 && statementCompletions.every(c => c.type === BREAK_COMPLETION)) {\n        if (lastNormalCompletions.length > 0 && statementCompletions.every(c => c.path.isBreakStatement({\n          label: null\n        }))) {\n          normalCompletionToBreak(lastNormalCompletions);\n          completions.push(...lastNormalCompletions);\n\n          if (lastNormalCompletions.some(c => c.path.isDeclaration())) {\n            completions.push(...statementCompletions);\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n\n          replaceBreakStatementInBreakCompletion(statementCompletions, false);\n        } else {\n          completions.push(...statementCompletions);\n\n          if (!context.shouldPopulateBreak) {\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n        }\n\n        break;\n      }\n\n      if (i === paths.length - 1) {\n        completions.push(...statementCompletions);\n      } else {\n        lastNormalCompletions = [];\n\n        for (let i = 0; i < statementCompletions.length; i++) {\n          const c = statementCompletions[i];\n\n          if (c.type === BREAK_COMPLETION) {\n            completions.push(c);\n          }\n\n          if (c.type === NORMAL_COMPLETION) {\n            lastNormalCompletions.push(c);\n          }\n        }\n      }\n    }\n  } else if (paths.length) {\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const pathCompletions = _getCompletionRecords(paths[i], context);\n\n      if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {\n        completions.push(...pathCompletions);\n        break;\n      }\n    }\n  }\n\n  return completions;\n}\n\nfunction _getCompletionRecords(path, context) {\n  let records = [];\n\n  if (path.isIfStatement()) {\n    records = addCompletionRecords(path.get(\"consequent\"), records, context);\n    records = addCompletionRecords(path.get(\"alternate\"), records, context);\n  } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isProgram() || path.isBlockStatement()) {\n    return getStatementListCompletion(path.get(\"body\"), context);\n  } else if (path.isFunction()) {\n    return _getCompletionRecords(path.get(\"body\"), context);\n  } else if (path.isTryStatement()) {\n    records = addCompletionRecords(path.get(\"block\"), records, context);\n    records = addCompletionRecords(path.get(\"handler\"), records, context);\n  } else if (path.isCatchClause()) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isSwitchStatement()) {\n    return completionRecordForSwitch(path.get(\"cases\"), records, context);\n  } else if (path.isSwitchCase()) {\n    return getStatementListCompletion(path.get(\"consequent\"), {\n      canHaveBreak: true,\n      shouldPopulateBreak: false,\n      inCaseClause: true\n    });\n  } else if (path.isBreakStatement()) {\n    records.push(BreakCompletion(path));\n  } else {\n    records.push(NormalCompletion(path));\n  }\n\n  return records;\n}\n\nfunction getCompletionRecords() {\n  const records = _getCompletionRecords(this, {\n    canHaveBreak: false,\n    shouldPopulateBreak: false,\n    inCaseClause: false\n  });\n\n  return records.map(r => r.path);\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return _getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return _getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  const search = [path];\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = _getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (isDeclaration(declaration)) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child)) {\n          search.push(...child);\n        } else if (child.node) {\n          search.push(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addComment = addComment;\nexports.addComments = addComments;\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  addComment: _addComment,\n  addComments: _addComments\n} = _t;\n\nfunction shareCommentsWithSiblings() {\n  if (typeof this.key === \"string\") return;\n  const node = this.node;\n  if (!node) return;\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n\n  if (hasPrev && !hasNext) {\n    prev.addComments(\"trailing\", trailing);\n  } else if (hasNext && !hasPrev) {\n    next.addComments(\"leading\", leading);\n  }\n}\n\nfunction addComment(type, content, line) {\n  _addComment(this.node, type, content, line);\n}\n\nfunction addComments(type, comments) {\n  _addComments(this.node, type, comments);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.merge = merge;\nexports.verify = verify;\n\nvar virtualTypes = require(\"./path/lib/virtual-types\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  DEPRECATED_KEYS,\n  FLIPPED_ALIAS_KEYS,\n  TYPES\n} = _t;\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      for (const type of wrapper.types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecatedKey = DEPRECATED_KEYS[nodeType];\n\n    if (deprecatedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`);\n      aliases = [deprecatedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors, states = [], wrapper) {\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  const newFn = function (path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\" || key === \"blacklist\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Hub {\n  getCode() {}\n\n  getScope() {}\n\n  addHelper() {\n    throw new Error(\"Helpers are not supported by the default hub.\");\n  }\n\n  buildError(node, msg, Error = TypeError) {\n    return new Error(msg);\n  }\n\n}\n\nexports.default = Hub;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Hub\", {\n  enumerable: true,\n  get: function () {\n    return _hub.default;\n  }\n});\nObject.defineProperty(exports, \"NodePath\", {\n  enumerable: true,\n  get: function () {\n    return _path.default;\n  }\n});\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return _scope.default;\n  }\n});\nexports.visitors = exports.default = void 0;\n\nvar _context = require(\"./context\");\n\nvar visitors = require(\"./visitors\");\n\nexports.visitors = visitors;\n\nvar _t = require(\"@babel/types\");\n\nvar cache = require(\"./cache\");\n\nvar _path = require(\"./path\");\n\nvar _scope = require(\"./scope\");\n\nvar _hub = require(\"./hub\");\n\nconst {\n  VISITOR_KEYS,\n  removeProperties,\n  traverseFast\n} = _t;\n\nfunction traverse(parent, opts = {}, scope, state, parentPath) {\n  if (!parent) return;\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\"You must pass a scope and parentPath unless traversing a Program/File. \" + `Instead of that you tried to traverse a ${parent.type} node without ` + \"passing scope and parentPath.\");\n    }\n  }\n\n  if (!VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts);\n  traverse.node(parent, opts, scope, state, parentPath);\n}\n\nvar _default = traverse;\nexports.default = _default;\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node, enter) {\n  return traverseFast(node, enter);\n};\n\ntraverse.node = function (node, opts, scope, state, parentPath, skipKeys) {\n  const keys = VISITOR_KEYS[node.type];\n  if (!keys) return;\n  const context = new _context.default(scope, opts, state, parentPath);\n\n  for (const key of keys) {\n    if (skipKeys && skipKeys[key]) continue;\n    if (context.visit(node, key)) return;\n  }\n};\n\ntraverse.clearNode = function (node, opts) {\n  removeProperties(node, opts);\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (tree, opts) {\n  traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\nfunction hasDenylistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (tree, type, denylistTypes) {\n  if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;\n  if (tree.type === type) return true;\n  const state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    noScope: true,\n    denylist: denylistTypes,\n    enter: hasDenylistedType\n  }, null, state);\n  return state.has;\n};\n\ntraverse.cache = cache;"],"sourceRoot":""}