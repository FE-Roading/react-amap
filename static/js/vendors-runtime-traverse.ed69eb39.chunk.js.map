{"version":3,"sources":["../node_modules/@babel/traverse/lib/index.js","../node_modules/@babel/traverse/lib/context.js","../node_modules/@babel/traverse/lib/scope/lib/renamer.js","../node_modules/@babel/traverse/lib/path/ancestry.js","../node_modules/@babel/traverse/lib/path/inference/index.js","../node_modules/@babel/traverse/lib/path/inference/inferers.js","../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js","../node_modules/@babel/traverse/lib/path/replacement.js","../node_modules/@babel/traverse/lib/path/evaluation.js","../node_modules/@babel/traverse/lib/path/conversion.js","../node_modules/@babel/traverse/lib/path/introspection.js","../node_modules/@babel/traverse/lib/path/context.js","../node_modules/@babel/traverse/lib/path/removal.js","../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js","../node_modules/@babel/traverse/lib/path/modification.js","../node_modules/@babel/traverse/lib/path/lib/hoister.js","../node_modules/@babel/traverse/lib/path/family.js","../node_modules/@babel/traverse/lib/path/comments.js","../node_modules/@babel/traverse/lib/visitors.js","../node_modules/@babel/traverse/lib/hub.js","../node_modules/@babel/traverse/lib/path/index.js","../node_modules/@babel/traverse/lib/cache.js","../node_modules/@babel/traverse/lib/path/lib/virtual-types.js","../node_modules/@babel/traverse/lib/scope/index.js","../node_modules/@babel/traverse/lib/scope/binding.js"],"names":["Object","defineProperty","exports","value","enumerable","get","_path","default","_scope","_hub","visitors","_context","_interopRequireDefault","require","_interopRequireWildcard","t","cache","_getRequireWildcardCache","WeakMap","obj","__esModule","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","traverse","parent","opts","scope","state","parentPath","noScope","type","Error","VISITOR_KEYS","explode","node","_default","hasDenylistedType","path","stop","verify","cheap","enter","traverseFast","skipKeys","keys","context","visit","clearNode","removeProperties","delete","tree","hasType","denylistTypes","includes","denylist","TraversalContext","this","queue","priorityQueue","exit","length","listKey","container","notPriority","trap","push","shouldVisit","create","visitQueue","visited","WeakSet","resync","contexts","pushContext","process","add","popContext","nodes","Array","isArray","visitMultiple","visitSingle","_helperSplitExportDeclaration","renameVisitor","ReferencedIdentifier","name","oldName","newName","Scope","bindingIdentifierEquals","binding","identifier","isMethod","computed","skip","skipKey","skipAllButComputedMethodKey","isVariableDeclaration","ids","getOuterBindingIdentifiers","Renamer","parentDeclar","maybeExportDeclar","isExportDeclaration","isExportDefaultDeclaration","id","block","find","isDeclaration","isFunctionExpression","isClassExpression","maybeConvertFromExportDeclaration","blockToTraverse","cases","forEach","c","removeOwnBinding","bindings","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","findParent","callback","getFunctionParent","p","isFunction","getStatementParent","isStatement","isProgram","isFile","getEarliestCommonAncestorFrom","paths","getDeepestCommonAncestorFrom","deepest","i","ancestries","earliest","indexOf","parentKey","filter","lastCommonIndex","lastCommon","minDepth","Infinity","map","ancestry","unshift","first","depthLoop","shouldMatch","getAncestry","isAncestor","maybeDescendant","isDescendant","maybeAncestor","inType","candidateTypes","getTypeAnnotation","typeAnnotation","_getTypeAnnotation","anyTypeAnnotation","isTypeAnnotation","isVariableDeclarator","declar","declarParent","isForInStatement","stringTypeAnnotation","isForOfStatement","voidTypeAnnotation","typeAnnotationInferringNodes","_inferer","inferer","inferers","validParent","isBaseType","baseName","soft","_isBaseType","couldBeBaseType","isAnyTypeAnnotation","isUnionTypeAnnotation","types","type2","baseTypeStrictlyMatches","rightArg","left","right","isFlowBaseAnnotation","isGenericType","genericName","isGenericTypeAnnotation","isIdentifier","isStringTypeAnnotation","isNumberTypeAnnotation","isBooleanTypeAnnotation","isMixedTypeAnnotation","isEmptyTypeAnnotation","isVoidTypeAnnotation","VariableDeclarator","_type","init","isCallExpression","hasBinding","ArrayExpression","TypeCastExpression","NewExpression","genericTypeAnnotation","callee","TemplateLiteral","UnaryExpression","operator","NUMBER_UNARY_OPERATORS","numberTypeAnnotation","STRING_UNARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","booleanTypeAnnotation","BinaryExpression","NUMBER_BINARY_OPERATORS","BOOLEAN_BINARY_OPERATORS","unionTypeAnnotation","LogicalExpression","argumentTypes","isTSTypeAnnotation","createTSUnionType","createFlowUnionType","createUnionTypeAnnotation","ConditionalExpression","SequenceExpression","pop","ParenthesizedExpression","AssignmentExpression","UpdateExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","nullLiteralTypeAnnotation","RegExpLiteral","ObjectExpression","RestElement","ClassDeclaration","ClassExpression","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","CallExpression","isObjectKeys","arrayTypeAnnotation","isArrayFrom","isObjectValues","isObjectEntries","tupleTypeAnnotation","resolveCall","TaggedTemplateExpression","_infererReference","buildMatchMemberExpression","resolve","is","returnType","isReferenced","getBinding","functionConstantViolations","constantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","concat","violation","getTypeAnnotationBindingConstantViolations","functions","violations","slice","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","target","typeofPath","typePath","BOOLEAN_NUMBER_BINARY_OPERATORS","isUnaryExpression","isLiteral","typeValue","createTypeAnnotationBasedOnTypeof","isIfStatement","isConditionalExpression","getParentConditionalPath","isLogicalExpression","isBinaryExpression","replaceWithMultiple","_pathCache$get","_verifyNodeList","inheritLeadingComments","inheritTrailingComments","_cache","insertAfter","requeue","remove","replaceWithSourceString","replacement","_parser","parse","err","loc","message","_codeFrame","codeFrameColumns","start","line","column","code","program","body","expression","_index","replaceWith","removed","_index2","nodePath","isNodeType","isExpression","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","expressionStatement","replaceExpressionWithStatements","oldNode","inheritsComments","removeComments","_replaceWith","setScope","_pathCache$get2","ReferenceError","inList","validate","debug","toSequenceExpression","functionParent","isParentAsync","arrowFunctionExpression","blockStatement","callExpression","hoistVariablesVisitor","completionRecords","getCompletionRecords","isExpressionStatement","loop","isLoop","uid","getData","generateDeclaredUidIdentifier","pushContainer","returnStatement","cloneNode","setData","assignmentExpression","arrowFunctionToExpression","FUNCTION_TYPES","awaitExpression","replaceInline","_containerInsertAfter","Function","VariableDeclaration","kind","getBindingIdentifiers","exprs","declarations","evaluateTruthy","res","evaluate","confident","deoptPath","seen","Map","evaluateCached","undefined","deopt","VALID_CALLEES","INVALID_METHODS","existing","resolved","item","val","isSequenceExpression","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","isTemplateLiteral","evaluateQuasis","quasis","isTaggedTemplateExpression","isMemberExpression","object","property","quasi","testResult","isExpressionWrapper","isReferencedIdentifier","end","hasValue","NaN","prefix","argument","isClass","arg","isArrayExpression","arr","elems","elemValue","isObjectExpression","props","prop","isObjectMethod","isSpreadElement","wasConfident","leftConfident","rightConfident","Math","pow","func","global","args","apply","_evaluate","raw","str","elem","cooked","expr","String","toComputedKey","isProperty","stringLiteral","ensureBlock","bodyNode","isBlockStatement","statements","stringPath","setup","arrowFunctionToShadowed","isArrowFunctionExpression","unwrapFunctionEnvironment","isFunctionDeclaration","buildCodeFrameError","hoistFunctionEnvironment","allowInsertArrow","specCompliant","noNewArrows","thisBinding","checkBinding","generateUidIdentifier","objectExpression","unshiftContainer","hub","addHelper","thisExpression","memberExpression","_helperFunctionName","fnPath","thisEnvFn","isClassProperty","static","inConstructor","getScopeInformation","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","allSuperCalls","child","ClassProperty","isSuper","superBinding","getSuperBinding","superCall","argumentsBinding","argumentsChild","argsRef","newTargetBinding","metaProperty","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","standardizeSuperProperty","isAssignment","isAssignmentExpression","isCall","getSuperPropBinding","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","jsxIdentifier","assignmentPath","op","tmp","binaryExpression","isUpdateExpression","updateExpr","computedKey","parts","numericLiteral","sequenceExpression","isClassMethod","superClass","supers","argsBinding","restElement","super","spreadElement","propName","fnBody","argsList","method","valueIdent","cacheKey","data","ThisExpression","JSXIdentifier","isJSXMemberExpression","isJSXOpeningElement","MemberExpression","MetaProperty","matchesPattern","pattern","allowPartial","isStatic","isnt","equals","isType","isFor","isCompletionRecord","allowInsideFunction","isStatementOrBlock","isLabeledStatement","STATEMENT_OR_BLOCK_KEYS","referencesImport","moduleSource","importName","isOptionalMemberExpression","isImportDeclaration","source","isImportDefaultSpecifier","isImportNamespaceSpecifier","isImportSpecifier","imported","getSource","getCode","willIMaybeExecuteBefore","funcParent","getOuterFunction","_guessExecutionStatusRelativeToDifferentFunctions","commonPath","commonIndex","isExecutionUncertainInList","divergence","keyPosition","references","allStatus","referencePaths","executionOrderCheckedNodes","dangerous","_resolve","constant","ret","isTypeCastExpression","targetKey","targetName","match","isNaN","isConstantExpression","isRegExpLiteral","every","isInStrictMode","sourceType","directives","getProgramParent","isExecutionUncertain","maxIndex","_call","fns","fn","then","_traverseFlags","isBlacklisted","isDenylisted","_this$opts$denylist","blacklist","shouldSkip","shouldStop","SHOULD_SKIP","SHOULD_STOP","getScope","setContext","_resyncParent","_resyncList","_resyncKey","setKey","newContainer","_resyncRemoved","_markRemoved","_this$node","pathToQueue","maybeQueue","_getQueueContexts","_this$opts","_assertUnremoved","_removeFromScope","_callRemovalHooks","shareCommentsWithSiblings","_remove","removeBinding","_removalHooks","hooks","splice","updateSiblingKeys","REMOVED","self","isWhile","isSwitchCase","expressions","isBinary","insertBefore","nodes_","isExportNamedDeclaration","isJSXElement","isForStatement","_containerInsertBefore","shouldInsertCurrentNode","_containerInsert","from","to","getSibling","isPattern","assertExpression","temp","fromIndex","incrementBy","msg","verifiedNodes","hoist","hoister","_hoister","run","referenceVisitor","isJSXIdentifier","react","isCompatTag","breakOnScopePaths","mutableBinding","PathHoister","scopes","attachAfter","isCompatibleScope","_getAttachmentPath","targetScope","hasOwnBinding","getAttachmentParentForPath","violationPath","hasOwnParamBindings","getNextScopeAttachmentParent","bodies","_blockHoist","getCompatibleScopes","attachTo","getAttachmentPath","declarator","variableDeclarator","variableDeclaration","attached","children","jsxExpressionContainer","getOpposite","addCompletionRecords","isDoExpression","isTryStatement","isCatchClause","isSwitchStatement","isLastCaseWithConsequent","consequent","breakStatement","findBreak","prevSibling","getPrevSibling","buildUndefinedNode","statementFinder","statement","some","completionRecordForSwitch","getNextSibling","getAllNextSiblings","_key","sibling","siblings","getAllPrevSiblings","split","_getKey","_getPattern","_","part","duplicates","getBindingIdentifierPaths","outerOnly","search","shift","_ids","declaration","getOuterBindingIdentifierPaths","_findBreak","_findBreak2","isBreakStatement","trailing","trailingComments","leading","leadingComments","prev","next","hasPrev","Boolean","hasNext","addComments","addComment","content","comments","merge","states","wrapper","rootVisitor","visitor","visitorType","wrapWithStateOrWrapper","nodeVisitor","mergePair","virtualTypes","_exploded","nodeType","shouldIgnoreKey","ensureEntranceObjects","ensureCallbackArrays","wrapCheck","aliases","FLIPPED_ALIAS_KEYS","deprecatedKey","DEPRECATED_KEYS","console","trace","alias","assign","_verified","validateVisitorMethods","TYPES","visitorKey","TypeError","oldVisitor","newVisitor","newFn","toString","checkPath","arguments","dest","src","Hub","_debug","_generator","NodePath_ancestry","NodePath_inference","NodePath_replacement","NodePath_evaluation","NodePath_conversion","NodePath_introspection","NodePath_context","NodePath_removal","NodePath_modification","NodePath_family","NodePath_comments","NodePath","isScope","def","SyntaxError","buildError","join","enabled","getPathLocation","v","targetNode","typeKey","virtualType","clear","clearPath","clearScope","ForAwaitStatement","NumericLiteralTypeAnnotation","ExistentialTypeParam","SpreadProperty","RestProperty","Flow","Pure","Generated","User","Var","BlockScoped","Referenced","Expression","Statement","BindingIdentifier","ReferencedMemberExpression","grandparent","isBinding","isForXStatement","isBlockScoped","isVar","isUser","isPure","isFlow","importKind","exportKind","isObjectPattern","await","_renamer","_binding","_globals","gatherNodeParts","isModuleDeclaration","isExportAllDeclaration","specifiers","isModuleSpecifier","local","properties","meta","openingElement","openingFragment","namespace","collectorVisitor","For","FOR_INIT_KEYS","registerBinding","Declaration","registerDeclaration","ForXStatement","ExportDeclaration","isClassDeclaration","reference","decl","LabeledStatement","getBlockParent","assignments","CatchClause","NOT_LOCAL_BINDING","params","param","labels","inited","globals","uids","crawling","cached","generateUid","toIdentifier","replace","_generateUid","hasLabel","hasGlobal","hasReference","defaultName","generateUidBasedOnNode","isThisExpression","dontPush","generateUidIdentifierBasedOnNode","rename","sep","repeat","log","arrayLikeIsIterable","helperName","getLabel","label","registerLabel","specifier","unaryExpression","reassign","bindingPath","declarators","getOwnBinding","checkBlockScopedCollisions","registerConstantViolation","constantsOnly","isClassBody","elements","tag","isPureish","crawl","programParent","typeVisitors","addGlobal","ref","unique","blockHoist","dataKey","declarPath","isFunctionParent","isBlockParent","kinds","getBindingIdentifier","previousPath","_previousPath","_this$getBinding","noGlobals","parentHasBinding","hasUid","contextVariables","_this$parent","info","_this$getBinding2","_parent","isKey","builtin","Binding","referenced","clearValue","hasDeoptedValue"],"mappings":"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","file":"static/js/vendors-runtime-traverse.ed69eb39.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"NodePath\", {\n  enumerable: true,\n  get: function () {\n    return _path.default;\n  }\n});\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return _scope.default;\n  }\n});\nObject.defineProperty(exports, \"Hub\", {\n  enumerable: true,\n  get: function () {\n    return _hub.default;\n  }\n});\nexports.visitors = exports.default = void 0;\n\nvar _context = _interopRequireDefault(require(\"./context\"));\n\nvar visitors = _interopRequireWildcard(require(\"./visitors\"));\n\nexports.visitors = visitors;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar cache = _interopRequireWildcard(require(\"./cache\"));\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar _scope = _interopRequireDefault(require(\"./scope\"));\n\nvar _hub = _interopRequireDefault(require(\"./hub\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction traverse(parent, opts = {}, scope, state, parentPath) {\n  if (!parent) return;\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\"You must pass a scope and parentPath unless traversing a Program/File. \" + `Instead of that you tried to traverse a ${parent.type} node without ` + \"passing scope and parentPath.\");\n    }\n  }\n\n  if (!t.VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts);\n  traverse.node(parent, opts, scope, state, parentPath);\n}\n\nvar _default = traverse;\nexports.default = _default;\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node, enter) {\n  return t.traverseFast(node, enter);\n};\n\ntraverse.node = function (node, opts, scope, state, parentPath, skipKeys) {\n  const keys = t.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  const context = new _context.default(scope, opts, state, parentPath);\n\n  for (const key of keys) {\n    if (skipKeys && skipKeys[key]) continue;\n    if (context.visit(node, key)) return;\n  }\n};\n\ntraverse.clearNode = function (node, opts) {\n  t.removeProperties(node, opts);\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (tree, opts) {\n  t.traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\nfunction hasDenylistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (tree, type, denylistTypes) {\n  if (denylistTypes == null ? void 0 : denylistTypes.includes(tree.type)) return false;\n  if (tree.type === type) return true;\n  const state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    noScope: true,\n    denylist: denylistTypes,\n    enter: hasDenylistedType\n  }, null, state);\n  return state.has;\n};\n\ntraverse.cache = cache;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst testing = process.env.NODE_ENV === \"test\";\n\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.priorityQueue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = t.VISITOR_KEYS[node.type];\n    if (!(keys == null ? void 0 : keys.length)) return false;\n\n    for (const key of keys) {\n      if (node[key]) return true;\n    }\n\n    return false;\n  }\n\n  create(node, obj, key, listKey) {\n    return _path.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey\n    });\n  }\n\n  maybeQueue(path, notPriority) {\n    if (this.trap) {\n      throw new Error(\"Infinite cycle detected\");\n    }\n\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n\n    for (const path of queue) {\n      path.resync();\n\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        path.pushContext(this);\n      }\n\n      if (path.key === null) continue;\n\n      if (testing && queue.length >= 10000) {\n        this.trap = true;\n      }\n\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    for (const path of queue) {\n      path.popContext();\n    }\n\n    this.queue = null;\n    return stop;\n  }\n\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n\n}\n\nexports.default = TraversalContext;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = _interopRequireDefault(require(\"../binding\"));\n\nvar _helperSplitExportDeclaration = _interopRequireDefault(require(\"@babel/helper-split-export-declaration\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      skipAllButComputedMethodKey(path);\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = t.identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(t.identifier(this.newName), t.toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = t.identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: t.identifier(this.newName)\n    });\n    path.replaceWith(t.assignmentExpression(\"=\", t.identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;\n\nfunction skipAllButComputedMethodKey(path) {\n  if (!path.isMethod() || !path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = t.VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findParent = findParent;\nexports.find = find;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getAncestry = getAncestry;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\nexports.inType = inType;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction findParent(callback) {\n  let path = this;\n\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n\n  return null;\n}\n\nfunction find(callback) {\n  let path = this;\n\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n\n  return null;\n}\n\nfunction getFunctionParent() {\n  return this.findParent(p => p.isFunction());\n}\n\nfunction getStatementParent() {\n  let path = this;\n\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\"File/Program node, we can't possibly find a statement parent to this\");\n  }\n\n  return path;\n}\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    let earliest;\n    const keys = t.VISITOR_KEYS[deepest.type];\n\n    for (const ancestry of ancestries) {\n      const path = ancestry[i + 1];\n\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      if (path.listKey && earliest.listKey === path.listKey) {\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      const currentKeyIndex = keys.indexOf(path.parentKey);\n\n      if (earliestKeyIndex > currentKeyIndex) {\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  let minDepth = Infinity;\n  let lastCommonIndex, lastCommon;\n  const ancestries = paths.map(path => {\n    const ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n  const first = ancestries[0];\n\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        break depthLoop;\n      }\n    }\n\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\nfunction getAncestry() {\n  let path = this;\n  const paths = [];\n\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n\n  return paths;\n}\n\nfunction isAncestor(maybeDescendant) {\n  return maybeDescendant.isDescendant(this);\n}\n\nfunction isDescendant(maybeAncestor) {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\n\nfunction inType(...candidateTypes) {\n  let path = this;\n\n  while (path) {\n    for (const type of candidateTypes) {\n      if (path.node.type === type) return true;\n    }\n\n    path = path.parentPath;\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypeAnnotation = getTypeAnnotation;\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.couldBeBaseType = couldBeBaseType;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.isGenericType = isGenericType;\n\nvar inferers = _interopRequireWildcard(require(\"./inferers\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n  let type = this._getTypeAnnotation() || t.anyTypeAnnotation();\n  if (t.isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\nconst typeAnnotationInferringNodes = new WeakSet();\n\nfunction _getTypeAnnotation() {\n  const node = this.node;\n\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return t.stringTypeAnnotation();\n      }\n\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return t.anyTypeAnnotation();\n      }\n\n      return t.voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    var _inferer;\n\n    let inferer = inferers[node.type];\n\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    inferer = inferers[this.parentPath.type];\n\n    if ((_inferer = inferer) == null ? void 0 : _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return t.isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return t.isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return t.isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return t.isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return t.isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return t.isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return t.isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (t.isAnyTypeAnnotation(type)) return true;\n\n  if (t.isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(rightArg) {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n\n  if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n\n  return false;\n}\n\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n  return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, {\n    name: genericName\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariableDeclarator = VariableDeclarator;\nexports.TypeCastExpression = TypeCastExpression;\nexports.NewExpression = NewExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.UnaryExpression = UnaryExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.StringLiteral = StringLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.NullLiteral = NullLiteral;\nexports.RegExpLiteral = RegExpLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ArrayExpression = ArrayExpression;\nexports.RestElement = RestElement;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nexports.CallExpression = CallExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _infererReference = _interopRequireDefault(require(\"./inferer-reference\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return t.genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return t.voidTypeAnnotation();\n  } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.stringTypeAnnotation();\n  } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return t.numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return t.stringTypeAnnotation();\n    }\n\n    return t.unionTypeAnnotation([t.stringTypeAnnotation(), t.numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return t.numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return t.numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return t.booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return t.nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return t.genericTypeAnnotation(t.identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return t.genericTypeAnnotation(t.identifier(\"Function\"));\n}\n\nconst isArrayFrom = t.buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = t.buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = t.buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = t.buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return t.arrayTypeAnnotation(t.stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return t.arrayTypeAnnotation(t.anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return t.arrayTypeAnnotation(t.tupleTypeAnnotation([t.stringTypeAnnotation(), t.anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return t.genericTypeAnnotation(t.identifier(\"AsyncIterator\"));\n      } else {\n        return t.genericTypeAnnotation(t.identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(types);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(types);\n  }\n\n  return t.createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return t.createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n      return {\n        typeAnnotation: t.createTSUnionType(types),\n        ifStatement\n      };\n    }\n\n    if (t.createFlowUnionType) {\n      return {\n        typeAnnotation: t.createFlowUnionType(types),\n        ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\nexports.replaceWith = replaceWith;\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = _interopRequireDefault(require(\"./index\"));\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst hoistVariablesVisitor = {\n  Function(path) {\n    path.skip();\n  },\n\n  VariableDeclaration(path) {\n    if (path.node.kind !== \"var\") return;\n    const bindings = path.getBindingIdentifiers();\n\n    for (const key of Object.keys(bindings)) {\n      path.scope.push({\n        id: bindings[key]\n      });\n    }\n\n    const exprs = [];\n\n    for (const declar of path.node.declarations) {\n      if (declar.init) {\n        exprs.push(t.expressionStatement(t.assignmentExpression(\"=\", declar.id, declar.init)));\n      }\n    }\n\n    path.replaceWithMultiple(exprs);\n  }\n\n};\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  t.inheritLeadingComments(nodes[0], this.node);\n  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = `(${replacement})`;\n    replacement = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n\n  _index.default.removeProperties(replacement);\n\n  return this.replaceWith(replacement);\n}\n\nfunction replaceWith(replacement) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index2.default) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !t.isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && t.isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = t.expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && t.isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    t.inheritsComments(replacement, oldNode);\n    t.removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    t.validate(this.parent, this.key, [node]);\n  } else {\n    t.validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const toSequenceExpression = t.toSequenceExpression(nodes, this.scope);\n\n  if (toSequenceExpression) {\n    return this.replaceWith(toSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const container = t.arrowFunctionExpression([], t.blockStatement(nodes));\n  this.replaceWith(t.callExpression(container, []));\n  this.traverse(hoistVariablesVisitor);\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        const callee = this.get(\"callee\");\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", t.returnStatement(t.cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = t.identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(t.assignmentExpression(\"=\", t.cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(t.returnStatement(path.node.expression));\n    }\n  }\n\n  const callee = this.get(\"callee\");\n  callee.arrowFunctionToExpression();\n\n  if (isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", t.FUNCTION_TYPES)) {\n    callee.set(\"async\", true);\n    this.replaceWith(t.awaitExpression(this.node));\n  }\n\n  return callee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding == null ? void 0 : binding.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toComputedKey = toComputedKey;\nexports.ensureBlock = ensureBlock;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _helperFunctionName = _interopRequireDefault(require(\"@babel/helper-function-name\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction toComputedKey() {\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!this.node.computed) {\n    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(t.returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(t.expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = t.blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  specCompliant = false,\n  noNewArrows = !specCompliant\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const thisBinding = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);\n  this.ensureBlock();\n  this.node.type = \"FunctionExpression\";\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      this.parentPath.scope.push({\n        id: checkBinding,\n        init: t.objectExpression([])\n      });\n    }\n\n    this.get(\"body\").unshiftContainer(\"body\", t.expressionStatement(t.callExpression(this.hub.addHelper(\"newArrowCheck\"), [t.thisExpression(), checkBinding ? t.identifier(checkBinding.name) : t.identifier(thisBinding)])));\n    this.replaceWith(t.callExpression(t.memberExpression((0, _helperFunctionName.default)(this, true) || this.node, t.identifier(\"bind\")), [checkBinding ? t.identifier(checkBinding.name) : t.thisExpression()]));\n  }\n}\n\nfunction hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true) {\n  const thisEnvFn = fnPath.findParent(p => {\n    return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({\n      static: false\n    });\n  });\n  const inConstructor = (thisEnvFn == null ? void 0 : thisEnvFn.node.kind) === \"constructor\";\n\n  if (thisEnvFn.isClassProperty()) {\n    throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        allSuperCalls.push(child);\n      }\n\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = t.identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => t.identifier(\"arguments\"));\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = t.identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => t.metaProperty(t.identifier(\"new\"), t.identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = t.identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = t.callExpression(t.identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", t.thisExpression());\n        superProp.replaceWith(t.memberExpression(call, t.identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? t.jsxIdentifier(thisBinding) : t.identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return thisBinding;\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    assignmentPath.node.operator = \"=\";\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, t.assignmentExpression(\"=\", tmp, superProp.node.property), true));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(tmp.name), true), value));\n    } else {\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, superProp.node.property));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(superProp.node.property.name)), value));\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [t.assignmentExpression(\"=\", tmp, t.memberExpression(superProp.node.object, computedKey ? t.assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), t.assignmentExpression(\"=\", t.memberExpression(superProp.node.object, computedKey ? t.identifier(computedKey.name) : superProp.node.property, superProp.node.computed), t.binaryExpression(\"+\", t.identifier(tmp.name), t.numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(t.identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(t.sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return t.thisExpression();\n    const supers = new WeakSet();\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        if (supers.has(child.node)) return;\n        supers.add(child.node);\n        child.replaceWithMultiple([child.node, t.assignmentExpression(\"=\", t.identifier(thisBinding), t.identifier(\"this\"))]);\n      }\n\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return t.arrowFunctionExpression([t.restElement(argsBinding)], t.callExpression(t.super(), [t.spreadElement(t.identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = t.memberExpression(t.super(), t.identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = t.memberExpression(t.super(), t.identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = t.assignmentExpression(\"=\", fnBody, t.identifier(valueIdent.name));\n    }\n\n    return t.arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse({\n    ClassProperty(child) {\n      child.skip();\n    },\n\n    Function(child) {\n      if (child.isArrowFunctionExpression()) return;\n      child.skip();\n    },\n\n    ThisExpression(child) {\n      thisPaths.push(child);\n    },\n\n    JSXIdentifier(child) {\n      if (child.node.name !== \"this\") return;\n\n      if (!child.parentPath.isJSXMemberExpression({\n        object: child.node\n      }) && !child.parentPath.isJSXOpeningElement({\n        name: child.node\n      })) {\n        return;\n      }\n\n      thisPaths.push(child);\n    },\n\n    CallExpression(child) {\n      if (child.get(\"callee\").isSuper()) superCalls.push(child);\n    },\n\n    MemberExpression(child) {\n      if (child.get(\"object\").isSuper()) superProps.push(child);\n    },\n\n    ReferencedIdentifier(child) {\n      if (child.node.name !== \"arguments\") return;\n      argumentsPaths.push(child);\n    },\n\n    MetaProperty(child) {\n      if (!child.get(\"meta\").isIdentifier({\n        name: \"new\"\n      })) return;\n      if (!child.get(\"property\").isIdentifier({\n        name: \"target\"\n      })) return;\n      newTargetPaths.push(child);\n    }\n\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchesPattern = matchesPattern;\nexports.has = has;\nexports.isStatic = isStatic;\nexports.isnt = isnt;\nexports.equals = equals;\nexports.isNodeType = isNodeType;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.referencesImport = referencesImport;\nexports.getSource = getSource;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;\nexports.resolve = resolve;\nexports._resolve = _resolve;\nexports.isConstantExpression = isConstantExpression;\nexports.isInStrictMode = isInStrictMode;\nexports.is = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction matchesPattern(pattern, allowPartial) {\n  return t.matchesPattern(this.node, pattern, allowPartial);\n}\n\nfunction has(key) {\n  const val = this.node && this.node[key];\n\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\n\nconst is = has;\nexports.is = is;\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\nfunction isNodeType(type) {\n  return t.isType(this.type, type);\n}\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return t.isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return t.isExpression(replacement);\n  }\n\n  return false;\n}\n\nfunction isCompletionRecord(allowInsideFunction) {\n  let path = this;\n  let first = true;\n\n  do {\n    const container = path.container;\n\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return t.STATEMENT_OR_BLOCK_KEYS.includes(this.key);\n  }\n}\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) {\n    if ((this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? t.isStringLiteral(this.node.property, {\n      value: importName\n    }) : this.node.property.name === importName)) {\n      const object = this.get(\"object\");\n      return object.isReferencedIdentifier() && object.referencesImport(moduleSource, \"*\");\n    }\n\n    return false;\n  }\n\n  const binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && t.isIdentifier(path.node.imported, {\n    name: importName\n  })) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getSource() {\n  const node = this.node;\n\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n\n  return \"\";\n}\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path) {\n  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;\n}\n\nfunction isExecutionUncertain(type, key) {\n  switch (type) {\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths, maxIndex) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  const funcParent = {\n    this: getOuterFunction(this),\n    target: getOuterFunction(target)\n  };\n\n  if (funcParent.target.node !== funcParent.this.node) {\n    return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: this.getAncestry()\n  };\n  if (paths.target.indexOf(this) >= 0) return \"after\";\n  if (paths.this.indexOf(target) >= 0) return \"before\";\n  let commonPath;\n  const commonIndex = {\n    target: 0,\n    this: 0\n  };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\"Internal Babel error - The two compared nodes\" + \" don't appear to belong to the same program.\");\n  }\n\n  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1]\n  };\n\n  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  const keys = t.VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey)\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\nconst executionOrderCheckedNodes = new WeakSet();\n\nfunction _guessExecutionStatusRelativeToDifferentFunctions(target) {\n  if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {\n    return \"unknown\";\n  }\n\n  const binding = target.scope.getBinding(target.node.id.name);\n  if (!binding.references) return \"before\";\n  const referencePaths = binding.referencePaths;\n  let allStatus;\n\n  for (const path of referencePaths) {\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      return \"unknown\";\n    }\n\n    if (executionOrderCheckedNodes.has(path.node)) continue;\n    executionOrderCheckedNodes.add(path.node);\n\n    const status = this._guessExecutionStatusRelativeTo(path);\n\n    executionOrderCheckedNodes.delete(path.node);\n\n    if (allStatus && allStatus !== status) {\n      return \"unknown\";\n    } else {\n      allStatus = status;\n    }\n  }\n\n  return allStatus;\n}\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nfunction _resolve(dangerous, resolved) {\n  if (resolved && resolved.indexOf(this) >= 0) return;\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {}\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n    if (!binding.constant) return;\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    const targetKey = this.toComputedKey();\n    if (!t.isLiteral(targetKey)) return;\n    const targetName = targetKey.value;\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n\n      for (const prop of props) {\n        if (!prop.isProperty()) continue;\n        const key = prop.get(\"key\");\n        let match = prop.isnt(\"computed\") && key.isIdentifier({\n          name: targetName\n        });\n        match = match || key.isLiteral({\n          value: targetName\n        });\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nfunction isConstantExpression() {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression => expression.isConstantExpression());\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.node.operator !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    return this.get(\"left\").isConstantExpression() && this.get(\"right\").isConstantExpression();\n  }\n\n  return false;\n}\n\nfunction isInStrictMode() {\n  const start = this.isProgram() ? this : this.parentPath;\n  const strictParent = start.find(path => {\n    if (path.isProgram({\n      sourceType: \"module\"\n    })) return true;\n    if (path.isClass()) return true;\n    if (!path.isProgram() && !path.isFunction()) return false;\n\n    if (path.isArrowFunctionExpression() && !path.get(\"body\").isBlockStatement()) {\n      return false;\n    }\n\n    const body = path.isFunction() ? path.node.body : path.node;\n\n    for (const directive of body.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n  return !!strictParent;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.call = call;\nexports._call = _call;\nexports.isBlacklisted = exports.isDenylisted = isDenylisted;\nexports.visit = visit;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.setScope = setScope;\nexports.setContext = setContext;\nexports.resync = resync;\nexports._resyncParent = _resyncParent;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncRemoved = _resyncRemoved;\nexports.popContext = popContext;\nexports.pushContext = pushContext;\nexports.setup = setup;\nexports.setKey = setKey;\nexports.requeue = requeue;\nexports._getQueueContexts = _getQueueContexts;\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = require(\"./index\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction call(key) {\n  const opts = this.opts;\n  this.debug(key);\n\n  if (this.node) {\n    if (this._call(opts[key])) return true;\n  }\n\n  if (this.node) {\n    return this._call(opts[this.node.type] && opts[this.node.type][key]);\n  }\n\n  return false;\n}\n\nfunction _call(fns) {\n  if (!fns) return false;\n\n  for (const fn of fns) {\n    if (!fn) continue;\n    const node = this.node;\n    if (!node) return true;\n    const ret = fn.call(this.state, this, this.state);\n\n    if (ret && typeof ret === \"object\" && typeof ret.then === \"function\") {\n      throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n    }\n\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n\n    if (this.node !== node) return true;\n    if (this._traverseFlags > 0) return true;\n  }\n\n  return false;\n}\n\nfunction isDenylisted() {\n  var _this$opts$denylist;\n\n  const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;\n  return denylist && denylist.indexOf(this.node.type) > -1;\n}\n\nfunction visit() {\n  if (!this.node) {\n    return false;\n  }\n\n  if (this.isDenylisted()) {\n    return false;\n  }\n\n  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {\n    return false;\n  }\n\n  if (this.shouldSkip || this.call(\"enter\") || this.shouldSkip) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n\n  this.debug(\"Recursing into...\");\n\n  _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);\n\n  this.call(\"exit\");\n  return this.shouldStop;\n}\n\nfunction skip() {\n  this.shouldSkip = true;\n}\n\nfunction skipKey(key) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n\n  this.skipKeys[key] = true;\n}\n\nfunction stop() {\n  this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;\n}\n\nfunction setScope() {\n  if (this.opts && this.opts.noScope) return;\n  let path = this.parentPath;\n  if (this.key === \"key\" && path.isMethod()) path = path.parentPath;\n  let target;\n\n  while (path && !target) {\n    if (path.opts && path.opts.noScope) return;\n    target = path.scope;\n    path = path.parentPath;\n  }\n\n  this.scope = this.getScope(target);\n  if (this.scope) this.scope.init();\n}\n\nfunction setContext(context) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n\n  this._traverseFlags = 0;\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n\n  this.setScope();\n  return this;\n}\n\nfunction resync() {\n  if (this.removed) return;\n\n  this._resyncParent();\n\n  this._resyncList();\n\n  this._resyncKey();\n}\n\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\nfunction _resyncKey() {\n  if (!this.container) return;\n  if (this.node === this.container[this.key]) return;\n\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        return this.setKey(i);\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      if (this.container[key] === this.node) {\n        return this.setKey(key);\n      }\n    }\n  }\n\n  this.key = null;\n}\n\nfunction _resyncList() {\n  if (!this.parent || !this.inList) return;\n  const newContainer = this.parent[this.listKey];\n  if (this.container === newContainer) return;\n  this.container = newContainer || null;\n}\n\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    this._markRemoved();\n  }\n}\n\nfunction popContext() {\n  this.contexts.pop();\n\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\n\nfunction pushContext(context) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\n\nfunction setup(parentPath, container, listKey, key) {\n  this.listKey = listKey;\n  this.container = container;\n  this.parentPath = parentPath || this.parentPath;\n  this.setKey(key);\n}\n\nfunction setKey(key) {\n  var _this$node;\n\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;\n}\n\nfunction requeue(pathToQueue = this) {\n  if (pathToQueue.removed) return;\n  const contexts = this.contexts;\n\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\n\nfunction _getQueueContexts() {\n  let path = this;\n  let contexts = this.contexts;\n\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n\n  return contexts;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.remove = remove;\nexports._removeFromScope = _removeFromScope;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._remove = _remove;\nexports._markRemoved = _markRemoved;\nexports._assertUnremoved = _assertUnremoved;\n\nvar _removalHooks = require(\"./lib/removal-hooks\");\n\nvar _cache = require(\"../cache\");\n\nvar _index = _interopRequireWildcard(require(\"./index\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction remove() {\n  var _this$opts;\n\n  this._assertUnremoved();\n\n  this.resync();\n\n  if (!((_this$opts = this.opts) == null ? void 0 : _this$opts.noScope)) {\n    this._removeFromScope();\n  }\n\n  if (this._callRemovalHooks()) {\n    this._markRemoved();\n\n    return;\n  }\n\n  this.shareCommentsWithSiblings();\n\n  this._remove();\n\n  this._markRemoved();\n}\n\nfunction _removeFromScope() {\n  const bindings = this.getBindingIdentifiers();\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\n\nfunction _callRemovalHooks() {\n  for (const fn of _removalHooks.hooks) {\n    if (fn(this, this.parentPath)) return true;\n  }\n}\n\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    this.updateSiblingKeys(this.key, -1);\n  } else {\n    this._replaceWith(null);\n  }\n}\n\nfunction _markRemoved() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;\n  if (this.parent) _cache.path.get(this.parent).delete(this.node);\n  this.node = null;\n}\n\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\"NodePath has been removed so is read-only.\");\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hooks = void 0;\nconst hooks = [function (self, parent) {\n  const removeParent = self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase()) || self.key === \"declaration\" && parent.isExportDeclaration() || self.key === \"body\" && parent.isLabeledStatement() || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === \"expression\" && parent.isExpressionStatement();\n\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && (self.key === \"consequent\" || self.key === \"alternate\") || self.key === \"body\" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: \"BlockStatement\",\n      body: []\n    });\n    return true;\n  }\n}];\nexports.hooks = hooks;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = _interopRequireDefault(require(\"./lib/hoister\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return t.isExpression(node) ? t.expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        t.assertExpression(node);\n        this.replaceWith(t.callExpression(t.arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", t.cloneNode(temp), node)));\n      nodes.push(t.expressionStatement(t.cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = t.variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = t.jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(t.cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOpposite = getOpposite;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getSibling = getSibling;\nexports.getPrevSibling = getPrevSibling;\nexports.getNextSibling = getNextSibling;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.get = get;\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n\n  return null;\n}\n\nfunction addCompletionRecords(path, paths) {\n  if (path) return paths.concat(path.getCompletionRecords());\n  return paths;\n}\n\nfunction findBreak(statements) {\n  let breakStatement;\n\n  if (!Array.isArray(statements)) {\n    statements = [statements];\n  }\n\n  for (const statement of statements) {\n    if (statement.isDoExpression() || statement.isProgram() || statement.isBlockStatement() || statement.isCatchClause() || statement.isLabeledStatement()) {\n      breakStatement = findBreak(statement.get(\"body\"));\n    } else if (statement.isIfStatement()) {\n      var _findBreak;\n\n      breakStatement = (_findBreak = findBreak(statement.get(\"consequent\"))) != null ? _findBreak : findBreak(statement.get(\"alternate\"));\n    } else if (statement.isTryStatement()) {\n      var _findBreak2;\n\n      breakStatement = (_findBreak2 = findBreak(statement.get(\"block\"))) != null ? _findBreak2 : findBreak(statement.get(\"handler\"));\n    } else if (statement.isBreakStatement()) {\n      breakStatement = statement;\n    }\n\n    if (breakStatement) {\n      return breakStatement;\n    }\n  }\n\n  return null;\n}\n\nfunction completionRecordForSwitch(cases, paths) {\n  let isLastCaseWithConsequent = true;\n\n  for (let i = cases.length - 1; i >= 0; i--) {\n    const switchCase = cases[i];\n    const consequent = switchCase.get(\"consequent\");\n    let breakStatement = findBreak(consequent);\n\n    if (breakStatement) {\n      while (breakStatement.key === 0 && breakStatement.parentPath.isBlockStatement()) {\n        breakStatement = breakStatement.parentPath;\n      }\n\n      const prevSibling = breakStatement.getPrevSibling();\n\n      if (breakStatement.key > 0 && (prevSibling.isExpressionStatement() || prevSibling.isBlockStatement())) {\n        paths = addCompletionRecords(prevSibling, paths);\n        breakStatement.remove();\n      } else {\n        breakStatement.replaceWith(breakStatement.scope.buildUndefinedNode());\n        paths = addCompletionRecords(breakStatement, paths);\n      }\n    } else if (isLastCaseWithConsequent) {\n      const statementFinder = statement => !statement.isBlockStatement() || statement.get(\"body\").some(statementFinder);\n\n      const hasConsequent = consequent.some(statementFinder);\n\n      if (hasConsequent) {\n        paths = addCompletionRecords(consequent[consequent.length - 1], paths);\n        isLastCaseWithConsequent = false;\n      }\n    }\n  }\n\n  return paths;\n}\n\nfunction getCompletionRecords() {\n  let paths = [];\n\n  if (this.isIfStatement()) {\n    paths = addCompletionRecords(this.get(\"consequent\"), paths);\n    paths = addCompletionRecords(this.get(\"alternate\"), paths);\n  } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isProgram() || this.isBlockStatement()) {\n    paths = addCompletionRecords(this.get(\"body\").pop(), paths);\n  } else if (this.isFunction()) {\n    return this.get(\"body\").getCompletionRecords();\n  } else if (this.isTryStatement()) {\n    paths = addCompletionRecords(this.get(\"block\"), paths);\n    paths = addCompletionRecords(this.get(\"handler\"), paths);\n  } else if (this.isCatchClause()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isSwitchStatement()) {\n    paths = completionRecordForSwitch(this.get(\"cases\"), paths);\n  } else {\n    paths.push(this);\n  }\n\n  return paths;\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return t.getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return t.getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  let search = [].concat(path);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = t.getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child) || child.node) {\n          search = search.concat(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\nexports.addComment = addComment;\nexports.addComments = addComments;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction shareCommentsWithSiblings() {\n  if (typeof this.key === \"string\") return;\n  const node = this.node;\n  if (!node) return;\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n\n  if (hasPrev && !hasNext) {\n    prev.addComments(\"trailing\", trailing);\n  } else if (hasNext && !hasPrev) {\n    next.addComments(\"leading\", leading);\n  }\n}\n\nfunction addComment(type, content, line) {\n  t.addComment(this.node, type, content, line);\n}\n\nfunction addComments(type, comments) {\n  t.addComments(this.node, type, comments);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.verify = verify;\nexports.merge = merge;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./path/lib/virtual-types\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      for (const type of wrapper.types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = t.FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecatedKey = t.DEPRECATED_KEYS[nodeType];\n\n    if (deprecatedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`);\n      aliases = [deprecatedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (t.TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors, states = [], wrapper) {\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  const newFn = function (path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\" || key === \"blacklist\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Hub {\n  getCode() {}\n\n  getScope() {}\n\n  addHelper() {\n    throw new Error(\"Helpers are not supported by the default hub.\");\n  }\n\n  buildError(node, msg, Error = TypeError) {\n    return new Error(msg);\n  }\n\n}\n\nexports.default = Hub;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SHOULD_SKIP = exports.SHOULD_STOP = exports.REMOVED = void 0;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./lib/virtual-types\"));\n\nvar _debug = _interopRequireDefault(require(\"debug\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _scope = _interopRequireDefault(require(\"../scope\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nvar _generator = _interopRequireDefault(require(\"@babel/generator\"));\n\nvar NodePath_ancestry = _interopRequireWildcard(require(\"./ancestry\"));\n\nvar NodePath_inference = _interopRequireWildcard(require(\"./inference\"));\n\nvar NodePath_replacement = _interopRequireWildcard(require(\"./replacement\"));\n\nvar NodePath_evaluation = _interopRequireWildcard(require(\"./evaluation\"));\n\nvar NodePath_conversion = _interopRequireWildcard(require(\"./conversion\"));\n\nvar NodePath_introspection = _interopRequireWildcard(require(\"./introspection\"));\n\nvar NodePath_context = _interopRequireWildcard(require(\"./context\"));\n\nvar NodePath_removal = _interopRequireWildcard(require(\"./removal\"));\n\nvar NodePath_modification = _interopRequireWildcard(require(\"./modification\"));\n\nvar NodePath_family = _interopRequireWildcard(require(\"./family\"));\n\nvar NodePath_comments = _interopRequireWildcard(require(\"./comments\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst debug = (0, _debug.default)(\"babel\");\nconst REMOVED = 1 << 0;\nexports.REMOVED = REMOVED;\nconst SHOULD_STOP = 1 << 1;\nexports.SHOULD_STOP = SHOULD_STOP;\nconst SHOULD_SKIP = 1 << 2;\nexports.SHOULD_SKIP = SHOULD_SKIP;\n\nclass NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key\n  }) {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode = container[key];\n\n    let paths = _cache.path.get(parent);\n\n    if (!paths) {\n      paths = new Map();\n\n      _cache.path.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  }\n\n  getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  }\n\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    return this.data[key] = val;\n  }\n\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  buildCodeFrameError(msg, Error = SyntaxError) {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key, node) {\n    t.validate(this.node, key, node);\n    this.node[key] = node;\n  }\n\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  }\n\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n\n}\n\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n\n  NodePath.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === \"_\") continue;\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n  const virtualType = virtualTypes[type];\n\n  NodePath.prototype[`is${type}`] = function (opts) {\n    return virtualType.checkPath(this, opts);\n  };\n}\n\nvar _default = NodePath;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clear = clear;\nexports.clearPath = clearPath;\nexports.clearScope = clearScope;\nexports.scope = exports.path = void 0;\nlet path = new WeakMap();\nexports.path = path;\nlet scope = new WeakMap();\nexports.scope = scope;\n\nfunction clear() {\n  clearPath();\n  clearScope();\n}\n\nfunction clearPath() {\n  exports.path = path = new WeakMap();\n}\n\nfunction clearScope() {\n  exports.scope = scope = new WeakMap();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {\n      if (t.isJSXIdentifier(node, opts)) {\n        if (t.react.isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return t.isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return t.isMemberExpression(node) && t.isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (t.isStatement(node)) {\n      if (t.isVariableDeclaration(node)) {\n        if (t.isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (t.isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t.isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return t.isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return t.isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return t.isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return t.isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (t.isFlow(node)) {\n      return true;\n    } else if (t.isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t.isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (t.isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = _interopRequireDefault(require(\"./lib/renamer\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _binding = _interopRequireDefault(require(\"./binding\"));\n\nvar _globals = _interopRequireDefault(require(\"globals\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (t.isModuleDeclaration(node)) {\n        if ((t.isExportAllDeclaration(node) || t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((t.isExportDefaultDeclaration(node) || t.isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (t.isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (t.isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  For(path) {\n    for (const key of t.FOR_INIT_KEYS) {\n      const declar = path.get(key);\n\n      if (declar.isVar()) {\n        const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        parentScope.registerBinding(\"var\", declar);\n      }\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (t.isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        if (binding) binding.reference(path);\n      } else if (t.isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(t.getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            if (binding) binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const isKey = path.key === \"key\";\n      path = path.parentPath;\n      if (isKey && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return t.cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return t.identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = t.toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return t.identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (t.isThisExpression(node) || t.isSuper(node)) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return t.cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if ((binding == null ? void 0 : binding.constant) && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (t.isArrayExpression(node)) {\n      return node;\n    }\n\n    if (t.isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(\"Array\"), t.identifier(\"prototype\")), t.identifier(\"slice\")), t.identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(t.numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return t.callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return t.unaryExpression(\"void\", t.numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (t.isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (t.isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (t.isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (t.isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (t.isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (t.isTaggedTemplateExpression(node)) {\n      return t.matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (t.isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return t.isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = t.variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = t.variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind(...kinds) {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if (((_previousPath = previousPath) == null ? void 0 : _previousPath.isPattern()) && binding.kind !== \"param\") {} else {\n          return binding;\n        }\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.default.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Binding {\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind\n  }) {\n    this.identifier = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.kind = void 0;\n    this.constantViolations = [];\n    this.constant = true;\n    this.referencePaths = [];\n    this.referenced = false;\n    this.references = 0;\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n    this.clearValue();\n  }\n\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n\n  setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n\n  reassign(path) {\n    this.constant = false;\n\n    if (this.constantViolations.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.constantViolations.push(path);\n  }\n\n  reference(path) {\n    if (this.referencePaths.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n\n}\n\nexports.default = Binding;"],"sourceRoot":""}